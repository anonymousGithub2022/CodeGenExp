text
"<BOS>import re
from thefuck.utils import get_all_matched_commands, replace_command, for_app


@for_app('tsuru')
def match(command):
    return (' is not a tsuru command. See ""tsuru help"".' in command.output
            and '\nDid you mean?\n\t' in command.output)


def get_new_command(command):
    broken_cmd = re.findall(r'tsuru: ""([^""]*)"" is not a tsuru command',
                            command.output)[0]
    return replace_command(command, broken_cmd,
                           get_all_matched_commands(command.output))<EOS>"
"<BOS>import re
from thefuck.utils import for_app

regex = re.compile(r'Run ""(.*)"" instead')


@for_app('yarn', at_least=1)
def match(command):
    return regex.findall(command.output)


def get_new_command(command):
    return regex.findall(command.output)[0]<EOS>"
"<BOS>from thefuck.utils import for_app


@for_app('ag')
def match(command):
    return command.output.endswith('run ag with -Q\n')


def get_new_command(command):
    return command.script.replace('ag', 'ag -Q', 1)<EOS>"
"<BOS>from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('branch -d' in command.script
            and 'If you are sure you want to delete it' in command.output)


@git_support
def get_new_command(command):
    return replace_argument(command.script, '-d', '-D')<EOS>"
"<BOS>import re
from thefuck.shells import shell


patterns = (
    r""mv: cannot move '[^']*' to '([^']*)': No such file or directory"",
    r""mv: cannot move '[^']*' to '([^']*)': Not a directory"",
    r""cp: cannot create regular file '([^']*)': No such file or directory"",
    r""cp: cannot create regular file '([^']*)': Not a directory"",
)


def match(command):
    for pattern in patterns:
        if re.search(pattern, command.output):
            return True

    return False


def get_new_command(command):
    for pattern in patterns:
        file = re.findall(pattern, command.output)

        if file:
            file = file[0]
            dir = file[0:file.rfind('/')]

            formatme = shell.and_('mkdir -p {}', '{}')
            return formatme.format(dir, command.script)<EOS>"
"<BOS>from thefuck.specific.npm import npm_available
from thefuck.utils import replace_argument, for_app, eager, get_closest
from thefuck.specific.sudo import sudo_support

enabled_by_default = npm_available


def _get_wrong_command(script_parts):
    commands = [part for part in script_parts[1:] if not part.startswith('-')]
    if commands:
        return commands[0]


@sudo_support
@for_app('npm')
def match(command):
    return (command.script_parts[0] == 'npm' and
            'where <command> is one of:' in command.output and
            _get_wrong_command(command.script_parts))


@eager
def _get_available_commands(stdout):
    commands_listing = False
    for line in stdout.split('\n'):
        if line.startswith('where <command> is one of:'):
            commands_listing = True
        elif commands_listing:
            if not line:
                break

            for command in line.split(', '):
                stripped = command.strip()
                if stripped:
                    yield stripped


def get_new_command(command):
    npm_commands = _get_available_commands(command.output)
    wrong_command = _get_wrong_command(command.script_parts)
    fixed = get_closest(wrong_command, npm_commands)
    return replace_argument(command.script, wrong_command, fixed)<EOS>"
"<BOS>from collections import Counter
import re
from thefuck.system import Path
from thefuck.utils import (get_valid_history_without_current,
                           memoize, replace_argument)
from thefuck.shells import shell


patterns = [r'no such file or directory: (.*)$',
            r""cannot access '(.*)': No such file or directory"",
            r': (.*): No such file or directory',
            r""can't cd to (.*)$""]


@memoize
def _get_destination(command):
    for pattern in patterns:
        found = re.findall(pattern, command.output)
        if found:
            if found[0] in command.script_parts:
                return found[0]


def match(command):
    return bool(_get_destination(command))


def _get_all_absolute_paths_from_history(command):
    counter = Counter()

    for line in get_valid_history_without_current(command):
        splitted = shell.split_command(line)

        for param in splitted[1:]:
            if param.startswith('/') or param.startswith('~'):
                if param.endswith('/'):
                    param = param[:-1]

                counter[param] += 1

    return (path for path, _ in counter.most_common(None))


def get_new_command(command):
    destination = _get_destination(command)
    paths = _get_all_absolute_paths_from_history(command)

    return [replace_argument(command.script, destination, path)
            for path in paths if path.endswith(destination)
            and Path(path).expanduser().exists()]


priority = 800<EOS>"
"<BOS>from thefuck.utils import for_app, replace_command, eager, memoize
from thefuck.system import Path


@memoize
@eager
def _get_all_environments():
    root = Path('~/.virtualenvs').expanduser()
    if not root.is_dir():
        return

    for child in root.iterdir():
        if child.is_dir():
            yield child.name


@for_app('workon')
def match(command):
    return (len(command.script_parts) >= 2
            and command.script_parts[1] not in _get_all_environments())


def get_new_command(command):
    misspelled_env = command.script_parts[1]
    create_new = u'mkvirtualenv {}'.format(misspelled_env)

    available = _get_all_environments()
    if available:
        return (replace_command(command, misspelled_env, available)
                + [create_new])
    else:
        return create_new<EOS>"
"<BOS>import re
from thefuck.utils import replace_argument, for_app


@for_app('cargo', at_least=1)
def match(command):
    return ('no such subcommand' in command.output.lower()
            and 'Did you mean' in command.output)


def get_new_command(command):
    broken = command.script_parts[1]
    fix = re.findall(r'Did you mean `([^`]*)`', command.output)[0]

    return replace_argument(command.script, broken, fix)<EOS>"
"<BOS>from thefuck.utils import for_app
from thefuck.shells import shell


@for_app('docker')
def match(command):
    '''
    Matches a command's output with docker's output
    warning you that you need to remove a container before removing an image.
    '''
    return 'image is being used by running container' in command.output


def get_new_command(command):
    '''
    Prepends docker container rm -f {container ID} to
    the previous docker image rm {image ID} command
    '''
    container_id = command.output.strip().split(' ')
    return shell.and_('docker container rm -f {}', '{}').format(container_id[-1], command.script)<EOS>"
"<BOS>def match(command):
    split_command = command.script_parts

    return (split_command
            and len(split_command) >= 2
            and split_command[0] == split_command[1])


def get_new_command(command):
    return ' '.join(command.script_parts[1:])


# it should be rare enough to actually have to type twice the same word, so
# this rule can have a higher priority to come before things like ""cd cd foo""
priority = 900<EOS>"
"<BOS>from thefuck.specific.git import git_support


@git_support
def match(command):
    return (' rm ' in command.script
            and ""fatal: not removing '"" in command.output
            and ""' recursively without -r"" in command.output)


@git_support
def get_new_command(command):
    command_parts = command.script_parts[:]
    index = command_parts.index('rm') + 1
    command_parts.insert(index, '-r')
    return u' '.join(command_parts)<EOS>"
"<BOS>import os
from thefuck.specific.sudo import sudo_support


@sudo_support
def match(command):
    return command.script_parts and os.path.exists(command.script_parts[0]) \
        and 'command not found' in command.output


@sudo_support
def get_new_command(command):
    return u'./{}'.format(command.script)<EOS>"
"<BOS>import subprocess
from thefuck.utils import for_app, replace_command, eager


@for_app('ifconfig')
def match(command):
    return 'error fetching interface information: Device not found' \
           in command.output


@eager
def _get_possible_interfaces():
    proc = subprocess.Popen(['ifconfig', '-a'], stdout=subprocess.PIPE)
    for line in proc.stdout.readlines():
        line = line.decode()
        if line and line != '\n' and not line.startswith(' '):
            yield line.split(' ')[0]


def get_new_command(command):
    interface = command.output.split(' ')[0][:-1]
    possible_interfaces = _get_possible_interfaces()
    return replace_command(command, interface, possible_interfaces)<EOS>"
"<BOS>from thefuck.utils import replace_argument
import re

# regex to match a suggested help command from the tool output
help_regex = r""(?:Run|Try) '([^']+)'(?: or '[^']+')? for (?:details|more information).""


def match(command):
    if re.search(help_regex, command.output, re.I) is not None:
        return True

    if '--help' in command.output:
        return True

    return False


def get_new_command(command):
    if re.search(help_regex, command.output) is not None:
        match_obj = re.search(help_regex, command.output, re.I)
        return match_obj.group(1)

    return replace_argument(command.script, '-h', '--help')


enabled_by_default = True
priority = 5000<EOS>"
"<BOS>import re
from thefuck.utils import (cache, for_app, replace_argument, replace_command,
                           which)
from subprocess import PIPE, Popen


supported_apps = 'goenv', 'nodenv', 'pyenv', 'rbenv'
enabled_by_default = any(which(a) for a in supported_apps)


COMMON_TYPOS = {
    'list': ['versions', 'install --list'],
    'remove': ['uninstall'],
}


@for_app(*supported_apps, at_least=1)
def match(command):
    return 'env: no such command ' in command.output


def get_app_commands(app):
    proc = Popen([app, 'commands'], stdout=PIPE)
    return [line.decode('utf-8').strip() for line in proc.stdout.readlines()]


def get_new_command(command):
    broken = re.findall(r""env: no such command ['`]([^']*)'"", command.output)[0]
    matched = [replace_argument(command.script, broken, common_typo)
               for common_typo in COMMON_TYPOS.get(broken, [])]

    app = command.script_parts[0]
    app_commands = cache(which(app))(get_app_commands)(app)
    matched.extend(replace_command(command, broken, app_commands))
    return matched<EOS>"
"<BOS># -*- encoding: utf-8 -*-
from six.moves.urllib.parse import urlparse
from thefuck.utils import for_app


@for_app('whois', at_least=1)
def match(command):
    """"""
    What the `whois` command returns depends on the 'Whois server' it contacted
    and is not consistent through different servers. But there can be only two
    types of errors I can think of with `whois`:
        - `whois https://en.wikipedia.org/` → `whois en.wikipedia.org`;
        - `whois en.wikipedia.org` → `whois wikipedia.org`.
    So we match any `whois` command and then:
        - if there is a slash: keep only the FQDN;
        - if there is no slash but there is a point: removes the left-most
          subdomain.

    We cannot either remove all subdomains because we cannot know which part is
    the subdomains and which is the domain, consider:
        - www.google.fr → subdomain: www, domain: 'google.fr';
        - google.co.uk → subdomain: None, domain; 'google.co.uk'.
    """"""
    return True


def get_new_command(command):
    url = command.script_parts[1]

    if '/' in command.script:
        return 'whois ' + urlparse(url).netloc
    elif '.' in command.script:
        path = urlparse(url).path.split('.')
        return ['whois ' + '.'.join(path[n:]) for n in range(1, len(path))]<EOS>"
"<BOS>import re
from thefuck.utils import replace_command, for_app


@for_app(""conda"")
def match(command):
    """"""
    Match a mistyped command
    """"""
    return ""Did you mean 'conda"" in command.output


def get_new_command(command):
    match = re.findall(r""'conda ([^']*)'"", command.output)
    broken_cmd = match[0]
    correct_cmd = match[1]
    return replace_command(command, broken_cmd, [correct_cmd])<EOS>"
"<BOS>import re
from thefuck.specific.git import git_support

error_pattern = ""fatal: bad flag '(.*?)' used after filename""
error_pattern2 = ""fatal: option '(.*?)' must come before non-option arguments""


@git_support
def match(command):
    return re.search(error_pattern, command.output) or re.search(error_pattern2, command.output)


@git_support
def get_new_command(command):
    command_parts = command.script_parts[:]

    # find the bad flag
    bad_flag = match(command).group(1)
    bad_flag_index = command_parts.index(bad_flag)

    # find the filename
    for index in reversed(range(bad_flag_index)):
        if command_parts[index][0] != '-':
            filename_index = index
            break

    # swap them
    command_parts[bad_flag_index], command_parts[filename_index] = \
    command_parts[filename_index], command_parts[bad_flag_index]  # noqa: E122

    return u' '.join(command_parts)<EOS>"
"<BOS>import re
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ""push"" in command.script and ""The upstream branch of your current branch does not match"" in command.output


@git_support
def get_new_command(command):
    return re.findall(r'^ +(git push [^\s]+ [^\s]+)', command.output, re.MULTILINE)[0]<EOS>"
"<BOS>def match(command):
    return (command.script.startswith(u'man')
            and u'command not found' in command.output.lower())


def get_new_command(command):
    return u'man {}'.format(command.script[3:])


priority = 2000<EOS>"
"<BOS>from thefuck.shells import shell
from thefuck.utils import for_app


@for_app('terraform')
def match(command):
    return ('this module is not yet installed' in command.output.lower() or
            'initialization required' in command.output.lower()
            )


def get_new_command(command):
    return shell.and_('terraform init', command.script)<EOS>"
"<BOS>from thefuck.utils import get_all_executables
from thefuck.specific.sudo import sudo_support


@sudo_support
def match(command):
    first_part = command.script_parts[0]
    if ""-"" not in first_part or first_part in get_all_executables():
        return False
    cmd, _ = first_part.split(""-"", 1)
    return cmd in get_all_executables()


@sudo_support
def get_new_command(command):
    return command.script.replace(""-"", "" "", 1)


priority = 4500
requires_output = False<EOS>"
"<BOS>import re
import subprocess
from thefuck.utils import for_app, eager, replace_command, cache, which


@for_app('gem')
def match(command):
    return ('ERROR:  While executing gem ... (Gem::CommandLineError)'
            in command.output
            and 'Unknown command' in command.output)


def _get_unknown_command(command):
    return re.findall(r'Unknown command (.*)$', command.output)[0]


@eager
def _get_all_commands():
    proc = subprocess.Popen(['gem', 'help', 'commands'],
                            stdout=subprocess.PIPE)

    for line in proc.stdout.readlines():
        line = line.decode()

        if line.startswith('    '):
            yield line.strip().split(' ')[0]


if which('gem'):
    _get_all_commands = cache(which('gem'))(_get_all_commands)


def get_new_command(command):
    unknown_command = _get_unknown_command(command)
    all_commands = _get_all_commands()
    return replace_command(command, unknown_command, all_commands)<EOS>"
"<BOS>from thefuck.shells import shell
from thefuck.specific.git import git_support


@git_support
def match(command):
    # catches ""Please commit or stash them"" and ""Please, commit your changes or
    # stash them before you can switch branches.""
    return 'or stash them' in command.output


@git_support
def get_new_command(command):
    formatme = shell.and_('git stash', '{}')
    return formatme.format(command.script)<EOS>"
"<BOS>import re
from thefuck.utils import for_app


@for_app('heroku')
def match(command):
    return 'https://devcenter.heroku.com/articles/multiple-environments' in command.output


def get_new_command(command):
    apps = re.findall('([^ ]*) \\([^)]*\\)', command.output)
    return [command.script + ' --app ' + app for app in apps]<EOS>"
"<BOS>from thefuck.utils import for_app, get_close_matches, replace_command
import re


def _get_failed_lifecycle(command):
    return re.search(r'\[ERROR\] Unknown lifecycle phase ""(.+)""',
                     command.output)


def _getavailable_lifecycles(command):
    return re.search(
        r'Available lifecycle phases are: (.+) -> \[Help 1\]', command.output)


@for_app('mvn')
def match(command):
    failed_lifecycle = _get_failed_lifecycle(command)
    available_lifecycles = _getavailable_lifecycles(command)
    return available_lifecycles and failed_lifecycle


def get_new_command(command):
    failed_lifecycle = _get_failed_lifecycle(command)
    available_lifecycles = _getavailable_lifecycles(command)
    if available_lifecycles and failed_lifecycle:
        selected_lifecycle = get_close_matches(
            failed_lifecycle.group(1), available_lifecycles.group(1).split("", ""))
        return replace_command(command, failed_lifecycle.group(1), selected_lifecycle)
    else:
        return []<EOS>"
"<BOS>import re
from thefuck.shells import shell

MISSING_MODULE = r""ModuleNotFoundError: No module named '([^']+)'""


def match(command):
    return ""ModuleNotFoundError: No module named '"" in command.output


def get_new_command(command):
    missing_module = re.findall(MISSING_MODULE, command.output)[0]
    return shell.and_(""pip install {}"".format(missing_module), command.script)<EOS>"
"<BOS>from thefuck.utils import is_app, get_closest, replace_argument


_ADB_COMMANDS = (
    'backup',
    'bugreport',
    'connect',
    'devices',
    'disable-verity',
    'disconnect',
    'enable-verity',
    'emu',
    'forward',
    'get-devpath',
    'get-serialno',
    'get-state',
    'install',
    'install-multiple',
    'jdwp',
    'keygen',
    'kill-server',
    'logcat',
    'pull',
    'push',
    'reboot',
    'reconnect',
    'restore',
    'reverse',
    'root',
    'run-as',
    'shell',
    'sideload',
    'start-server',
    'sync',
    'tcpip',
    'uninstall',
    'unroot',
    'usb',
    'wait-for',
)


def match(command):
    return (is_app(command, 'adb')
            and command.output.startswith('Android Debug Bridge version'))


def get_new_command(command):
    for idx, arg in enumerate(command.script_parts[1:]):
        # allowed params to ADB are a/d/e/s/H/P/L where s, H, P and L take additional args
        # for example 'adb -s 111 logcat' or 'adb -e logcat'
        if not arg[0] == '-' and not command.script_parts[idx] in ('-s', '-H', '-P', '-L'):
            adb_cmd = get_closest(arg, _ADB_COMMANDS)
            return replace_argument(command.script, arg, adb_cmd)<EOS>"
"<BOS>from thefuck.specific.apt import apt_available
from thefuck.specific.sudo import sudo_support
from thefuck.utils import for_app

enabled_by_default = apt_available


@sudo_support
@for_app('apt')
def match(command):
    return 'apt list --upgradable' in command.output


@sudo_support
def get_new_command(command):
    return 'apt list --upgradable'<EOS>"
"<BOS>import os
from thefuck.utils import for_app


@for_app('cat', at_least=1)
def match(command):
    return (
        command.output.startswith('cat: ') and
        os.path.isdir(command.script_parts[1])
    )


def get_new_command(command):
    return command.script.replace('cat', 'ls', 1)<EOS>"
"<BOS>import os
import zipfile
from thefuck.utils import for_app
from thefuck.shells import shell


def _is_bad_zip(file):
    try:
        with zipfile.ZipFile(file, 'r') as archive:
            return len(archive.namelist()) > 1
    except Exception:
        return False


def _zip_file(command):
    # unzip works that way:
    # unzip [-flags] file[.zip] [file(s) ...] [-x file(s) ...]
    #                ^          ^ files to unzip from the archive
    #                archive to unzip
    for c in command.script_parts[1:]:
        if not c.startswith('-'):
            if c.endswith('.zip'):
                return c
            else:
                return u'{}.zip'.format(c)


@for_app('unzip')
def match(command):
    if '-d' in command.script:
        return False

    zip_file = _zip_file(command)
    if zip_file:
        return _is_bad_zip(zip_file)
    else:
        return False


def get_new_command(command):
    return u'{} -d {}'.format(
        command.script, shell.quote(_zip_file(command)[:-4]))


def side_effect(old_cmd, command):
    with zipfile.ZipFile(_zip_file(old_cmd), 'r') as archive:
        for file in archive.namelist():
            if not os.path.abspath(file).startswith(os.getcwd()):
                # it's unsafe to overwrite files outside of the current directory
                continue

            try:
                os.remove(file)
            except OSError:
                # does not try to remove directories as we cannot know if they
                # already existed before
                pass


requires_output = False<EOS>"
"<BOS>from thefuck.shells import shell
from thefuck.specific.git import git_support
from thefuck.utils import replace_argument


@git_support
def match(command):
    return (
        (""branch -d"" in command.script or ""branch -D"" in command.script)
        and ""error: Cannot delete branch '"" in command.output
        and ""' checked out at '"" in command.output
    )


@git_support
def get_new_command(command):
    return shell.and_(""git checkout master"", ""{}"").format(
        replace_argument(command.script, ""-d"", ""-D"")
    )<EOS>"
"<BOS># Fixes careless "" and ' usage
#
# Example:
# > git commit -m 'My Message""


def match(command):
    return '\'' in command.script and '\""' in command.script


def get_new_command(command):
    return command.script.replace('\'', '\""')<EOS>"
"<BOS>from types import ModuleType
from thefuck.specific.apt import apt_available
from thefuck.utils import memoize, which
from thefuck.shells import shell

try:
    from CommandNotFound import CommandNotFound

    enabled_by_default = apt_available

    if isinstance(CommandNotFound, ModuleType):
        # For ubuntu 18.04+
        _get_packages = CommandNotFound.CommandNotFound().get_packages
    else:
        # For older versions
        _get_packages = CommandNotFound().getPackages
except ImportError:
    enabled_by_default = False


def _get_executable(command):
    if command.script_parts[0] == 'sudo':
        return command.script_parts[1]
    else:
        return command.script_parts[0]


@memoize
def get_package(executable):
    try:
        packages = _get_packages(executable)
        return packages[0][0]
    except IndexError:
        # IndexError is thrown when no matching package is found
        return None


def match(command):
    if 'not found' in command.output or 'not installed' in command.output:
        executable = _get_executable(command)
        return not which(executable) and get_package(executable)
    else:
        return False


def get_new_command(command):
    executable = _get_executable(command)
    name = get_package(executable)
    formatme = shell.and_('sudo apt-get install {}', '{}')
    return formatme.format(name, command.script)<EOS>"
"<BOS>import subprocess
from thefuck.specific.apt import apt_available
from thefuck.specific.sudo import sudo_support
from thefuck.utils import for_app, eager, replace_command

enabled_by_default = apt_available


@sudo_support
@for_app('apt', 'apt-get', 'apt-cache')
def match(command):
    return 'E: Invalid operation' in command.output


@eager
def _parse_apt_operations(help_text_lines):
    is_commands_list = False
    for line in help_text_lines:
        line = line.decode().strip()
        if is_commands_list and line:
            yield line.split()[0]
        elif line.startswith('Basic commands:') \
                or line.startswith('Most used commands:'):
            is_commands_list = True


@eager
def _parse_apt_get_and_cache_operations(help_text_lines):
    is_commands_list = False
    for line in help_text_lines:
        line = line.decode().strip()
        if is_commands_list:
            if not line:
                return

            yield line.split()[0]
        elif line.startswith('Commands:') \
                or line.startswith('Most used commands:'):
            is_commands_list = True


def _get_operations(app):
    proc = subprocess.Popen([app, '--help'],
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    lines = proc.stdout.readlines()

    if app == 'apt':
        return _parse_apt_operations(lines)
    else:
        return _parse_apt_get_and_cache_operations(lines)


@sudo_support
def get_new_command(command):
    invalid_operation = command.output.split()[-1]

    if invalid_operation == 'uninstall':
        return [command.script.replace('uninstall', 'remove')]

    else:
        operations = _get_operations(command.script_parts[0])
        return replace_command(command, invalid_operation, operations)<EOS>"
"<BOS>""""""Attempts to spellcheck and correct failed cd commands""""""

import os
import six
from thefuck.specific.sudo import sudo_support
from thefuck.rules import cd_mkdir
from thefuck.utils import for_app, get_close_matches

__author__ = ""mmussomele""

MAX_ALLOWED_DIFF = 0.6


def _get_sub_dirs(parent):
    """"""Returns a list of the child directories of the given parent directory""""""
    return [child for child in os.listdir(parent) if os.path.isdir(os.path.join(parent, child))]


@sudo_support
@for_app('cd')
def match(command):
    """"""Match function copied from cd_mkdir.py""""""
    return (
        command.script.startswith('cd ') and any((
            'no such file or directory' in command.output.lower(),
            'cd: can\'t cd to' in command.output.lower(),
            'does not exist' in command.output.lower()
        )))


@sudo_support
def get_new_command(command):
    """"""
    Attempt to rebuild the path string by spellchecking the directories.
    If it fails (i.e. no directories are a close enough match), then it
    defaults to the rules of cd_mkdir.
    Change sensitivity by changing MAX_ALLOWED_DIFF. Default value is 0.6
    """"""
    dest = command.script_parts[1].split(os.sep)
    if dest[-1] == '':
        dest = dest[:-1]

    if dest[0] == '':
        cwd = os.sep
        dest = dest[1:]
    elif six.PY2:
        cwd = os.getcwdu()
    else:
        cwd = os.getcwd()
    for directory in dest:
        if directory == ""."":
            continue
        elif directory == "".."":
            cwd = os.path.split(cwd)[0]
            continue
        best_matches = get_close_matches(directory, _get_sub_dirs(cwd), cutoff=MAX_ALLOWED_DIFF)
        if best_matches:
            cwd = os.path.join(cwd, best_matches[0])
        else:
            return cd_mkdir.get_new_command(command)
    return u'cd ""{0}""'.format(cwd)<EOS>"
"<BOS>import re
from thefuck.utils import replace_command
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('bisect' in command.script_parts and
            'usage: git bisect' in command.output)


@git_support
def get_new_command(command):
    broken = re.findall(r'git bisect ([^ $]*).*', command.script)[0]
    usage = re.findall(r'usage: git bisect \[([^\]]+)\]', command.output)[0]
    return replace_command(command, broken, usage.split('|'))<EOS>"
"<BOS>import re
from thefuck.utils import get_all_matched_commands, replace_command
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ("" is not a git command. See 'git --help'."" in command.output
            and ('The most similar command' in command.output
                 or 'Did you mean' in command.output))


@git_support
def get_new_command(command):
    broken_cmd = re.findall(r""git: '([^']*)' is not a git command"",
                            command.output)[0]
    matched = get_all_matched_commands(command.output, ['The most similar command', 'Did you mean'])
    return replace_command(command, broken_cmd, matched)<EOS>"
"<BOS>import re
from thefuck.specific.sudo import sudo_support
from thefuck.utils import replace_command, for_app

no_command = ""Error: No such command""
no_website = ""hostscli.errors.WebsiteImportError""


@sudo_support
@for_app('hostscli')
def match(command):
    errors = [no_command, no_website]
    for error in errors:
        if error in command.output:
            return True
    return False


@sudo_support
def get_new_command(command):
    if no_website in command.output:
        return ['hostscli websites']

    misspelled_command = re.findall(
        r'Error: No such command "".*""', command.output)[0]
    commands = ['block', 'unblock', 'websites', 'block_all', 'unblock_all']
    return replace_command(command, misspelled_command, commands)<EOS>"
"<BOS>""""""Appends .java when compiling java files

Example:
 > javac foo
 error: Class names, 'foo', are only accepted if annotation
 processing is explicitly requested

""""""
from thefuck.utils import for_app


@for_app('javac')
def match(command):
    return not command.script.endswith('.java')


def get_new_command(command):
    return command.script + '.java'<EOS>"
"<BOS>from thefuck.utils import for_app


@for_app('mvn')
def match(command):
    return 'No goals have been specified for this build' in command.output


def get_new_command(command):
    return [command.script + ' clean package',
            command.script + ' clean install']<EOS>"
"<BOS>from thefuck.utils import for_app


@for_app('brew', at_least=2)
def match(command):
    return (command.script_parts[1] in ['uninstall', 'rm', 'remove']
            and ""brew uninstall --force"" in command.output)


def get_new_command(command):
    command_parts = command.script_parts[:]
    command_parts[1] = 'uninstall'
    command_parts.insert(2, '--force')
    return ' '.join(command_parts)<EOS>"
"<BOS>from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('fatal: Not a git repository' in command.output
            and ""Stopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set)."" in command.output)


@git_support
def get_new_command(command):
    return replace_argument(command.script, 'pull', 'clone')<EOS>"
"<BOS>import re
import subprocess
from thefuck.utils import replace_command, for_app, cache


@for_app('gulp')
def match(command):
    return 'is not in your gulpfile' in command.output


@cache('gulpfile.js')
def get_gulp_tasks():
    proc = subprocess.Popen(['gulp', '--tasks-simple'],
                            stdout=subprocess.PIPE)
    return [line.decode('utf-8')[:-1]
            for line in proc.stdout.readlines()]


def get_new_command(command):
    wrong_task = re.findall(r""Task '(\w+)' is not in your gulpfile"",
                            command.output)[0]
    return replace_command(command, wrong_task, get_gulp_tasks())<EOS>"
"<BOS>import re
from thefuck.utils import replace_command, get_all_matched_commands, for_app
from thefuck.specific.sudo import sudo_support


@sudo_support
@for_app('lein')
def match(command):
    return (command.script.startswith('lein')
            and ""is not a task. See 'lein help'"" in command.output
            and 'Did you mean this?' in command.output)


@sudo_support
def get_new_command(command):
    broken_cmd = re.findall(r""'([^']*)' is not a task"",
                            command.output)[0]
    new_cmds = get_all_matched_commands(command.output, 'Did you mean this?')
    return replace_command(command, broken_cmd, new_cmds)<EOS>"
"<BOS>from thefuck.utils import replace_argument, for_app


@for_app('php', at_least=2)
def match(command):
    return ('-s' in command.script_parts
            and command.script_parts[-1] != '-s')


def get_new_command(command):
    return replace_argument(command.script, ""-s"", ""-S"")<EOS>"
"<BOS># Adds the missing space between the cd command and the target directory
# when trying to cd to the parent directory.
#
# Does not really save chars, but is fun :D
#
# Example:
# > cd..
# cd..: command not found


def match(command):
    return command.script == 'cd..'


def get_new_command(command):
    return 'cd ..'<EOS>"
"<BOS># -*- encoding: utf-8 -*-

import re
from thefuck.specific.sudo import sudo_support


@sudo_support
def match(command):
    return ('command not found' in command.output.lower()
            and u' ' in command.script)


@sudo_support
def get_new_command(command):
    return re.sub(u' ', ' ', command.script)<EOS>"
"<BOS>from thefuck.specific.git import git_support


@git_support
def match(command):
    return (
        {'rebase', '--continue'}.issubset(command.script_parts) and
        'No changes - did you forget to use \'git add\'?' in command.output
    )


def get_new_command(command):
    return 'git rebase --skip'<EOS>"
"<BOS>from thefuck.specific.git import git_support


@git_support
def match(command):
    return (' rm ' in command.script and
            'error: the following file has changes staged in the index' in command.output and
            'use --cached to keep the file, or -f to force removal' in command.output)


@git_support
def get_new_command(command):
    command_parts = command.script_parts[:]
    index = command_parts.index('rm') + 1
    command_parts.insert(index, '--cached')
    command_list = [u' '.join(command_parts)]
    command_parts[index] = '-f'
    command_list.append(u' '.join(command_parts))
    return command_list<EOS>"
"<BOS>from thefuck.utils import for_app
# Appends .go when compiling go files
#
# Example:
# > go run foo
# error: go run: no go files listed


@for_app('go')
def match(command):
    return (command.script.startswith('go run ')
            and not command.script.endswith('.go'))


def get_new_command(command):
    return command.script + '.go'<EOS>"
"<BOS>from thefuck.utils import for_app


@for_app('man', at_least=1)
def match(command):
    return True


def get_new_command(command):
    if '3' in command.script:
        return command.script.replace(""3"", ""2"")
    if '2' in command.script:
        return command.script.replace(""2"", ""3"")

    last_arg = command.script_parts[-1]
    help_command = last_arg + ' --help'

    # If there are no man pages for last_arg, suggest `last_arg --help` instead.
    # Otherwise, suggest `--help` after suggesting other man page sections.
    if command.output.strip() == 'No manual entry for ' + last_arg:
        return [help_command]

    split_cmd2 = command.script_parts
    split_cmd3 = split_cmd2[:]

    split_cmd2.insert(1, ' 2 ')
    split_cmd3.insert(1, ' 3 ')

    return [
        """".join(split_cmd3),
        """".join(split_cmd2),
        help_command,
    ]<EOS>"
"<BOS># Appends .py when executing python files
#
# Example:
# > python foo
# error: python: can't open file 'foo': [Errno 2] No such file or directory
from thefuck.utils import for_app


@for_app('python')
def match(command):
    return not command.script.endswith('.py')


def get_new_command(command):
    return command.script + '.py'<EOS>"
"<BOS>from thefuck.utils import for_app, eager
from thefuck.shells import shell
from thefuck.specific.brew import brew_available


@for_app('brew')
def match(command):
    return (u'install' in command.script_parts
            and u'brew cask install' in command.output)


@eager
def _get_cask_install_lines(output):
    for line in output.split('\n'):
        line = line.strip()
        if line.startswith('brew cask install'):
            yield line


def _get_script_for_brew_cask(output):
    cask_install_lines = _get_cask_install_lines(output)
    if len(cask_install_lines) > 1:
        return shell.and_(*cask_install_lines)
    else:
        return cask_install_lines[0]


def get_new_command(command):
    brew_cask_script = _get_script_for_brew_cask(command.output)
    return shell.and_(brew_cask_script, command.script)


enabled_by_default = brew_available<EOS>"
"<BOS>import os
import re
from thefuck.utils import get_closest, replace_command
from thefuck.specific.brew import get_brew_path_prefix, brew_available

BREW_CMD_PATH = '/Homebrew/Library/Homebrew/cmd'
TAP_PATH = '/Homebrew/Library/Taps'
TAP_CMD_PATH = '/%s/%s/cmd'

enabled_by_default = brew_available


def _get_brew_commands(brew_path_prefix):
    """"""To get brew default commands on local environment""""""
    brew_cmd_path = brew_path_prefix + BREW_CMD_PATH

    return [name[:-3] for name in os.listdir(brew_cmd_path)
            if name.endswith(('.rb', '.sh'))]


def _get_brew_tap_specific_commands(brew_path_prefix):
    """"""To get tap's specific commands
    https://github.com/Homebrew/homebrew/blob/master/Library/brew.rb#L115""""""
    commands = []
    brew_taps_path = brew_path_prefix + TAP_PATH

    for user in _get_directory_names_only(brew_taps_path):
        taps = _get_directory_names_only(brew_taps_path + '/%s' % user)

        # Brew Taps's naming rule
        # https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/brew-tap.md#naming-conventions-and-limitations
        taps = (tap for tap in taps if tap.startswith('homebrew-'))
        for tap in taps:
            tap_cmd_path = brew_taps_path + TAP_CMD_PATH % (user, tap)

            if os.path.isdir(tap_cmd_path):
                commands += (name.replace('brew-', '').replace('.rb', '')
                             for name in os.listdir(tap_cmd_path)
                             if _is_brew_tap_cmd_naming(name))

    return commands


def _is_brew_tap_cmd_naming(name):
    return name.startswith('brew-') and name.endswith('.rb')


def _get_directory_names_only(path):
    return [d for d in os.listdir(path)
            if os.path.isdir(os.path.join(path, d))]


def _brew_commands():
    brew_path_prefix = get_brew_path_prefix()
    if brew_path_prefix:
        try:
            return (_get_brew_commands(brew_path_prefix)
                    + _get_brew_tap_specific_commands(brew_path_prefix))
        except OSError:
            pass

    # Failback commands for testing (Based on Homebrew 0.9.5)
    return ['info', 'home', 'options', 'install', 'uninstall',
            'search', 'list', 'update', 'upgrade', 'pin', 'unpin',
            'doctor', 'create', 'edit', 'cask']


def match(command):
    is_proper_command = ('brew' in command.script and
                         'Unknown command' in command.output)

    if is_proper_command:
        broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',
                                command.output)[0]
        return bool(get_closest(broken_cmd, _brew_commands()))
    return False


def get_new_command(command):
    broken_cmd = re.findall(r'Error: Unknown command: ([a-z]+)',
                            command.output)[0]
    return replace_command(command, broken_cmd, _brew_commands())<EOS>"
"<BOS># -*- encoding: utf-8 -*-

# Redirects cs to cd when there is a typo
# Due to the proximity of the keys - d and s - this seems like a common typo
# ~ > cs /etc/
# cs: command not found
# ~ > fuck
# cd /etc/ [enter/↑/↓/ctrl+c]
# /etc >


def match(command):
    if command.script_parts[0] == 'cs':
        return True


def get_new_command(command):
    return 'cd' + ''.join(command.script[2:])


priority = 900<EOS>"
"<BOS>from thefuck.utils import for_app, which


@for_app(""choco"", ""cinst"")
def match(command):
    return ((command.script.startswith('choco install') or 'cinst' in command.script_parts)
            and 'Installing the following packages' in command.output)


def get_new_command(command):
    # Find the argument that is the package name
    for script_part in command.script_parts:
        if (
            script_part not in [""choco"", ""cinst"", ""install""]
            # Need exact match (bc chocolatey is a package)
            and not script_part.startswith('-')
            # Leading hyphens are parameters; some packages contain them though
            and '=' not in script_part and '/' not in script_part
            # These are certainly parameters
        ):
            return command.script.replace(script_part, script_part + "".install"")
    return []


enabled_by_default = bool(which(""choco"")) or bool(which(""cinst""))<EOS>"
"<BOS>from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('diff' in command.script and
            '--staged' not in command.script)


@git_support
def get_new_command(command):
    return replace_argument(command.script, 'diff', 'diff --staged')<EOS>"
"<BOS>from thefuck.utils import replace_argument
from thefuck.specific.git import git_support

hooked_commands = (""am"", ""commit"", ""push"")


@git_support
def match(command):
    return any(
        hooked_command in command.script_parts for hooked_command in hooked_commands
    )


@git_support
def get_new_command(command):
    hooked_command = next(
        hooked_command
        for hooked_command in hooked_commands
        if hooked_command in command.script_parts
    )
    return replace_argument(
        command.script, hooked_command, hooked_command + "" --no-verify""
    )


priority = 1100
requires_output = False<EOS>"
"<BOS>from thefuck.utils import for_app


@for_app('grep')
def match(command):
    return 'is a directory' in command.output.lower()


def get_new_command(command):
    return u'grep -r {}'.format(command.script[5:])<EOS>"
"<BOS>from thefuck.utils import for_app


@for_app('ls')
def match(command):
    return command.output.strip() == ''


def get_new_command(command):
    return ' '.join(['ls', '-A'] + command.script_parts[1:])<EOS>"
"<BOS>from thefuck.utils import get_all_executables, memoize


@memoize
def _get_executable(script_part):
    for executable in get_all_executables():
        if len(executable) > 1 and script_part.startswith(executable):
            return executable


def match(command):
    return (not command.script_parts[0] in get_all_executables()
            and _get_executable(command.script_parts[0]))


def get_new_command(command):
    executable = _get_executable(command.script_parts[0])
    return command.script.replace(executable, u'{} '.format(executable), 1)


priority = 4000<EOS>"
"<BOS>from thefuck.utils import get_all_executables, get_close_matches, \
    get_valid_history_without_current, get_closest, which
from thefuck.specific.sudo import sudo_support


@sudo_support
def match(command):
    return (not which(command.script_parts[0])
            and ('not found' in command.output
                 or 'is not recognized as' in command.output)
            and bool(get_close_matches(command.script_parts[0],
                                       get_all_executables())))


def _get_used_executables(command):
    for script in get_valid_history_without_current(command):
        yield script.split(' ')[0]


@sudo_support
def get_new_command(command):
    old_command = command.script_parts[0]

    # One from history:
    already_used = get_closest(
        old_command, _get_used_executables(command),
        fallback_to_first=False)
    if already_used:
        new_cmds = [already_used]
    else:
        new_cmds = []

    # Other from all executables:
    new_cmds += [cmd for cmd in get_close_matches(old_command,
                                                  get_all_executables())
                 if cmd not in new_cmds]

    return [' '.join([new_command] + command.script_parts[1:])
            for new_command in new_cmds]


priority = 3000<EOS>"
"<BOS>import re
from subprocess import Popen, PIPE
from thefuck.utils import for_app, replace_command, cache, eager


@for_app('react-native')
def match(command):
    return re.findall(r""Unrecognized command '.*'"", command.output)


@cache('package.json')
@eager
def _get_commands():
    proc = Popen(['react-native', '--help'], stdout=PIPE)
    should_yield = False
    for line in proc.stdout.readlines():
        line = line.decode().strip()

        if not line:
            continue

        if 'Commands:' in line:
            should_yield = True
            continue

        if should_yield:
            yield line.split(' ')[0]


def get_new_command(command):
    misspelled_command = re.findall(r""Unrecognized command '(.*)'"",
                                    command.output)[0]
    commands = _get_commands()
    return replace_command(command, misspelled_command, commands)<EOS>"
"<BOS>import re
from thefuck.shells import shell
from thefuck.utils import for_app


@for_app('touch')
def match(command):
    return 'No such file or directory' in command.output


def get_new_command(command):
    path = re.findall(
        r""touch: (?:cannot touch ')?(.+)/.+'?:"", command.output)[0]
    return shell.and_(u'mkdir -p {}'.format(path), command.script)<EOS>"
"<BOS>import re

from thefuck.utils import for_app, replace_argument

INVALID_CHOICE = ""(?<=Invalid choice: ')(.*)(?=', maybe you meant:)""
OPTIONS = ""^\\s*\\*\\s(.*)""


@for_app('aws')
def match(command):
    return ""usage:"" in command.output and ""maybe you meant:"" in command.output


def get_new_command(command):
    mistake = re.search(INVALID_CHOICE, command.output).group(0)
    options = re.findall(OPTIONS, command.output, flags=re.MULTILINE)
    return [replace_argument(command.script, mistake, o) for o in options]<EOS>"
"<BOS>import re
from thefuck.utils import for_app
from thefuck.specific.sudo import sudo_support
from thefuck.shells import shell


@sudo_support
@for_app('cd')
def match(command):
    return (
        command.script.startswith('cd ') and any((
            'no such file or directory' in command.output.lower(),
            'cd: can\'t cd to' in command.output.lower(),
            'does not exist' in command.output.lower()
        )))


@sudo_support
def get_new_command(command):
    repl = shell.and_('mkdir -p \\1', 'cd \\1')
    return re.sub(r'^cd (.*)', repl, command.script)<EOS>"
"<BOS>import re
from thefuck.utils import replace_argument, for_app


@for_app('composer')
def match(command):
    return (('did you mean this?' in command.output.lower()
             or 'did you mean one of these?' in command.output.lower())) or (
        ""install"" in command.script_parts and ""composer require"" in command.output.lower()
    )


def get_new_command(command):
    if ""install"" in command.script_parts and ""composer require"" in command.output.lower():
        broken_cmd, new_cmd = ""install"", ""require""
    else:
        broken_cmd = re.findall(r""Command \""([^']*)\"" is not defined"", command.output)[0]
        new_cmd = re.findall(r'Did you mean this\?[^\n]*\n\s*([^\n]*)', command.output)
        if not new_cmd:
            new_cmd = re.findall(r'Did you mean one of these\?[^\n]*\n\s*([^\n]*)', command.output)
        new_cmd = new_cmd[0].strip()
    return replace_argument(command.script, broken_cmd, new_cmd)<EOS>"
"<BOS>from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('commit' in command.script_parts)


@git_support
def get_new_command(command):
    return 'git commit --amend'<EOS>"
"<BOS>from thefuck.shells import shell
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('push' in command.script and
            '! [rejected]' in command.output and
            'failed to push some refs to' in command.output and
            ('Updates were rejected because the tip of your'
             ' current branch is behind' in command.output or
             'Updates were rejected because the remote '
             'contains work that you do' in command.output))


@git_support
def get_new_command(command):
    return shell.and_(replace_argument(command.script, 'push', 'pull'),
                      command.script)<EOS>"
"<BOS>import re
from thefuck.specific.sudo import sudo_support


@sudo_support
def match(command):
    return ('mkdir' in command.script
            and 'No such file or directory' in command.output)


@sudo_support
def get_new_command(command):
    return re.sub('\\bmkdir (.*)', 'mkdir -p \\1', command.script)<EOS>"
"<BOS>from thefuck.utils import for_app


@for_app('g++', 'clang++')
def match(command):
    return ('This file requires compiler and library support for the '
            'ISO C++ 2011 standard.' in command.output or
            '-Wc++11-extensions' in command.output)


def get_new_command(command):
    return command.script + ' -std=c++11'<EOS>"
"<BOS>from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('commit' in command.script_parts)


@git_support
def get_new_command(command):
    return 'git reset HEAD~'<EOS>"
"<BOS>import re
from thefuck.shells import shell
from thefuck.specific.git import git_support


@git_support
def match(command):
    return bool(re.search(r""src refspec \w+ does not match any"", command.output))


def get_new_command(command):
    return shell.and_('git commit -m ""Initial commit""', command.script)<EOS>"
"<BOS>from thefuck.utils import get_close_matches
from thefuck.specific.git import git_support


@git_support
def match(command):
    return (' rebase' in command.script and
            'It seems that there is already a rebase-merge directory' in command.output and
            'I wonder if you are in the middle of another rebase' in command.output)


@git_support
def get_new_command(command):
    command_list = ['git rebase --continue', 'git rebase --abort', 'git rebase --skip']
    rm_cmd = command.output.split('\n')[-4]
    command_list.append(rm_cmd.strip())
    return get_close_matches(command.script, command_list, 4, 0)<EOS>"
"<BOS>from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('error: did you mean `' in command.output
            and '` (with two dashes ?)' in command.output)


@git_support
def get_new_command(command):
    to = command.output.split('`')[1]
    return replace_argument(command.script, to[1:], to)<EOS>"
"<BOS>import re
from subprocess import Popen, PIPE
from thefuck.utils import for_app, eager, replace_command

regex = re.compile(r""Task '(.*)' (is ambiguous|not found)"")


@for_app('gradle', 'gradlew')
def match(command):
    return regex.findall(command.output)


@eager
def _get_all_tasks(gradle):
    proc = Popen([gradle, 'tasks'], stdout=PIPE)
    should_yield = False
    for line in proc.stdout.readlines():
        line = line.decode().strip()
        if line.startswith('----'):
            should_yield = True
            continue

        if not line.strip():
            should_yield = False
            continue

        if should_yield and not line.startswith('All tasks runnable from root project'):
            yield line.split(' ')[0]


def get_new_command(command):
    wrong_task = regex.findall(command.output)[0][0]
    all_tasks = _get_all_tasks(command.script_parts[0])
    return replace_command(command, wrong_task, all_tasks)<EOS>"
"<BOS>import os
from thefuck.specific.sudo import sudo_support


def _get_destination(script_parts):
    """"""When arguments order is wrong first argument will be destination.""""""
    for part in script_parts:
        if part not in {'ln', '-s', '--symbolic'} and os.path.exists(part):
            return part


@sudo_support
def match(command):
    return (command.script_parts[0] == 'ln'
            and {'-s', '--symbolic'}.intersection(command.script_parts)
            and 'File exists' in command.output
            and _get_destination(command.script_parts))


@sudo_support
def get_new_command(command):
    destination = _get_destination(command.script_parts)
    parts = command.script_parts[:]
    parts.remove(destination)
    parts.append(destination)
    return ' '.join(parts)<EOS>"
"<BOS>import re
from thefuck.utils import get_closest, for_app


def extract_possibilities(command):
    possib = re.findall(r'\n\(did you mean one of ([^\?]+)\?\)', command.output)
    if possib:
        return possib[0].split(', ')
    possib = re.findall(r'\n    ([^$]+)$', command.output)
    if possib:
        return possib[0].split(' ')
    return possib


@for_app('hg')
def match(command):
    return ('hg: unknown command' in command.output
            and '(did you mean one of ' in command.output
            or ""hg: command '"" in command.output
            and ""' is ambiguous:"" in command.output)


def get_new_command(command):
    script = command.script_parts[:]
    possibilities = extract_possibilities(command)
    script[1] = get_closest(script[1], possibilities)
    return ' '.join(script)<EOS>"
"<BOS>def match(command):
    return command.script == 'test.py' and 'not found' in command.output


def get_new_command(command):
    return 'py.test'


# make it come before the python_command rule
priority = 900<EOS>"
"<BOS>from thefuck.specific.apt import apt_available
from thefuck.specific.sudo import sudo_support
from thefuck.utils import for_app

enabled_by_default = apt_available


@sudo_support
@for_app('apt')
def match(command):
    return command.script == ""apt list --upgradable"" and len(command.output.strip().split('\n')) > 1


@sudo_support
def get_new_command(command):
    return 'apt upgrade'<EOS>"
"<BOS>import subprocess
import re
from thefuck.specific.sudo import sudo_support
from thefuck.utils import for_app, replace_command
from thefuck.specific.dnf import dnf_available


regex = re.compile(r'No such command: (.*)\.')


@sudo_support
@for_app('dnf')
def match(command):
    return 'no such command' in command.output.lower()


def _parse_operations(help_text_lines):
    operation_regex = re.compile(r'^([a-z-]+) +', re.MULTILINE)
    return operation_regex.findall(help_text_lines)


def _get_operations():
    proc = subprocess.Popen([""dnf"", '--help'],
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    lines = proc.stdout.read().decode(""utf-8"")

    return _parse_operations(lines)


@sudo_support
def get_new_command(command):
    misspelled_command = regex.findall(command.output)[0]
    return replace_command(command, misspelled_command, _get_operations())


enabled_by_default = dnf_available<EOS>"
"<BOS>from thefuck.specific.git import git_support


@git_support
def match(command):
    return (' git clone ' in command.script
            and 'fatal: Too many arguments.' in command.output)


@git_support
def get_new_command(command):
    return command.script.replace(' git clone ', ' ', 1)<EOS>"
"<BOS>import re
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('merge' in command.script
            and ' - not something we can merge' in command.output
            and 'Did you mean this?' in command.output)


@git_support
def get_new_command(command):
    unknown_branch = re.findall(r'merge: (.+) - not something we can merge', command.output)[0]
    remote_branch = re.findall(r'Did you mean this\?\n\t([^\n]+)', command.output)[0]

    return replace_argument(command.script, unknown_branch, remote_branch)<EOS>"
"<BOS>from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('merge' in command.script
            and 'fatal: refusing to merge unrelated histories' in command.output)


@git_support
def get_new_command(command):
    return command.script + ' --allow-unrelated-histories'<EOS>"
"<BOS>import os
from thefuck.utils import for_app


def _is_recursive(part):
    if part == '--recurse':
        return True
    elif not part.startswith('--') and part.startswith('-') and 'r' in part:
        return True


def _isdir(part):
    return not part.startswith('-') and os.path.isdir(part)


@for_app('prove')
def match(command):
    return (
        'NOTESTS' in command.output
        and not any(_is_recursive(part) for part in command.script_parts[1:])
        and any(_isdir(part) for part in command.script_parts[1:]))


def get_new_command(command):
    parts = command.script_parts[:]
    parts.insert(1, '-r')
    return u' '.join(parts)<EOS>"
"<BOS>from thefuck.utils import for_app


@for_app('brew', at_least=2)
def match(command):
    return (command.script_parts[1] in ['ln', 'link']
            and ""brew link --overwrite --dry-run"" in command.output)


def get_new_command(command):
    command_parts = command.script_parts[:]
    command_parts[1] = 'link'
    command_parts.insert(2, '--overwrite')
    command_parts.insert(3, '--dry-run')
    return ' '.join(command_parts)<EOS>"
"<BOS>def match(command):
    return 'manage.py' in command.script and \
           'migrate' in command.script \
           and '--merge: will just attempt the migration' in command.output


def get_new_command(command):
    return u'{} --merge'.format(command.script)<EOS>"
"<BOS>from thefuck.specific.git import git_support


@git_support
def match(command):
    return (' rm ' in command.script and
            'error: the following file has local modifications' in command.output and
            'use --cached to keep the file, or -f to force removal' in command.output)


@git_support
def get_new_command(command):
    command_parts = command.script_parts[:]
    index = command_parts.index('rm') + 1
    command_parts.insert(index, '--cached')
    command_list = [u' '.join(command_parts)]
    command_parts[index] = '-f'
    command_list.append(u' '.join(command_parts))
    return command_list<EOS>"
"<BOS>from thefuck.utils import for_app


@for_app('ls')
def match(command):
    return command.script_parts and 'ls -' not in command.script


def get_new_command(command):
    command = command.script_parts[:]
    command[0] = 'ls -lah'
    return ' '.join(command)<EOS>"
"<BOS>import re
from thefuck.utils import replace_command, for_app


@for_app('tmux')
def match(command):
    return ('ambiguous command:' in command.output
            and 'could be:' in command.output)


def get_new_command(command):
    cmd = re.match(r""ambiguous command: (.*), could be: (.*)"",
                   command.output)

    old_cmd = cmd.group(1)
    suggestions = [c.strip() for c in cmd.group(2).split(',')]

    return replace_command(command, old_cmd, suggestions)<EOS>"
"<BOS>import os
from thefuck.shells import shell


def match(command):
    return (command.script.startswith('./')
            and 'permission denied' in command.output.lower()
            and os.path.exists(command.script_parts[0])
            and not os.access(command.script_parts[0], os.X_OK))


def get_new_command(command):
    return shell.and_(
        'chmod +x {}'.format(command.script_parts[0][2:]),
        command.script)<EOS>"
"<BOS>from thefuck.utils import for_app
from thefuck.shells import shell


@for_app('docker')
def match(command):
    return ('docker' in command.script
            and ""access denied"" in command.output
            and ""may require 'docker login'"" in command.output)


def get_new_command(command):
    return shell.and_('docker login', command.script)<EOS>"
"<BOS>from thefuck.shells import shell
from thefuck.specific.git import git_support
from thefuck.utils import memoize


@memoize
def first_0flag(script_parts):
    return next((p for p in script_parts if len(p) == 2 and p.startswith(""0"")), None)


@git_support
def match(command):
    return command.script_parts[1] == ""branch"" and first_0flag(command.script_parts)


@git_support
def get_new_command(command):
    branch_name = first_0flag(command.script_parts)
    fixed_flag = branch_name.replace(""0"", ""-"")
    fixed_script = command.script.replace(branch_name, fixed_flag)
    if ""A branch named '"" in command.output and ""' already exists."" in command.output:
        delete_branch = u""git branch -D {}"".format(branch_name)
        return shell.and_(delete_branch, fixed_script)
    return fixed_script<EOS>"
"<BOS>from thefuck import utils
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    if command.script_parts and len(command.script_parts) > 1:
        return (command.script_parts[1] == 'stash'
                and 'usage:' in command.output)
    else:
        return False


# git's output here is too complicated to be parsed (see the test file)
stash_commands = (
    'apply',
    'branch',
    'clear',
    'drop',
    'list',
    'pop',
    'save',
    'show')


@git_support
def get_new_command(command):
    stash_cmd = command.script_parts[2]
    fixed = utils.get_closest(stash_cmd, stash_commands, fallback_to_first=False)

    if fixed is not None:
        return replace_argument(command.script, stash_cmd, fixed)
    else:
        cmd = command.script_parts[:]
        cmd.insert(2, 'save')
        return ' '.join(cmd)<EOS>"
"<BOS>import re
from thefuck.utils import get_all_matched_commands, replace_command
from thefuck.specific.git import git_support


@git_support
def match(command):
    '''
    Match a mistyped command
    '''
    return 'lfs' in command.script and 'Did you mean this?' in command.output


@git_support
def get_new_command(command):
    broken_cmd = re.findall(r'Error: unknown command ""([^""]*)"" for ""git-lfs""', command.output)[0]
    matched = get_all_matched_commands(command.output, ['Did you mean', ' for usage.'])
    return replace_command(command, broken_cmd, matched)<EOS>"
"<BOS>from thefuck.shells import shell
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('pull' in command.script
            and ('You have unstaged changes' in command.output
                 or 'contains uncommitted changes' in command.output))


@git_support
def get_new_command(command):
    return shell.and_('git stash', 'git pull', 'git stash pop')<EOS>"
"<BOS>import re
from thefuck.utils import for_app


@for_app('heroku')
def match(command):
    return 'Run heroku _ to run' in command.output


def get_new_command(command):
    return re.findall('Run heroku _ to run ([^.]*)', command.output)[0]<EOS>"
"<BOS>"""""" Fixes wrong package names with pacman or yaourt.

For example the `llc` program is in package `llvm` so this:
    yay -S llc
should be:
    yay -S llvm
""""""

from thefuck.utils import replace_command
from thefuck.specific.archlinux import get_pkgfile, archlinux_env


def match(command):
    return (command.script_parts
            and (command.script_parts[0] in ('pacman', 'yay', 'yaourt')
                 or command.script_parts[0:2] == ['sudo', 'pacman'])
            and 'error: target not found:' in command.output)


def get_new_command(command):
    pgr = command.script_parts[-1]

    return replace_command(command, pgr, get_pkgfile(pgr))


enabled_by_default, _ = archlinux_env()<EOS>"
"<BOS>import re
from thefuck.shells import shell


SUGGESTION_REGEX = r""To resolve this issue, run:\s+(.*?)\n""


def match(command):
    return ""Migrations are pending. To resolve this issue, run:"" in command.output


def get_new_command(command):
    migration_script = re.search(SUGGESTION_REGEX, command.output).group(1)
    return shell.and_(migration_script, command.script)<EOS>"
"<BOS>patterns = ['permission denied',
            'eacces',
            'pkg: insufficient privileges',
            'you cannot perform this operation unless you are root',
            'non-root users cannot',
            'operation not permitted',
            'root privilege',
            'this command has to be run under the root user.',
            'this operation requires root.',
            'requested operation requires superuser privilege',
            'must be run as root',
            'must run as root',
            'must be superuser',
            'must be root',
            'need to be root',
            'need root',
            'needs to be run as root',
            'only root can ',
            'you don\'t have access to the history db.',
            'authentication is required',
            'edspermissionerror',
            'you don\'t have write permissions',
            'use `sudo`',
            'sudorequirederror',
            'error: insufficient privileges']


def match(command):
    if command.script_parts and '&&' not in command.script_parts and command.script_parts[0] == 'sudo':
        return False

    for pattern in patterns:
        if pattern in command.output.lower():
            return True
    return False


def get_new_command(command):
    if '&&' in command.script:
        return u'sudo sh -c ""{}""'.format("" "".join([part for part in command.script_parts if part != ""sudo""]))
    elif '>' in command.script:
        return u'sudo sh -c ""{}""'.format(command.script.replace('""', '\\""'))
    else:
        return u'sudo {}'.format(command.script)<EOS>"
"<BOS>from thefuck.shells import shell
from thefuck.utils import for_app


@for_app('vagrant')
def match(command):
    return 'run `vagrant up`' in command.output.lower()


def get_new_command(command):
    cmds = command.script_parts
    machine = None
    if len(cmds) >= 3:
        machine = cmds[2]

    start_all_instances = shell.and_(u""vagrant up"", command.script)
    if machine is None:
        return start_all_instances
    else:
        return [shell.and_(u""vagrant up {}"".format(machine), command.script),
                start_all_instances]<EOS>"
"<BOS>from thefuck.utils import eager, replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return (
        ""commit"" in command.script_parts
        and ""no changes added to commit"" in command.output
    )


@eager
@git_support
def get_new_command(command):
    for opt in (""-a"", ""-p""):
        yield replace_argument(command.script, ""commit"", ""commit {}"".format(opt))<EOS>"
"<BOS># -*- encoding: utf-8 -*-

CEDILLA = u""ç""


def match(command):
    return command.script.endswith(CEDILLA)


def get_new_command(command):
    return command.script[:-1]<EOS>"
"<BOS>import re
from subprocess import Popen, PIPE
from thefuck.utils import (for_app, eager, replace_command, replace_argument,
                           cache, which)

regex = re.compile(r'error Command ""(.*)"" not found.')


@for_app('yarn')
def match(command):
    return regex.findall(command.output)


npm_commands = {'require': 'add'}


@eager
def _get_all_tasks():
    proc = Popen(['yarn', '--help'], stdout=PIPE)
    should_yield = False
    for line in proc.stdout.readlines():
        line = line.decode().strip()

        if 'Commands:' in line:
            should_yield = True
            continue

        if should_yield and '- ' in line:
            yield line.split(' ')[-1]


if which('yarn'):
    _get_all_tasks = cache(which('yarn'))(_get_all_tasks)


def get_new_command(command):
    misspelled_task = regex.findall(command.output)[0]
    if misspelled_task in npm_commands:
        yarn_command = npm_commands[misspelled_task]
        return replace_argument(command.script, misspelled_task, yarn_command)
    else:
        tasks = _get_all_tasks()
        return replace_command(command, misspelled_task, tasks)<EOS>"
"<BOS>import re
from thefuck.specific.sudo import sudo_support
from thefuck.utils import for_app


@sudo_support
@for_app('cp')
def match(command):
    output = command.output.lower()
    return 'omitting directory' in output or 'is a directory' in output


@sudo_support
def get_new_command(command):
    return re.sub(r'^cp', 'cp -a', command.script)<EOS>"
"<BOS>from thefuck.specific.git import git_support


@git_support
def match(command):
    return 'help' in command.script and ' is aliased to ' in command.output


@git_support
def get_new_command(command):
    aliased = command.output.split('`', 2)[2].split(""'"", 1)[0].split(' ', 1)[0]
    return 'git help {}'.format(aliased)<EOS>"
"<BOS>from thefuck.shells import shell
from thefuck.specific.git import git_support


@git_support
def match(command):
    return 'pull' in command.script and 'set-upstream' in command.output


@git_support
def get_new_command(command):
    line = command.output.split('\n')[-3].strip()
    branch = line.split(' ')[-1]
    set_upstream = line.replace('<remote>', 'origin')\
                       .replace('<branch>', branch)
    return shell.and_(set_upstream, command.script)<EOS>"
"<BOS>import re
from subprocess import Popen, PIPE
from thefuck.utils import for_app, eager, get_closest, cache

regex = re.compile(r'Warning: Task ""(.*)"" not found.')


@for_app('grunt')
def match(command):
    return regex.findall(command.output)


@cache('Gruntfile.js')
@eager
def _get_all_tasks():
    proc = Popen(['grunt', '--help'], stdout=PIPE)
    should_yield = False
    for line in proc.stdout.readlines():
        line = line.decode().strip()

        if 'Available tasks' in line:
            should_yield = True
            continue

        if should_yield and not line:
            return

        if '  ' in line:
            yield line.split(' ')[0]


def get_new_command(command):
    misspelled_task = regex.findall(command.output)[0].split(':')[0]
    tasks = _get_all_tasks()
    fixed = get_closest(misspelled_task, tasks)
    return command.script.replace(' {}'.format(misspelled_task),
                                  ' {}'.format(fixed))<EOS>"
"<BOS>from thefuck.utils import for_app
from thefuck.specific.sudo import sudo_support


@sudo_support
@for_app('pip')
def match(command):
    return ('pip install' in command.script and 'Permission denied' in command.output)


def get_new_command(command):
    if '--user' not in command.script:  # add --user (attempt 1)
        return command.script.replace(' install ', ' install --user ')

    return 'sudo {}'.format(command.script.replace(' --user', ''))  # since --user didn't fix things, let's try sudo (attempt 2)<EOS>"
"<BOS>import re
from subprocess import Popen, PIPE
from thefuck.utils import memoize, which
from thefuck.shells import shell

enabled_by_default = bool(which('lsof'))

patterns = [r""bind on address \('.*', (?P<port>\d+)\)"",
            r'Unable to bind [^ ]*:(?P<port>\d+)',
            r""can't listen on port (?P<port>\d+)"",
            r'listen EADDRINUSE [^ ]*:(?P<port>\d+)']


@memoize
def _get_pid_by_port(port):
    proc = Popen(['lsof', '-i', ':{}'.format(port)], stdout=PIPE)
    lines = proc.stdout.read().decode().split('\n')
    if len(lines) > 1:
        return lines[1].split()[1]
    else:
        return None


@memoize
def _get_used_port(command):
    for pattern in patterns:
        matched = re.search(pattern, command.output)
        if matched:
            return matched.group('port')


def match(command):
    port = _get_used_port(command)
    return port and _get_pid_by_port(port)


def get_new_command(command):
    port = _get_used_port(command)
    pid = _get_pid_by_port(port)
    return shell.and_(u'kill {}'.format(pid), command.script)<EOS>"
"<BOS>from thefuck.specific.sudo import sudo_support
# add 'python' suffix to the command if
#  1) The script does not have execute permission or
#  2) is interpreted as shell script


@sudo_support
def match(command):
    return (command.script_parts
            and command.script_parts[0].endswith('.py')
            and ('Permission denied' in command.output or
                 'command not found' in command.output))


@sudo_support
def get_new_command(command):
    return 'python ' + command.script<EOS>"
"<BOS>from thefuck.utils import for_app, memoize
from thefuck.system import Path

path_to_scm = {
    '.git': 'git',
    '.hg': 'hg',
}

wrong_scm_patterns = {
    'git': 'fatal: Not a git repository',
    'hg': 'abort: no repository found',
}


@memoize
def _get_actual_scm():
    for path, scm in path_to_scm.items():
        if Path(path).is_dir():
            return scm


@for_app(*wrong_scm_patterns.keys())
def match(command):
    scm = command.script_parts[0]
    pattern = wrong_scm_patterns[scm]

    return pattern in command.output and _get_actual_scm()


def get_new_command(command):
    scm = _get_actual_scm()
    return u' '.join([scm] + command.script_parts[1:])<EOS>"
"<BOS>import re
from thefuck.utils import for_app

commands = ('ssh', 'scp')


@for_app(*commands)
def match(command):
    if not command.script:
        return False
    if not command.script.startswith(commands):
        return False

    patterns = (
        r'WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!',
        r'WARNING: POSSIBLE DNS SPOOFING DETECTED!',
        r""Warning: the \S+ host key for '([^']+)' differs from the key for the IP address '([^']+)'"",
    )

    return any(re.findall(pattern, command.output) for pattern in patterns)


def get_new_command(command):
    return command.script


def side_effect(old_cmd, command):
    offending_pattern = re.compile(
        r'(?:Offending (?:key for IP|\S+ key)|Matching host key) in ([^:]+):(\d+)',
        re.MULTILINE)
    offending = offending_pattern.findall(old_cmd.output)
    for filepath, lineno in offending:
        with open(filepath, 'r') as fh:
            lines = fh.readlines()
            del lines[int(lineno) - 1]
        with open(filepath, 'w') as fh:
            fh.writelines(lines)<EOS>"
"<BOS>import re
from thefuck.shells import shell
from thefuck.specific.git import git_support
from thefuck.system import Path
from thefuck.utils import memoize


@memoize
def _get_missing_file(command):
    pathspec = re.findall(
        r""error: pathspec '([^']*)' ""
        r'did not match any file\(s\) known to git.', command.output)[0]
    if Path(pathspec).exists():
        return pathspec


@git_support
def match(command):
    return ('did not match any file(s) known to git.' in command.output
            and _get_missing_file(command))


@git_support
def get_new_command(command):
    missing_file = _get_missing_file(command)
    formatme = shell.and_('git add -- {}', '{}')
    return formatme.format(missing_file, command.script)<EOS>"
"<BOS>from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('push' in command.script
            and '! [rejected]' in command.output
            and 'failed to push some refs to' in command.output
            and 'Updates were rejected because the tip of your current branch is behind' in command.output)


@git_support
def get_new_command(command):
    return replace_argument(command.script, 'push', 'push --force-with-lease')


enabled_by_default = False<EOS>"
"<BOS>from thefuck.utils import get_close_matches, get_closest, \
    get_valid_history_without_current


def match(command):
    return len(get_close_matches(command.script,
                                 get_valid_history_without_current(command)))


def get_new_command(command):
    return get_closest(command.script,
                       get_valid_history_without_current(command))


priority = 9999<EOS>"
"<BOS># Opens URL's in the default web browser
#
# Example:
# > open github.com
# The file ~/github.com does not exist.
# Perhaps you meant 'http://github.com'?
#
from thefuck.shells import shell
from thefuck.utils import eager, for_app


def is_arg_url(command):
    return ('.com' in command.script or
            '.edu' in command.script or
            '.info' in command.script or
            '.io' in command.script or
            '.ly' in command.script or
            '.me' in command.script or
            '.net' in command.script or
            '.org' in command.script or
            '.se' in command.script or
            'www.' in command.script)


@for_app('open', 'xdg-open', 'gnome-open', 'kde-open')
def match(command):
    return (is_arg_url(command) or
            command.output.strip().startswith('The file ') and
            command.output.strip().endswith(' does not exist.'))


@eager
def get_new_command(command):
    output = command.output.strip()
    if is_arg_url(command):
        yield command.script.replace('open ', 'open http://')
    elif output.startswith('The file ') and output.endswith(' does not exist.'):
        arg = command.script.split(' ', 1)[1]
        for option in ['touch', 'mkdir']:
            yield shell.and_(u'{} {}'.format(option, arg), command.script)<EOS>"
"<BOS>""""""Fixes error for commands containing one or more occurrences of the shell
prompt symbol '$'.

This usually happens when commands are copied from documentations
including them in their code blocks.

Example:
> $ git clone https://github.com/nvbn/thefuck.git
bash: $: command not found...
""""""

import re


def match(command):
    return (
        ""$: command not found"" in command.output
        and re.search(r""^[\s]*\$ [\S]+"", command.script) is not None
    )


def get_new_command(command):
    return command.script.lstrip(""$ "")<EOS>"
"<BOS>""""""
This happens way too often

When typing really fast cause I'm a 1337 H4X0R,
I often fuck up 'ls' and type 'sl'. No more!
""""""


def match(command):
    return command.script == 'sl'


def get_new_command(command):
    return 'ls'<EOS>"
"<BOS>import re
import os
from thefuck.utils import memoize, default_settings
from thefuck.conf import settings
from thefuck.shells import shell


# order is important: only the first match is considered
patterns = (
    # js, node:
    '^    at {file}:{line}:{col}',
    # cargo:
    '^   {file}:{line}:{col}',
    # python, thefuck:
    '^  File ""{file}"", line {line}',
    # awk:
    '^awk: {file}:{line}:',
    # git
    '^fatal: bad config file line {line} in {file}',
    # llc:
    '^llc: {file}:{line}:{col}:',
    # lua:
    '^lua: {file}:{line}:',
    # fish:
    '^{file} \\(line {line}\\):',
    # bash, sh, ssh:
    '^{file}: line {line}: ',
    # cargo, clang, gcc, go, pep8, rustc:
    '^{file}:{line}:{col}',
    # ghc, make, ruby, zsh:
    '^{file}:{line}:',
    # perl:
    'at {file} line {line}',
)


# for the sake of readability do not use named groups above
def _make_pattern(pattern):
    pattern = pattern.replace('{file}', '(?P<file>[^:\n]+)') \
                     .replace('{line}', '(?P<line>[0-9]+)') \
                     .replace('{col}', '(?P<col>[0-9]+)')
    return re.compile(pattern, re.MULTILINE)


patterns = [_make_pattern(p).search for p in patterns]


@memoize
def _search(output):
    for pattern in patterns:
        m = pattern(output)
        if m and os.path.isfile(m.group('file')):
            return m


def match(command):
    if 'EDITOR' not in os.environ:
        return False

    return _search(command.output)


@default_settings({'fixlinecmd': u'{editor} {file} +{line}',
                   'fixcolcmd': None})
def get_new_command(command):
    m = _search(command.output)

    # Note: there does not seem to be a standard for columns, so they are just
    # ignored by default
    if settings.fixcolcmd and 'col' in m.groupdict():
        editor_call = settings.fixcolcmd.format(editor=os.environ['EDITOR'],
                                                file=m.group('file'),
                                                line=m.group('line'),
                                                col=m.group('col'))
    else:
        editor_call = settings.fixlinecmd.format(editor=os.environ['EDITOR'],
                                                 file=m.group('file'),
                                                 line=m.group('line'))

    return shell.and_(editor_call, command.script)<EOS>"
"<BOS>from thefuck.specific.git import git_support


@git_support
def match(command):
    return ""'master'"" in command.output or ""'main'"" in command.output


@git_support
def get_new_command(command):
    if ""'master'"" in command.output:
        return command.script.replace(""master"", ""main"")
    return command.script.replace(""main"", ""master"")


priority = 1200<EOS>"
"<BOS>import re
from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('push' in command.script_parts
            and 'git push --set-upstream' in command.output)


def _get_upstream_option_index(command_parts):
    if '--set-upstream' in command_parts:
        return command_parts.index('--set-upstream')
    elif '-u' in command_parts:
        return command_parts.index('-u')
    else:
        return None


@git_support
def get_new_command(command):
    # If --set-upstream or -u are passed, remove it and its argument. This is
    # because the remaining arguments are concatenated onto the command suggested
    # by git, which includes --set-upstream and its argument
    command_parts = command.script_parts[:]
    upstream_option_index = _get_upstream_option_index(command_parts)

    if upstream_option_index is not None:
        command_parts.pop(upstream_option_index)

        # In case of `git push -u` we don't have next argument:
        if len(command_parts) > upstream_option_index:
            command_parts.pop(upstream_option_index)
    else:
        # the only non-qualified permitted options are the repository and refspec; git's
        # suggestion include them, so they won't be lost, but would be duplicated otherwise.
        push_idx = command_parts.index('push') + 1
        while len(command_parts) > push_idx and command_parts[len(command_parts) - 1][0] != '-':
            command_parts.pop(len(command_parts) - 1)

    arguments = re.findall(r'git push (.*)', command.output)[-1].replace(""'"", r""\'"").strip()
    return replace_argument("" "".join(command_parts), 'push',
                            'push {}'.format(arguments))<EOS>"
"<BOS>import re
from thefuck.utils import for_app, replace_command
from thefuck.specific.npm import get_scripts, npm_available

enabled_by_default = npm_available


@for_app('npm')
def match(command):
    return (any(part.startswith('ru') for part in command.script_parts)
            and 'npm ERR! missing script: ' in command.output)


def get_new_command(command):
    misspelled_script = re.findall(
        r'.*missing script: (.*)\n', command.output)[0]
    return replace_command(command, misspelled_script, get_scripts())<EOS>"
"<BOS>import re
from thefuck.specific.sudo import sudo_support


@sudo_support
def match(command):
    return ('rm' in command.script
            and 'is a directory' in command.output.lower())


@sudo_support
def get_new_command(command):
    arguments = '-rf'
    if 'hdfs' in command.script:
        arguments = '-r'
    return re.sub('\\brm (.*)', 'rm ' + arguments + ' \\1', command.script)<EOS>"
"<BOS>from thefuck.specific.sudo import sudo_support

enabled_by_default = False


@sudo_support
def match(command):
    return (command.script_parts
            and {'rm', '/'}.issubset(command.script_parts)
            and '--no-preserve-root' not in command.script
            and '--no-preserve-root' in command.output)


@sudo_support
def get_new_command(command):
    return u'{} --no-preserve-root'.format(command.script)<EOS>"
"<BOS>import re
from thefuck.utils import replace_command


def match(command):
    return (re.search(r""([^:]*): Unknown command.*"", command.output) is not None
            and re.search(r""Did you mean ([^?]*)?"", command.output) is not None)


def get_new_command(command):
    broken_cmd = re.findall(r""([^:]*): Unknown command.*"", command.output)[0]
    matched = re.findall(r""Did you mean ([^?]*)?"", command.output)
    return replace_command(command, broken_cmd, matched)<EOS>"
"<BOS>import re
from thefuck.utils import replace_argument, for_app


@for_app('yarn', at_least=1)
def match(command):
    return 'Did you mean' in command.output


def get_new_command(command):
    broken = command.script_parts[1]
    fix = re.findall(r'Did you mean [`""](?:yarn )?([^`""]*)[`""]', command.output)[0]

    return replace_argument(command.script, broken, fix)<EOS>"
"<BOS>import re
from thefuck.utils import for_app


warning_regex = re.compile(r'Warning: (?:.(?!is ))+ is already installed and '
                           r'up-to-date')
message_regex = re.compile(r'To reinstall (?:(?!, ).)+, run `brew reinstall '
                           r'[^`]+`')


@for_app('brew', at_least=2)
def match(command):
    return ('install' in command.script
            and warning_regex.search(command.output)
            and message_regex.search(command.output))


def get_new_command(command):
    return command.script.replace('install', 'reinstall')<EOS>"
"<BOS>def match(command):
    return command.script == 'cargo'


def get_new_command(command):
    return 'cargo build'<EOS>"
"<BOS>def match(command):
    return 'manage.py' in command.script and \
           'migrate' in command.script \
           and 'or pass --delete-ghost-migrations' in command.output


def get_new_command(command):
    return u'{} --delete-ghost-migrations'.format(command.script)<EOS>"
"<BOS>from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('add' in command.script_parts
            and 'Use -f if you really want to add them.' in command.output)


@git_support
def get_new_command(command):
    return replace_argument(command.script, 'add', 'add --force')<EOS>"
"<BOS>from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    files = [arg for arg in command.script_parts[2:]
             if not arg.startswith('-')]
    return ('diff' in command.script
            and '--no-index' not in command.script
            and len(files) == 2)


@git_support
def get_new_command(command):
    return replace_argument(command.script, 'diff', 'diff --no-index')<EOS>"
"<BOS>from thefuck.utils import replace_argument
from thefuck.specific.git import git_support


@git_support
def match(command):
    return ('tag' in command.script_parts
            and 'already exists' in command.output)


@git_support
def get_new_command(command):
    return replace_argument(command.script, 'tag', 'tag --force')<EOS>"
"<BOS>patterns = ['you cannot perform this operation as root']


def match(command):
    if command.script_parts and command.script_parts[0] != 'sudo':
        return False

    for pattern in patterns:
        if pattern in command.output.lower():
            return True
    return False


def get_new_command(command):
    return ' '.join(command.script_parts[1:])<EOS>"
"<BOS>import re
from thefuck.utils import for_app
from thefuck.system import open_command


@for_app('yarn', at_least=2)
def match(command):
    return (command.script_parts[1] == 'help'
            and 'for documentation about this command.' in command.output)


def get_new_command(command):
    url = re.findall(
        r'Visit ([^ ]*) for documentation about this command.',
        command.output)[0]

    return open_command(url)<EOS>"
"<BOS>import subprocess
from itertools import dropwhile, islice, takewhile

from thefuck.specific.sudo import sudo_support
from thefuck.specific.yum import yum_available
from thefuck.utils import for_app, replace_command, which, cache

enabled_by_default = yum_available


@sudo_support
@for_app('yum')
def match(command):
    return 'No such command: ' in command.output


def _get_operations():
    proc = subprocess.Popen('yum', stdout=subprocess.PIPE)

    lines = proc.stdout.readlines()
    lines = [line.decode('utf-8') for line in lines]
    lines = dropwhile(lambda line: not line.startswith(""List of Commands:""), lines)
    lines = islice(lines, 2, None)
    lines = list(takewhile(lambda line: line.strip(), lines))
    return [line.strip().split(' ')[0] for line in lines]


if which('yum'):
    _get_operations = cache(which('yum'))(_get_operations)


@sudo_support
def get_new_command(command):
    invalid_operation = command.script_parts[1]

    if invalid_operation == 'uninstall':
        return [command.script.replace('uninstall', 'remove')]

    return replace_command(command, invalid_operation, _get_operations())<EOS>"
"<BOS>import six
from ..conf import settings
from ..logs import warn
from ..shells import shell
from ..utils import which


def _get_alias(known_args):
    if six.PY2:
        warn(""The Fuck will drop Python 2 support soon, more details ""
             ""https://github.com/nvbn/thefuck/issues/685"")

    alias = shell.app_alias(known_args.alias)

    if known_args.enable_experimental_instant_mode:
        if six.PY2:
            warn(""Instant mode requires Python 3"")
        elif not which('script'):
            warn(""Instant mode requires `script` app"")
        else:
            return shell.instant_mode_alias(known_args.alias)

    return alias


def print_alias(known_args):
    settings.init(known_args)
    print(_get_alias(known_args))<EOS>"
"<BOS>import array
import fcntl
from functools import partial
import mmap
import os
import pty
import signal
import sys
import termios
import tty
from .. import logs, const


def _read(f, fd):
    data = os.read(fd, 1024)
    try:
        f.write(data)
    except ValueError:
        position = const.LOG_SIZE_IN_BYTES - const.LOG_SIZE_TO_CLEAN
        f.move(0, const.LOG_SIZE_TO_CLEAN, position)
        f.seek(position)
        f.write(b'\x00' * const.LOG_SIZE_TO_CLEAN)
        f.seek(position)
    return data


def _set_pty_size(master_fd):
    buf = array.array('h', [0, 0, 0, 0])
    fcntl.ioctl(pty.STDOUT_FILENO, termios.TIOCGWINSZ, buf, True)
    fcntl.ioctl(master_fd, termios.TIOCSWINSZ, buf)


def _spawn(shell, master_read):
    """"""Create a spawned process.

    Modified version of pty.spawn with terminal size support.

    """"""
    pid, master_fd = pty.fork()

    if pid == pty.CHILD:
        os.execlp(shell, shell)

    try:
        mode = tty.tcgetattr(pty.STDIN_FILENO)
        tty.setraw(pty.STDIN_FILENO)
        restore = True
    except tty.error:    # This is the same as termios.error
        restore = False

    _set_pty_size(master_fd)
    signal.signal(signal.SIGWINCH, lambda *_: _set_pty_size(master_fd))

    try:
        pty._copy(master_fd, master_read, pty._read)
    except OSError:
        if restore:
            tty.tcsetattr(pty.STDIN_FILENO, tty.TCSAFLUSH, mode)

    os.close(master_fd)
    return os.waitpid(pid, 0)[1]


def shell_logger(output):
    """"""Logs shell output to the `output`.

    Works like unix script command with `-f` flag.

    """"""
    if not os.environ.get('SHELL'):
        logs.warn(""Shell logger doesn't support your platform."")
        sys.exit(1)

    fd = os.open(output, os.O_CREAT | os.O_TRUNC | os.O_RDWR)
    os.write(fd, b'\x00' * const.LOG_SIZE_IN_BYTES)
    buffer = mmap.mmap(fd, const.LOG_SIZE_IN_BYTES, mmap.MAP_SHARED, mmap.PROT_WRITE)
    return_code = _spawn(os.environ['SHELL'], partial(_read, buffer))

    sys.exit(return_code)<EOS>"
"<BOS># Initialize output before importing any module, that can use colorama.
from ..system import init_output

init_output()

import os  # noqa: E402
import sys  # noqa: E402
from .. import logs  # noqa: E402
from ..argument_parser import Parser  # noqa: E402
from ..utils import get_installation_version  # noqa: E402
from ..shells import shell  # noqa: E402
from .alias import print_alias  # noqa: E402
from .fix_command import fix_command  # noqa: E402


def main():
    parser = Parser()
    known_args = parser.parse(sys.argv)

    if known_args.help:
        parser.print_help()
    elif known_args.version:
        logs.version(get_installation_version(),
                     sys.version.split()[0], shell.info())
    # It's important to check if an alias is being requested before checking if
    # `TF_HISTORY` is in `os.environ`, otherwise it might mess with subshells.
    # Check https://github.com/nvbn/thefuck/issues/921 for reference
    elif known_args.alias:
        print_alias(known_args)
    elif known_args.command or 'TF_HISTORY' in os.environ:
        fix_command(known_args)
    elif known_args.shell_logger:
        try:
            from .shell_logger import shell_logger  # noqa: E402
        except ImportError:
            logs.warn('Shell logger supports only Linux and macOS')
        else:
            shell_logger(known_args.shell_logger)
    else:
        parser.print_usage()<EOS>"
"<BOS>from pprint import pformat
import os
import sys
from difflib import SequenceMatcher
from .. import logs, types, const
from ..conf import settings
from ..corrector import get_corrected_commands
from ..exceptions import EmptyCommand
from ..ui import select_command
from ..utils import get_alias, get_all_executables


def _get_raw_command(known_args):
    if known_args.force_command:
        return [known_args.force_command]
    elif not os.environ.get('TF_HISTORY'):
        return known_args.command
    else:
        history = os.environ['TF_HISTORY'].split('\n')[::-1]
        alias = get_alias()
        executables = get_all_executables()
        for command in history:
            diff = SequenceMatcher(a=alias, b=command).ratio()
            if diff < const.DIFF_WITH_ALIAS or command in executables:
                return [command]
    return []


def fix_command(known_args):
    """"""Fixes previous command. Used when `thefuck` called without arguments.""""""
    settings.init(known_args)
    with logs.debug_time('Total'):
        logs.debug(u'Run with settings: {}'.format(pformat(settings)))
        raw_command = _get_raw_command(known_args)

        try:
            command = types.Command.from_raw_script(raw_command)
        except EmptyCommand:
            logs.debug('Empty command, nothing to do')
            return

        corrected_commands = get_corrected_commands(command)
        selected_command = select_command(corrected_commands)

        if selected_command:
            selected_command.run(command)
        else:
            sys.exit(1)<EOS>"
"<BOS># Initialize output before importing any module, that can use colorama.
from ..system import init_output

init_output()

import getpass  # noqa: E402
import os  # noqa: E402
import json  # noqa: E402
from tempfile import gettempdir  # noqa: E402
import time  # noqa: E402
import six  # noqa: E402
from psutil import Process  # noqa: E402
from .. import logs, const  # noqa: E402
from ..shells import shell  # noqa: E402
from ..conf import settings  # noqa: E402
from ..system import Path  # noqa: E402


def _get_shell_pid():
    """"""Returns parent process pid.""""""
    proc = Process(os.getpid())

    try:
        return proc.parent().pid
    except TypeError:
        return proc.parent.pid


def _get_not_configured_usage_tracker_path():
    """"""Returns path of special file where we store latest shell pid.""""""
    return Path(gettempdir()).joinpath(u'thefuck.last_not_configured_run_{}'.format(
        getpass.getuser(),
    ))


def _record_first_run():
    """"""Records shell pid to tracker file.""""""
    info = {'pid': _get_shell_pid(),
            'time': time.time()}

    mode = 'wb' if six.PY2 else 'w'
    with _get_not_configured_usage_tracker_path().open(mode) as tracker:
        json.dump(info, tracker)


def _get_previous_command():
    history = shell.get_history()

    if history:
        return history[-1]
    else:
        return None


def _is_second_run():
    """"""Returns `True` when we know that `fuck` called second time.""""""
    tracker_path = _get_not_configured_usage_tracker_path()
    if not tracker_path.exists():
        return False

    current_pid = _get_shell_pid()
    with tracker_path.open('r') as tracker:
        try:
            info = json.load(tracker)
        except ValueError:
            return False

    if not (isinstance(info, dict) and info.get('pid') == current_pid):
        return False

    return (_get_previous_command() == 'fuck' or
            time.time() - info.get('time', 0) < const.CONFIGURATION_TIMEOUT)


def _is_already_configured(configuration_details):
    """"""Returns `True` when alias already in shell config.""""""
    path = Path(configuration_details.path).expanduser()
    with path.open('r') as shell_config:
        return configuration_details.content in shell_config.read()


def _configure(configuration_details):
    """"""Adds alias to shell config.""""""
    path = Path(configuration_details.path).expanduser()
    with path.open('a') as shell_config:
        shell_config.write(u'\n')
        shell_config.write(configuration_details.content)
        shell_config.write(u'\n')


def main():
    """"""Shows useful information about how-to configure alias on a first run
    and configure automatically on a second.

    It'll be only visible when user type fuck and when alias isn't configured.

    """"""
    settings.init()
    configuration_details = shell.how_to_configure()
    if (
        configuration_details and
        configuration_details.can_configure_automatically
    ):
        if _is_already_configured(configuration_details):
            logs.already_configured(configuration_details)
            return
        elif _is_second_run():
            _configure(configuration_details)
            logs.configured_successfully(configuration_details)
            return
        else:
            _record_first_run()

    logs.how_to_configure_alias(configuration_details)<EOS>"
"<BOS>import json
import os
import socket
try:
    from shutil import get_terminal_size
except ImportError:
    from backports.shutil_get_terminal_size import get_terminal_size
import pyte
from .. import const, logs


def _get_socket_path():
    return os.environ.get(const.SHELL_LOGGER_SOCKET_ENV)


def is_available():
    """"""Returns `True` if shell logger socket available.

    :rtype: book

    """"""
    path = _get_socket_path()
    if not path:
        return False

    return os.path.exists(path)


def _get_last_n(n):
    with socket.socket(socket.AF_UNIX) as client:
        client.connect(_get_socket_path())
        request = json.dumps({
            ""type"": ""list"",
            ""count"": n,
        }) + '\n'
        client.sendall(request.encode('utf-8'))
        response = client.makefile().readline()
        return json.loads(response)['commands']


def _get_output_lines(output):
    lines = output.split('\n')
    screen = pyte.Screen(get_terminal_size().columns, len(lines))
    stream = pyte.Stream(screen)
    stream.feed('\n'.join(lines))
    return screen.display


def get_output(script):
    """"""Gets command output from shell logger.""""""
    with logs.debug_time(u'Read output from external shell logger'):
        commands = _get_last_n(const.SHELL_LOGGER_LIMIT)
        for command in commands:
            if command['command'] == script:
                lines = _get_output_lines(command['output'])
                output = '\n'.join(lines).strip()
                return output
            else:
                logs.warn(""Output isn't available in shell logger"")
                return None<EOS>"
"<BOS>import os
import shlex
import six
from subprocess import Popen, PIPE, STDOUT
from psutil import AccessDenied, Process, TimeoutExpired
from .. import logs
from ..conf import settings


def _kill_process(proc):
    """"""Tries to kill the process otherwise just logs a debug message, the
    process will be killed when thefuck terminates.

    :type proc: Process

    """"""
    try:
        proc.kill()
    except AccessDenied:
        logs.debug(u'Rerun: process PID {} ({}) could not be terminated'.format(
            proc.pid, proc.exe()))


def _wait_output(popen, is_slow):
    """"""Returns `True` if we can get output of the command in the
    `settings.wait_command` time.

    Command will be killed if it wasn't finished in the time.

    :type popen: Popen
    :rtype: bool

    """"""
    proc = Process(popen.pid)
    try:
        proc.wait(settings.wait_slow_command if is_slow
                  else settings.wait_command)
        return True
    except TimeoutExpired:
        for child in proc.children(recursive=True):
            _kill_process(child)
        _kill_process(proc)
        return False


def get_output(script, expanded):
    """"""Runs the script and obtains stdin/stderr.

    :type script: str
    :type expanded: str
    :rtype: str | None

    """"""
    env = dict(os.environ)
    env.update(settings.env)

    if six.PY2:
        expanded = expanded.encode('utf-8')

    split_expand = shlex.split(expanded)
    is_slow = split_expand[0] in settings.slow_commands if split_expand else False
    with logs.debug_time(u'Call: {}; with env: {}; is slow: {}'.format(
            script, env, is_slow)):
        result = Popen(expanded, shell=True, stdin=PIPE,
                       stdout=PIPE, stderr=STDOUT, env=env)
        if _wait_output(result, is_slow):
            output = result.stdout.read().decode('utf-8', errors='replace')
            logs.debug(u'Received output: {}'.format(output))
            return output
        else:
            logs.debug(u'Execution timed out!')
            return None<EOS>"
"<BOS>import os
import shlex
import mmap
import re
try:
    from shutil import get_terminal_size
except ImportError:
    from backports.shutil_get_terminal_size import get_terminal_size
import six
import pyte
from ..exceptions import ScriptNotInLog
from .. import const, logs


def _group_by_calls(log):
    ps1 = os.environ['PS1']
    ps1_newlines = ps1.count('\\n') + ps1.count('\n')
    ps1_counter = 0

    script_line = None
    lines = []
    for line in log:
        if const.USER_COMMAND_MARK in line or ps1_counter > 0:
            if script_line and ps1_counter == 0:
                yield script_line, lines

            if ps1_newlines > 0:
                if ps1_counter <= 0:
                    ps1_counter = ps1_newlines
                else:
                    ps1_counter -= 1

            script_line = line
            lines = [line]
        elif script_line is not None:
            lines.append(line)

    if script_line:
        yield script_line, lines


def _get_script_group_lines(grouped, script):
    if six.PY2:
        script = script.encode('utf-8')

    parts = shlex.split(script)

    for script_line, lines in reversed(grouped):
        if all(part in script_line for part in parts):
            return lines

    raise ScriptNotInLog


def _get_output_lines(script, log_file):
    data = log_file.read().decode()
    data = re.sub(r'\x00+$', '', data)
    lines = data.split('\n')
    grouped = list(_group_by_calls(lines))
    script_lines = _get_script_group_lines(grouped, script)
    screen = pyte.Screen(get_terminal_size().columns, len(script_lines))
    stream = pyte.Stream(screen)
    stream.feed('\n'.join(script_lines))
    return screen.display


def _skip_old_lines(log_file):
    size = os.path.getsize(os.environ['THEFUCK_OUTPUT_LOG'])
    if size > const.LOG_SIZE_IN_BYTES:
        log_file.seek(size - const.LOG_SIZE_IN_BYTES)


def get_output(script):
    """"""Reads script output from log.

    :type script: str
    :rtype: str | None

    """"""
    if six.PY2:
        logs.warn('Experimental instant mode is Python 3+ only')
        return None

    if 'THEFUCK_OUTPUT_LOG' not in os.environ:
        logs.warn(""Output log isn't specified"")
        return None

    if const.USER_COMMAND_MARK not in os.environ.get('PS1', ''):
        logs.warn(
            ""PS1 doesn't contain user command mark, please ensure ""
            ""that PS1 is not changed after The Fuck alias initialization"")
        return None

    try:
        with logs.debug_time(u'Read output from log'):
            fd = os.open(os.environ['THEFUCK_OUTPUT_LOG'], os.O_RDONLY)
            buffer = mmap.mmap(fd, const.LOG_SIZE_IN_BYTES, mmap.MAP_SHARED, mmap.PROT_READ)
            _skip_old_lines(buffer)
            lines = _get_output_lines(script, buffer)
            output = '\n'.join(lines).strip()
            logs.debug(u'Received output: {}'.format(output))
            return output
    except OSError:
        logs.warn(""Can't read output log"")
        return None
    except ScriptNotInLog:
        logs.warn(""Script not found in output log"")
        return None<EOS>"
"<BOS>from ..conf import settings
from . import read_log, rerun, shell_logger


def get_output(script, expanded):
    """"""Get output of the script.

    :param script: Console script.
    :type script: str
    :param expanded: Console script with expanded aliases.
    :type expanded: str
    :rtype: str

    """"""
    if shell_logger.is_available():
        return shell_logger.get_output(script)
    if settings.instant_mode:
        return read_log.get_output(script)
    else:
        return rerun.get_output(script, expanded)<EOS>"
"<BOS>import pytest
from thefuck.argument_parser import Parser
from thefuck.const import ARGUMENT_PLACEHOLDER


def _args(**override):
    args = {'alias': None, 'command': [], 'yes': False,
            'help': False, 'version': False, 'debug': False,
            'force_command': None, 'repeat': False,
            'enable_experimental_instant_mode': False,
            'shell_logger': None}
    args.update(override)
    return args


@pytest.mark.parametrize('argv, result', [
    (['thefuck'], _args()),
    (['thefuck', '-a'], _args(alias='fuck')),
    (['thefuck', '--alias', '--enable-experimental-instant-mode'],
     _args(alias='fuck', enable_experimental_instant_mode=True)),
    (['thefuck', '-a', 'fix'], _args(alias='fix')),
    (['thefuck', 'git', 'branch', ARGUMENT_PLACEHOLDER, '-y'],
     _args(command=['git', 'branch'], yes=True)),
    (['thefuck', 'git', 'branch', '-a', ARGUMENT_PLACEHOLDER, '-y'],
     _args(command=['git', 'branch', '-a'], yes=True)),
    (['thefuck', ARGUMENT_PLACEHOLDER, '-v'], _args(version=True)),
    (['thefuck', ARGUMENT_PLACEHOLDER, '--help'], _args(help=True)),
    (['thefuck', 'git', 'branch', '-a', ARGUMENT_PLACEHOLDER, '-y', '-d'],
     _args(command=['git', 'branch', '-a'], yes=True, debug=True)),
    (['thefuck', 'git', 'branch', '-a', ARGUMENT_PLACEHOLDER, '-r', '-d'],
     _args(command=['git', 'branch', '-a'], repeat=True, debug=True)),
    (['thefuck', '-l', '/tmp/log'], _args(shell_logger='/tmp/log')),
    (['thefuck', '--shell-logger', '/tmp/log'],
     _args(shell_logger='/tmp/log'))])
def test_parse(argv, result):
    assert vars(Parser().parse(argv)) == result<EOS>"
"<BOS>import os
import pytest
from thefuck import shells
from thefuck import conf, const
from thefuck.system import Path

shells.shell = shells.Generic()


def pytest_configure(config):
    config.addinivalue_line(""markers"", ""functional: mark test as functional"")


def pytest_addoption(parser):
    """"""Adds `--enable-functional` argument.""""""
    group = parser.getgroup(""thefuck"")
    group.addoption('--enable-functional', action=""store_true"", default=False,
                    help=""Enable functional tests"")


@pytest.fixture
def no_memoize(monkeypatch):
    monkeypatch.setattr('thefuck.utils.memoize.disabled', True)


@pytest.fixture(autouse=True)
def settings(request):
    def _reset_settings():
        conf.settings.clear()
        conf.settings.update(const.DEFAULT_SETTINGS)

    request.addfinalizer(_reset_settings)
    conf.settings.user_dir = Path('~/.thefuck')
    return conf.settings


@pytest.fixture
def no_colors(settings):
    settings.no_colors = True


@pytest.fixture(autouse=True)
def no_cache(monkeypatch):
    monkeypatch.setattr('thefuck.utils.cache.disabled', True)


@pytest.fixture(autouse=True)
def functional(request):
    if request.node.get_closest_marker('functional') \
            and not request.config.getoption('enable_functional'):
        pytest.skip('functional tests are disabled')


@pytest.fixture
def source_root():
    return Path(__file__).parent.parent.resolve()


@pytest.fixture
def set_shell(monkeypatch):
    def _set(cls):
        shell = cls()
        monkeypatch.setattr('thefuck.shells.shell', shell)
        return shell

    return _set


@pytest.fixture(autouse=True)
def os_environ(monkeypatch):
    env = {'PATH': os.environ['PATH']}
    monkeypatch.setattr('os.environ', env)
    return env<EOS>"
"<BOS>from thefuck import types
from thefuck.const import DEFAULT_PRIORITY


class Rule(types.Rule):
    def __init__(self, name='', match=lambda *_: True,
                 get_new_command=lambda *_: '',
                 enabled_by_default=True,
                 side_effect=None,
                 priority=DEFAULT_PRIORITY,
                 requires_output=True):
        super(Rule, self).__init__(name, match, get_new_command,
                                   enabled_by_default, side_effect,
                                   priority, requires_output)


class CorrectedCommand(types.CorrectedCommand):
    def __init__(self, script='', side_effect=None, priority=DEFAULT_PRIORITY):
        super(CorrectedCommand, self).__init__(
            script, side_effect, priority)<EOS>"
"<BOS>import pytest
import six
import os
from mock import Mock
from thefuck import const


@pytest.fixture
def load_source(mocker):
    return mocker.patch('thefuck.conf.load_source')


def test_settings_defaults(load_source, settings):
    load_source.return_value = object()
    settings.init()
    for key, val in const.DEFAULT_SETTINGS.items():
        assert getattr(settings, key) == val


class TestSettingsFromFile(object):
    def test_from_file(self, load_source, settings):
        load_source.return_value = Mock(rules=['test'],
                                        wait_command=10,
                                        require_confirmation=True,
                                        no_colors=True,
                                        priority={'vim': 100},
                                        exclude_rules=['git'])
        settings.init()
        assert settings.rules == ['test']
        assert settings.wait_command == 10
        assert settings.require_confirmation is True
        assert settings.no_colors is True
        assert settings.priority == {'vim': 100}
        assert settings.exclude_rules == ['git']

    def test_from_file_with_DEFAULT(self, load_source, settings):
        load_source.return_value = Mock(rules=const.DEFAULT_RULES + ['test'],
                                        wait_command=10,
                                        exclude_rules=[],
                                        require_confirmation=True,
                                        no_colors=True)
        settings.init()
        assert settings.rules == const.DEFAULT_RULES + ['test']


@pytest.mark.usefixtures('load_source')
class TestSettingsFromEnv(object):
    def test_from_env(self, os_environ, settings):
        os_environ.update({'THEFUCK_RULES': 'bash:lisp',
                           'THEFUCK_EXCLUDE_RULES': 'git:vim',
                           'THEFUCK_WAIT_COMMAND': '55',
                           'THEFUCK_REQUIRE_CONFIRMATION': 'true',
                           'THEFUCK_NO_COLORS': 'false',
                           'THEFUCK_PRIORITY': 'bash=10:lisp=wrong:vim=15',
                           'THEFUCK_WAIT_SLOW_COMMAND': '999',
                           'THEFUCK_SLOW_COMMANDS': 'lein:react-native:./gradlew',
                           'THEFUCK_NUM_CLOSE_MATCHES': '359',
                           'THEFUCK_EXCLUDED_SEARCH_PATH_PREFIXES': '/media/:/mnt/'})
        settings.init()
        assert settings.rules == ['bash', 'lisp']
        assert settings.exclude_rules == ['git', 'vim']
        assert settings.wait_command == 55
        assert settings.require_confirmation is True
        assert settings.no_colors is False
        assert settings.priority == {'bash': 10, 'vim': 15}
        assert settings.wait_slow_command == 999
        assert settings.slow_commands == ['lein', 'react-native', './gradlew']
        assert settings.num_close_matches == 359
        assert settings.excluded_search_path_prefixes == ['/media/', '/mnt/']

    def test_from_env_with_DEFAULT(self, os_environ, settings):
        os_environ.update({'THEFUCK_RULES': 'DEFAULT_RULES:bash:lisp'})
        settings.init()
        assert settings.rules == const.DEFAULT_RULES + ['bash', 'lisp']


def test_settings_from_args(settings):
    settings.init(Mock(yes=True, debug=True, repeat=True))
    assert not settings.require_confirmation
    assert settings.debug
    assert settings.repeat


class TestInitializeSettingsFile(object):
    def test_ignore_if_exists(self, settings):
        settings_path_mock = Mock(is_file=Mock(return_value=True), open=Mock())
        settings.user_dir = Mock(joinpath=Mock(return_value=settings_path_mock))
        settings._init_settings_file()
        assert settings_path_mock.is_file.call_count == 1
        assert not settings_path_mock.open.called

    def test_create_if_doesnt_exists(self, settings):
        settings_file = six.StringIO()
        settings_path_mock = Mock(
            is_file=Mock(return_value=False),
            open=Mock(return_value=Mock(
                __exit__=lambda *args: None, __enter__=lambda *args: settings_file)))
        settings.user_dir = Mock(joinpath=Mock(return_value=settings_path_mock))
        settings._init_settings_file()
        settings_file_contents = settings_file.getvalue()
        assert settings_path_mock.is_file.call_count == 1
        assert settings_path_mock.open.call_count == 1
        assert const.SETTINGS_HEADER in settings_file_contents
        for setting in const.DEFAULT_SETTINGS.items():
            assert '# {} = {}\n'.format(*setting) in settings_file_contents
        settings_file.close()


@pytest.mark.parametrize('legacy_dir_exists, xdg_config_home, result', [
    (False, '~/.config', '~/.config/thefuck'),
    (False, '/user/test/config/', '/user/test/config/thefuck'),
    (True, '~/.config', '~/.thefuck'),
    (True, '/user/test/config/', '~/.thefuck')])
def test_get_user_dir_path(mocker, os_environ, settings, legacy_dir_exists,
                           xdg_config_home, result):
    mocker.patch('thefuck.conf.Path.is_dir',
                 return_value=legacy_dir_exists)

    if xdg_config_home is not None:
        os_environ['XDG_CONFIG_HOME'] = xdg_config_home
    else:
        os_environ.pop('XDG_CONFIG_HOME', None)

    path = settings._get_user_dir_path().as_posix()
    assert path == os.path.expanduser(result)<EOS>"
"<BOS>def test_readme(source_root):
    with source_root.joinpath('README.md').open() as f:
        readme = f.read()

        bundled = source_root.joinpath('thefuck') \
                             .joinpath('rules') \
                             .glob('*.py')

        for rule in bundled:
            if rule.stem != '__init__':
                assert rule.stem in readme,\
                    'Missing rule ""{}"" in README.md'.format(rule.stem)<EOS>"
"<BOS># -*- coding: utf-8 -*-

import pytest
from tests.utils import Rule, CorrectedCommand
from thefuck import corrector, const
from thefuck.system import Path
from thefuck.types import Command
from thefuck.corrector import get_corrected_commands, organize_commands


@pytest.fixture
def glob(mocker):
    results = {}
    mocker.patch('thefuck.system.Path.glob',
                 new_callable=lambda: lambda *_: results.pop('value', []))
    return lambda value: results.update({'value': value})


class TestGetRules(object):
    @pytest.fixture(autouse=True)
    def load_source(self, monkeypatch):
        monkeypatch.setattr('thefuck.types.load_source',
                            lambda x, _: Rule(x))

    def _compare_names(self, rules, names):
        assert {r.name for r in rules} == set(names)

    @pytest.mark.parametrize('paths, conf_rules, exclude_rules, loaded_rules', [
        (['git.py', 'bash.py'], const.DEFAULT_RULES, [], ['git', 'bash']),
        (['git.py', 'bash.py'], ['git'], [], ['git']),
        (['git.py', 'bash.py'], const.DEFAULT_RULES, ['git'], ['bash']),
        (['git.py', 'bash.py'], ['git'], ['git'], [])])
    def test_get_rules(self, glob, settings, paths, conf_rules, exclude_rules,
                       loaded_rules):
        glob([Path(path) for path in paths])
        settings.update(rules=conf_rules,
                        priority={},
                        exclude_rules=exclude_rules)
        rules = corrector.get_rules()
        self._compare_names(rules, loaded_rules)


def test_get_rules_rule_exception(mocker, glob):
    load_source = mocker.patch('thefuck.types.load_source',
                               side_effect=ImportError(""No module named foo...""))
    glob([Path('git.py')])
    assert not corrector.get_rules()
    load_source.assert_called_once_with('git', 'git.py')


def test_get_corrected_commands(mocker):
    command = Command('test', 'test')
    rules = [Rule(match=lambda _: False),
             Rule(match=lambda _: True,
                  get_new_command=lambda x: x.script + '!', priority=100),
             Rule(match=lambda _: True,
                  get_new_command=lambda x: [x.script + '@', x.script + ';'],
                  priority=60)]
    mocker.patch('thefuck.corrector.get_rules', return_value=rules)
    assert ([cmd.script for cmd in get_corrected_commands(command)]
            == ['test!', 'test@', 'test;'])


def test_organize_commands():
    """"""Ensures that the function removes duplicates and sorts commands.""""""
    commands = [CorrectedCommand('ls'), CorrectedCommand('ls -la', priority=9000),
                CorrectedCommand('ls -lh', priority=100),
                CorrectedCommand(u'echo café', priority=200),
                CorrectedCommand('ls -lh', priority=9999)]
    assert list(organize_commands(iter(commands))) \
        == [CorrectedCommand('ls'), CorrectedCommand('ls -lh', priority=100),
            CorrectedCommand(u'echo café', priority=200),
            CorrectedCommand('ls -la', priority=9000)]<EOS>"
"<BOS>import pytest
from thefuck import logs


def test_color(settings):
    settings.no_colors = False
    assert logs.color('red') == 'red'
    settings.no_colors = True
    assert logs.color('red') == ''


@pytest.mark.usefixtures('no_colors')
@pytest.mark.parametrize('debug, stderr', [
    (True, 'DEBUG: test\n'),
    (False, '')])
def test_debug(capsys, settings, debug, stderr):
    settings.debug = debug
    logs.debug('test')
    assert capsys.readouterr() == ('', stderr)<EOS>"
"<BOS># -*- encoding: utf-8 -*-

import pytest
from itertools import islice
from thefuck import ui
from thefuck.types import CorrectedCommand
from thefuck import const


@pytest.fixture
def patch_get_key(monkeypatch):
    def patch(vals):
        vals = iter(vals)
        monkeypatch.setattr('thefuck.ui.get_key', lambda: next(vals))

    return patch


def test_read_actions(patch_get_key):
    patch_get_key([
        # Enter:
        '\n',
        # Enter:
        '\r',
        # Ignored:
        'x', 'y',
        # Up:
        const.KEY_UP, 'k',
        # Down:
        const.KEY_DOWN, 'j',
        # Ctrl+C:
        const.KEY_CTRL_C, 'q'])
    assert (list(islice(ui.read_actions(), 8))
            == [const.ACTION_SELECT, const.ACTION_SELECT,
                const.ACTION_PREVIOUS, const.ACTION_PREVIOUS,
                const.ACTION_NEXT, const.ACTION_NEXT,
                const.ACTION_ABORT, const.ACTION_ABORT])


def test_command_selector():
    selector = ui.CommandSelector(iter([1, 2, 3]))
    assert selector.value == 1
    selector.next()
    assert selector.value == 2
    selector.next()
    assert selector.value == 3
    selector.next()
    assert selector.value == 1
    selector.previous()
    assert selector.value == 3


@pytest.mark.usefixtures('no_colors')
class TestSelectCommand(object):
    @pytest.fixture
    def commands_with_side_effect(self):
        return [CorrectedCommand('ls', lambda *_: None, 100),
                CorrectedCommand('cd', lambda *_: None, 100)]

    @pytest.fixture
    def commands(self):
        return [CorrectedCommand('ls', None, 100),
                CorrectedCommand('cd', None, 100)]

    def test_without_commands(self, capsys):
        assert ui.select_command(iter([])) is None
        assert capsys.readouterr() == ('', 'No fucks given\n')

    def test_without_confirmation(self, capsys, commands, settings):
        settings.require_confirmation = False
        assert ui.select_command(iter(commands)) == commands[0]
        assert capsys.readouterr() == ('', const.USER_COMMAND_MARK + 'ls\n')

    def test_without_confirmation_with_side_effects(
            self, capsys, commands_with_side_effect, settings):
        settings.require_confirmation = False
        assert (ui.select_command(iter(commands_with_side_effect))
                == commands_with_side_effect[0])
        assert capsys.readouterr() == ('', const.USER_COMMAND_MARK + 'ls (+side effect)\n')

    def test_with_confirmation(self, capsys, patch_get_key, commands):
        patch_get_key(['\n'])
        assert ui.select_command(iter(commands)) == commands[0]
        assert capsys.readouterr() == (
            '', const.USER_COMMAND_MARK + u'\x1b[1K\rls [enter/↑/↓/ctrl+c]\n')

    def test_with_confirmation_abort(self, capsys, patch_get_key, commands):
        patch_get_key([const.KEY_CTRL_C])
        assert ui.select_command(iter(commands)) is None
        assert capsys.readouterr() == (
            '', const.USER_COMMAND_MARK + u'\x1b[1K\rls [enter/↑/↓/ctrl+c]\nAborted\n')

    def test_with_confirmation_with_side_effct(self, capsys, patch_get_key,
                                               commands_with_side_effect):
        patch_get_key(['\n'])
        assert (ui.select_command(iter(commands_with_side_effect))
                == commands_with_side_effect[0])
        assert capsys.readouterr() == (
            '', const.USER_COMMAND_MARK + u'\x1b[1K\rls (+side effect) [enter/↑/↓/ctrl+c]\n')

    def test_with_confirmation_select_second(self, capsys, patch_get_key, commands):
        patch_get_key([const.KEY_DOWN, '\n'])
        assert ui.select_command(iter(commands)) == commands[1]
        stderr = (
            u'{mark}\x1b[1K\rls [enter/↑/↓/ctrl+c]'
            u'{mark}\x1b[1K\rcd [enter/↑/↓/ctrl+c]\n'
        ).format(mark=const.USER_COMMAND_MARK)
        assert capsys.readouterr() == ('', stderr)<EOS>"
"<BOS># -*- coding: utf-8 -*-

import os
from subprocess import PIPE, STDOUT
from mock import Mock
import pytest
from tests.utils import CorrectedCommand, Rule
from thefuck import const
from thefuck.exceptions import EmptyCommand
from thefuck.system import Path
from thefuck.types import Command


class TestCorrectedCommand(object):

    def test_equality(self):
        assert (CorrectedCommand('ls', None, 100) ==
                CorrectedCommand('ls', None, 200))
        assert (CorrectedCommand('ls', None, 100) !=
                CorrectedCommand('ls', lambda *_: _, 100))

    def test_hashable(self):
        assert {CorrectedCommand('ls', None, 100),
                CorrectedCommand('ls', None, 200)} == {CorrectedCommand('ls')}

    def test_representable(self):
        assert '{}'.format(CorrectedCommand('ls', None, 100)) == \
               'CorrectedCommand(script=ls, side_effect=None, priority=100)'
        assert u'{}'.format(CorrectedCommand(u'echo café', None, 100)) == \
               u'CorrectedCommand(script=echo café, side_effect=None, priority=100)'

    @pytest.mark.parametrize('script, printed, override_settings', [
        ('git branch', 'git branch', {'repeat': False, 'debug': False}),
        ('git brunch',
         ""git brunch || fuck --repeat --force-command 'git brunch'"",
         {'repeat': True, 'debug': False}),
        ('git brunch',
         ""git brunch || fuck --repeat --debug --force-command 'git brunch'"",
         {'repeat': True, 'debug': True})])
    def test_run(self, capsys, settings, script, printed, override_settings):
        settings.update(override_settings)
        CorrectedCommand(script, None, 1000).run(Command(script, ''))
        out, _ = capsys.readouterr()
        assert out == printed


class TestRule(object):
    def test_from_path_rule_exception(self, mocker):
        load_source = mocker.patch('thefuck.types.load_source',
                                   side_effect=ImportError(""No module named foo...""))
        assert Rule.from_path(Path('git.py')) is None
        load_source.assert_called_once_with('git', 'git.py')

    def test_from_path(self, mocker):
        match = object()
        get_new_command = object()
        load_source = mocker.patch(
            'thefuck.types.load_source',
            return_value=Mock(match=match,
                              get_new_command=get_new_command,
                              enabled_by_default=True,
                              priority=900,
                              requires_output=True))
        rule_path = os.path.join(os.sep, 'rules', 'bash.py')
        assert (Rule.from_path(Path(rule_path))
                == Rule('bash', match, get_new_command, priority=900))
        load_source.assert_called_once_with('bash', rule_path)

    def test_from_path_excluded_rule(self, mocker, settings):
        load_source = mocker.patch('thefuck.types.load_source')
        settings.update(exclude_rules=['git'])
        rule_path = os.path.join(os.sep, 'rules', 'git.py')
        assert Rule.from_path(Path(rule_path)) is None
        assert not load_source.called

    @pytest.mark.parametrize('rules, rule, is_enabled', [
        (const.DEFAULT_RULES, Rule('git', enabled_by_default=True), True),
        (const.DEFAULT_RULES, Rule('git', enabled_by_default=False), False),
        ([], Rule('git', enabled_by_default=False), False),
        ([], Rule('git', enabled_by_default=True), False),
        (const.DEFAULT_RULES + ['git'], Rule('git', enabled_by_default=False), True),
        (['git'], Rule('git', enabled_by_default=False), True)])
    def test_is_enabled(self, settings, rules, rule, is_enabled):
        settings.update(rules=rules)
        assert rule.is_enabled == is_enabled

    def test_isnt_match(self):
        assert not Rule('', lambda _: False).is_match(
            Command('ls', ''))

    def test_is_match(self):
        rule = Rule('', lambda x: x.script == 'cd ..')
        assert rule.is_match(Command('cd ..', ''))

    @pytest.mark.usefixtures('no_colors')
    def test_isnt_match_when_rule_failed(self, capsys):
        rule = Rule('test', Mock(side_effect=OSError('Denied')),
                    requires_output=False)
        assert not rule.is_match(Command('ls', ''))
        assert capsys.readouterr()[1].split('\n')[0] == '[WARN] Rule test:'

    def test_get_corrected_commands_with_rule_returns_list(self):
        rule = Rule(get_new_command=lambda x: [x.script + '!', x.script + '@'],
                    priority=100)
        assert (list(rule.get_corrected_commands(Command('test', '')))
                == [CorrectedCommand(script='test!', priority=100),
                    CorrectedCommand(script='test@', priority=200)])

    def test_get_corrected_commands_with_rule_returns_command(self):
        rule = Rule(get_new_command=lambda x: x.script + '!',
                    priority=100)
        assert (list(rule.get_corrected_commands(Command('test', '')))
                == [CorrectedCommand(script='test!', priority=100)])


class TestCommand(object):
    @pytest.fixture(autouse=True)
    def Popen(self, monkeypatch):
        Popen = Mock()
        Popen.return_value.stdout.read.return_value = b'output'
        monkeypatch.setattr('thefuck.output_readers.rerun.Popen', Popen)
        return Popen

    @pytest.fixture(autouse=True)
    def prepare(self, monkeypatch):
        monkeypatch.setattr('thefuck.output_readers.rerun._wait_output',
                            lambda *_: True)

    def test_from_script_calls(self, Popen, settings, os_environ):
        settings.env = {}
        assert Command.from_raw_script(
            ['apt-get', 'search', 'vim']) == Command(
            'apt-get search vim', 'output')
        Popen.assert_called_once_with('apt-get search vim',
                                      shell=True,
                                      stdin=PIPE,
                                      stdout=PIPE,
                                      stderr=STDOUT,
                                      env=os_environ)

    @pytest.mark.parametrize('script, result', [
        ([], None),
        ([''], None),
        (['', ''], None),
        (['ls', '-la'], 'ls -la'),
        (['ls'], 'ls'),
        (['echo \\ '], 'echo \\ '),
        (['echo \\\n'], 'echo \\\n')])
    def test_from_script(self, script, result):
        if result:
            assert Command.from_raw_script(script).script == result
        else:
            with pytest.raises(EmptyCommand):
                Command.from_raw_script(script)<EOS>"
"<BOS># -*- coding: utf-8 -*-

import pytest
import warnings
from mock import Mock, call, patch
from thefuck.utils import default_settings, \
    memoize, get_closest, get_all_executables, replace_argument, \
    get_all_matched_commands, is_app, for_app, cache, \
    get_valid_history_without_current, _cache, get_close_matches
from thefuck.types import Command


@pytest.mark.parametrize('override, old, new', [
    ({'key': 'val'}, {}, {'key': 'val'}),
    ({'key': 'new-val'}, {'key': 'val'}, {'key': 'val'}),
    ({'key': 'new-val', 'unset': 'unset'}, {'key': 'val'}, {'key': 'val', 'unset': 'unset'})])
def test_default_settings(settings, override, old, new):
    settings.clear()
    settings.update(old)
    default_settings(override)(lambda _: _)(None)
    assert settings == new


def test_memoize():
    fn = Mock(__name__='fn')
    memoized = memoize(fn)
    memoized()
    memoized()
    fn.assert_called_once_with()


@pytest.mark.usefixtures('no_memoize')
def test_no_memoize():
    fn = Mock(__name__='fn')
    memoized = memoize(fn)
    memoized()
    memoized()
    assert fn.call_count == 2


class TestGetClosest(object):
    def test_when_can_match(self):
        assert 'branch' == get_closest('brnch', ['branch', 'status'])

    def test_when_cant_match(self):
        assert 'status' == get_closest('st', ['status', 'reset'])

    def test_without_fallback(self):
        assert get_closest('st', ['status', 'reset'],
                           fallback_to_first=False) is None


class TestGetCloseMatches(object):
    @patch('thefuck.utils.difflib_get_close_matches')
    def test_call_with_n(self, difflib_mock):
        get_close_matches('', [], 1)
        assert difflib_mock.call_args[0][2] == 1

    @patch('thefuck.utils.difflib_get_close_matches')
    def test_call_without_n(self, difflib_mock, settings):
        get_close_matches('', [])
        assert difflib_mock.call_args[0][2] == settings.get('num_close_matches')


@pytest.fixture
def get_aliases(mocker):
    mocker.patch('thefuck.shells.shell.get_aliases',
                 return_value=['vim', 'apt-get', 'fsck', 'fuck'])


@pytest.mark.usefixtures('no_memoize', 'get_aliases')
def test_get_all_executables():
    all_callables = get_all_executables()
    assert 'vim' in all_callables
    assert 'fsck' in all_callables
    assert 'fuck' not in all_callables


@pytest.fixture
def os_environ_pathsep(monkeypatch, path, pathsep):
    env = {'PATH': path}
    monkeypatch.setattr('os.environ', env)
    monkeypatch.setattr('os.pathsep', pathsep)
    return env


@pytest.mark.usefixtures('no_memoize', 'os_environ_pathsep')
@pytest.mark.parametrize('path, pathsep', [
    ('/foo:/bar:/baz:/foo/bar', ':'),
    (r'C:\\foo;C:\\bar;C:\\baz;C:\\foo\\bar', ';')])
def test_get_all_executables_pathsep(path, pathsep):
    with patch('thefuck.utils.Path') as Path_mock:
        get_all_executables()
        Path_mock.assert_has_calls([call(p) for p in path.split(pathsep)], True)


@pytest.mark.usefixtures('no_memoize', 'os_environ_pathsep')
@pytest.mark.parametrize('path, pathsep, excluded', [
    ('/foo:/bar:/baz:/foo/bar:/mnt/foo', ':', '/mnt/foo'),
    (r'C:\\foo;C:\\bar;C:\\baz;C:\\foo\\bar;Z:\\foo', ';', r'Z:\\foo')])
def test_get_all_executables_exclude_paths(path, pathsep, excluded, settings):
    settings.init()
    settings.excluded_search_path_prefixes = [excluded]
    with patch('thefuck.utils.Path') as Path_mock:
        get_all_executables()
        path_list = path.split(pathsep)
        assert call(path_list[-1]) not in Path_mock.mock_calls
        assert all(call(p) in Path_mock.mock_calls for p in path_list[:-1])


@pytest.mark.parametrize('args, result', [
    (('apt-get instol vim', 'instol', 'install'), 'apt-get install vim'),
    (('git brnch', 'brnch', 'branch'), 'git branch')])
def test_replace_argument(args, result):
    assert replace_argument(*args) == result


@pytest.mark.parametrize('stderr, result', [
    ((""git: 'cone' is not a git command. See 'git --help'.\n""
      '\n'
      'Did you mean one of these?\n'
      '\tclone'), ['clone']),
    ((""git: 're' is not a git command. See 'git --help'.\n""
      '\n'
      'Did you mean one of these?\n'
      '\trebase\n'
      '\treset\n'
      '\tgrep\n'
      '\trm'), ['rebase', 'reset', 'grep', 'rm']),
    (('tsuru: ""target"" is not a tsuru command. See ""tsuru help"".\n'
      '\n'
      'Did you mean one of these?\n'
      '\tservice-add\n'
      '\tservice-bind\n'
      '\tservice-doc\n'
      '\tservice-info\n'
      '\tservice-list\n'
      '\tservice-remove\n'
      '\tservice-status\n'
      '\tservice-unbind'), ['service-add', 'service-bind', 'service-doc',
                            'service-info', 'service-list', 'service-remove',
                            'service-status', 'service-unbind'])])
def test_get_all_matched_commands(stderr, result):
    assert list(get_all_matched_commands(stderr)) == result


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script, names, result', [
    ('/usr/bin/git diff', ['git', 'hub'], True),
    ('/bin/hdfs dfs -rm foo', ['hdfs'], True),
    ('git diff', ['git', 'hub'], True),
    ('hub diff', ['git', 'hub'], True),
    ('hg diff', ['git', 'hub'], False)])
def test_is_app(script, names, result):
    assert is_app(Command(script, ''), *names) == result


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script, names, result', [
    ('/usr/bin/git diff', ['git', 'hub'], True),
    ('/bin/hdfs dfs -rm foo', ['hdfs'], True),
    ('git diff', ['git', 'hub'], True),
    ('hub diff', ['git', 'hub'], True),
    ('hg diff', ['git', 'hub'], False)])
def test_for_app(script, names, result):
    @for_app(*names)
    def match(command):
        return True

    assert match(Command(script, '')) == result


class TestCache(object):
    @pytest.fixture
    def shelve(self, mocker):
        value = {}

        class _Shelve(object):
            def __init__(self, path):
                pass

            def __setitem__(self, k, v):
                value[k] = v

            def __getitem__(self, k):
                return value[k]

            def get(self, k, v=None):
                return value.get(k, v)

            def close(self):
                return

        mocker.patch('thefuck.utils.shelve.open', new_callable=lambda: _Shelve)
        return value

    @pytest.fixture(autouse=True)
    def enable_cache(self, monkeypatch, shelve):
        monkeypatch.setattr('thefuck.utils.cache.disabled', False)
        _cache._init_db()

    @pytest.fixture(autouse=True)
    def mtime(self, mocker):
        mocker.patch('thefuck.utils.os.path.getmtime', return_value=0)

    @pytest.fixture
    def fn(self):
        @cache('~/.bashrc')
        def fn():
            return 'test'

        return fn

    @pytest.fixture
    def key(self, monkeypatch):
        monkeypatch.setattr('thefuck.utils.Cache._get_key',
                            lambda *_: 'key')
        return 'key'

    def test_with_blank_cache(self, shelve, fn, key):
        assert shelve == {}
        assert fn() == 'test'
        assert shelve == {key: {'etag': '0', 'value': 'test'}}

    def test_with_filled_cache(self, shelve, fn, key):
        cache_value = {key: {'etag': '0', 'value': 'new-value'}}
        shelve.update(cache_value)
        assert fn() == 'new-value'
        assert shelve == cache_value

    def test_when_etag_changed(self, shelve, fn, key):
        shelve.update({key: {'etag': '-1', 'value': 'old-value'}})
        assert fn() == 'test'
        assert shelve == {key: {'etag': '0', 'value': 'test'}}


class TestGetValidHistoryWithoutCurrent(object):
    @pytest.fixture(autouse=True)
    def fail_on_warning(self):
        warnings.simplefilter('error')
        yield
        warnings.resetwarnings()

    @pytest.fixture(autouse=True)
    def history(self, mocker):
        mock = mocker.patch('thefuck.shells.shell.get_history')
        #  Passing as an argument causes `UnicodeDecodeError`
        #  with newer py.test and python 2.7
        mock.return_value = ['le cat', 'fuck', 'ls cat',
                             'diff x', 'nocommand x', u'café ô']
        return mock

    @pytest.fixture(autouse=True)
    def alias(self, mocker):
        return mocker.patch('thefuck.utils.get_alias',
                            return_value='fuck')

    @pytest.fixture(autouse=True)
    def bins(self, mocker):
        callables = list()
        for name in ['diff', 'ls', 'café']:
            bin_mock = mocker.Mock(name=name)
            bin_mock.configure_mock(name=name, is_dir=lambda: False)
            callables.append(bin_mock)
        path_mock = mocker.Mock(iterdir=mocker.Mock(return_value=callables))
        return mocker.patch('thefuck.utils.Path', return_value=path_mock)

    @pytest.mark.parametrize('script, result', [
        ('le cat', ['ls cat', 'diff x', u'café ô']),
        ('diff x', ['ls cat', u'café ô']),
        ('fuck', ['ls cat', 'diff x', u'café ô']),
        (u'cafe ô', ['ls cat', 'diff x', u'café ô']),
    ])
    def test_get_valid_history_without_current(self, script, result):
        command = Command(script, '')
        assert get_valid_history_without_current(command) == result<EOS>"
"<BOS># -*- encoding: utf-8 -*-

from mock import Mock, patch
from psutil import AccessDenied, TimeoutExpired

from thefuck.output_readers import rerun


class TestRerun(object):
    def setup_method(self, test_method):
        self.patcher = patch('thefuck.output_readers.rerun.Process')
        process_mock = self.patcher.start()
        self.proc_mock = process_mock.return_value = Mock()

    def teardown_method(self, test_method):
        self.patcher.stop()

    @patch('thefuck.output_readers.rerun._wait_output', return_value=False)
    @patch('thefuck.output_readers.rerun.Popen')
    def test_get_output(self, popen_mock, wait_output_mock):
        popen_mock.return_value.stdout.read.return_value = b'output'
        assert rerun.get_output('', '') is None
        wait_output_mock.assert_called_once()

    @patch('thefuck.output_readers.rerun.Popen')
    def test_get_output_invalid_continuation_byte(self, popen_mock):
        output = b'ls: illegal option -- \xc3\nusage: ls [-@ABC...] [file ...]\n'
        expected = u'ls: illegal option -- \ufffd\nusage: ls [-@ABC...] [file ...]\n'
        popen_mock.return_value.stdout.read.return_value = output
        actual = rerun.get_output('', '')
        assert actual == expected

    @patch('thefuck.output_readers.rerun._wait_output')
    def test_get_output_unicode_misspell(self, wait_output_mock):
        rerun.get_output(u'pácman', u'pácman')
        wait_output_mock.assert_called_once()

    def test_wait_output_is_slow(self, settings):
        assert rerun._wait_output(Mock(), True)
        self.proc_mock.wait.assert_called_once_with(settings.wait_slow_command)

    def test_wait_output_is_not_slow(self, settings):
        assert rerun._wait_output(Mock(), False)
        self.proc_mock.wait.assert_called_once_with(settings.wait_command)

    @patch('thefuck.output_readers.rerun._kill_process')
    def test_wait_output_timeout(self, kill_process_mock):
        self.proc_mock.wait.side_effect = TimeoutExpired(3)
        self.proc_mock.children.return_value = []
        assert not rerun._wait_output(Mock(), False)
        kill_process_mock.assert_called_once_with(self.proc_mock)

    @patch('thefuck.output_readers.rerun._kill_process')
    def test_wait_output_timeout_children(self, kill_process_mock):
        self.proc_mock.wait.side_effect = TimeoutExpired(3)
        self.proc_mock.children.return_value = [Mock()] * 2
        assert not rerun._wait_output(Mock(), False)
        assert kill_process_mock.call_count == 3

    def test_kill_process(self):
        proc = Mock()
        rerun._kill_process(proc)
        proc.kill.assert_called_once_with()

    @patch('thefuck.output_readers.rerun.logs')
    def test_kill_process_access_denied(self, logs_mock):
        proc = Mock()
        proc.kill.side_effect = AccessDenied()
        rerun._kill_process(proc)
        proc.kill.assert_called_once_with()
        logs_mock.debug.assert_called_once()<EOS>"
"<BOS>from io import BytesIO

import pytest
from thefuck.specific.npm import get_scripts

run_script_stdout = b'''
Lifecycle scripts included in code-view-web:
  test
    jest

available via `npm run-script`:
  build
    cp node_modules/ace-builds/src-min/ -a resources/ace/ && webpack --progress --colors -p --config ./webpack.production.config.js
  develop
    cp node_modules/ace-builds/src/ -a resources/ace/ && webpack-dev-server --progress --colors
  watch-test
    jest --verbose --watch

'''


@pytest.mark.usefixtures('no_memoize')
def test_get_scripts(mocker):
    patch = mocker.patch('thefuck.specific.npm.Popen')
    patch.return_value.stdout = BytesIO(run_script_stdout)
    assert get_scripts() == ['build', 'develop', 'watch-test']<EOS>"
"<BOS>import pytest
from thefuck.specific.sudo import sudo_support
from thefuck.types import Command


@pytest.mark.parametrize('return_value, command, called, result', [
    ('ls -lah', 'sudo ls', 'ls', 'sudo ls -lah'),
    ('ls -lah', 'ls', 'ls', 'ls -lah'),
    (['ls -lah'], 'sudo ls', 'ls', ['sudo ls -lah']),
    (True, 'sudo ls', 'ls', True),
    (True, 'ls', 'ls', True),
    (False, 'sudo ls', 'ls', False),
    (False, 'ls', 'ls', False)])
def test_sudo_support(return_value, command, called, result):
    def fn(command):
        assert command == Command(called, '')
        return return_value

    assert sudo_support(fn)(Command(command, '')) == result<EOS>"
"<BOS>import pytest
from thefuck.specific.git import git_support
from thefuck.types import Command


@pytest.mark.parametrize('called, command, output', [
    ('git co', 'git checkout', ""19:22:36.299340 git.c:282   trace: alias expansion: co => 'checkout'""),
    ('git com file', 'git commit --verbose file',
     ""19:23:25.470911 git.c:282   trace: alias expansion: com => 'commit' '--verbose'""),
    ('git com -m ""Initial commit""', 'git commit -m ""Initial commit""',
     ""19:22:36.299340 git.c:282   trace: alias expansion: com => 'commit'""),
    ('git br -d some_branch', 'git branch -d some_branch',
     ""19:22:36.299340 git.c:282   trace: alias expansion: br => 'branch'"")])
def test_git_support(called, command, output):
    @git_support
    def fn(command):
        return command.script

    assert fn(Command(called, output)) == command


@pytest.mark.parametrize('command, is_git', [
    ('git pull', True),
    ('hub pull', True),
    ('git push --set-upstream origin foo', True),
    ('hub push --set-upstream origin foo', True),
    ('ls', False),
    ('cat git', False),
    ('cat hub', False)])
@pytest.mark.parametrize('output', ['', None])
def test_git_support_match(command, is_git, output):
    @git_support
    def fn(command):
        return True

    assert fn(Command(command, output)) == is_git<EOS>"
"<BOS>import pytest
from tests.functional.plots import with_confirmation, without_confirmation, \
    refuse_with_confirmation, select_command_with_arrows

containers = (('thefuck/python3-tcsh',
               u'''FROM python:3
                   RUN apt-get update
                   RUN apt-get install -yy tcsh''',
               u'tcsh'),
              ('thefuck/python2-tcsh',
               u'''FROM python:2
                   RUN apt-get update
                   RUN apt-get install -yy tcsh''',
               u'tcsh'))


@pytest.fixture(params=containers)
def proc(request, spawnu, TIMEOUT):
    proc = spawnu(*request.param)
    proc.sendline(u'pip install /src')
    assert proc.expect([TIMEOUT, u'Successfully installed'])
    proc.sendline(u'tcsh')
    proc.sendline(u'setenv PYTHONIOENCODING utf8')
    proc.sendline(u'eval `thefuck --alias`')
    return proc


@pytest.mark.functional
def test_with_confirmation(proc, TIMEOUT):
    with_confirmation(proc, TIMEOUT)


@pytest.mark.functional
def test_select_command_with_arrows(proc, TIMEOUT):
    select_command_with_arrows(proc, TIMEOUT)


@pytest.mark.functional
def test_refuse_with_confirmation(proc, TIMEOUT):
    refuse_with_confirmation(proc, TIMEOUT)


@pytest.mark.functional
def test_without_confirmation(proc, TIMEOUT):
    without_confirmation(proc, TIMEOUT)

# TODO: ensure that history changes.<EOS>"
"<BOS>import pytest
from tests.functional.plots import with_confirmation, without_confirmation, \
    refuse_with_confirmation, history_changed, history_not_changed, \
    select_command_with_arrows, how_to_configure


python_3 = (u'thefuck/python3-bash',
            u'FROM python:3',
            u'sh')

python_2 = (u'thefuck/python2-bash',
            u'FROM python:2',
            u'sh')


init_bashrc = u'''echo '
export SHELL=/bin/bash
export PS1=""$ ""
echo > $HISTFILE
eval $(thefuck --alias {})
echo ""instant mode ready: $THEFUCK_INSTANT_MODE""
' > ~/.bashrc'''


@pytest.fixture(params=[(python_3, False),
                        (python_3, True),
                        (python_2, False)])
def proc(request, spawnu, TIMEOUT):
    container, instant_mode = request.param
    proc = spawnu(*container)
    proc.sendline(u""pip install /src"")
    assert proc.expect([TIMEOUT, u'Successfully installed'])
    proc.sendline(init_bashrc.format(
        u'--enable-experimental-instant-mode' if instant_mode else ''))
    proc.sendline(u""bash"")
    if instant_mode:
        assert proc.expect([TIMEOUT, u'instant mode ready: True'])
    return proc


@pytest.mark.functional
def test_with_confirmation(proc, TIMEOUT):
    with_confirmation(proc, TIMEOUT)
    history_changed(proc, TIMEOUT, u'echo test')


@pytest.mark.functional
def test_select_command_with_arrows(proc, TIMEOUT):
    select_command_with_arrows(proc, TIMEOUT)
    history_changed(proc, TIMEOUT, u'git help')


@pytest.mark.functional
def test_refuse_with_confirmation(proc, TIMEOUT):
    refuse_with_confirmation(proc, TIMEOUT)
    history_not_changed(proc, TIMEOUT)


@pytest.mark.functional
def test_without_confirmation(proc, TIMEOUT):
    without_confirmation(proc, TIMEOUT)
    history_changed(proc, TIMEOUT, u'echo test')


@pytest.mark.functional
def test_how_to_configure_alias(proc, TIMEOUT):
    proc.sendline('unset -f fuck')
    how_to_configure(proc, TIMEOUT)<EOS>"
"<BOS>def _set_confirmation(proc, require):
    proc.sendline(u'mkdir -p ~/.thefuck')
    proc.sendline(
        u'echo ""require_confirmation = {}"" > ~/.thefuck/settings.py'.format(
            require))


def with_confirmation(proc, TIMEOUT):
    """"""Ensures that command can be fixed when confirmation enabled.""""""
    _set_confirmation(proc, True)

    proc.sendline(u'ehco test')

    proc.sendline(u'fuck')
    assert proc.expect([TIMEOUT, u'echo test'])
    assert proc.expect([TIMEOUT, u'enter'])
    assert proc.expect_exact([TIMEOUT, u'ctrl+c'])
    proc.send('\n')

    assert proc.expect([TIMEOUT, u'test'])


def history_changed(proc, TIMEOUT, to):
    """"""Ensures that history changed.""""""
    proc.send('\033[A')
    assert proc.expect([TIMEOUT, to])


def history_not_changed(proc, TIMEOUT):
    """"""Ensures that history not changed.""""""
    proc.send('\033[A')
    assert proc.expect([TIMEOUT, u'fuck'])


def select_command_with_arrows(proc, TIMEOUT):
    """"""Ensures that command can be selected with arrow keys.""""""
    _set_confirmation(proc, True)

    proc.sendline(u'git h')
    assert proc.expect([TIMEOUT, u""git: 'h' is not a git command.""])

    proc.sendline(u'fuck')
    assert proc.expect([TIMEOUT, u'git show'])
    proc.send('\033[B')
    assert proc.expect([TIMEOUT, u'git push'])
    proc.send('\033[B')
    assert proc.expect([TIMEOUT, u'git help'])
    proc.send('\033[A')
    assert proc.expect([TIMEOUT, u'git push'])
    proc.send('\033[B')
    assert proc.expect([TIMEOUT, u'git help'])
    proc.send('\n')

    assert proc.expect([TIMEOUT, u'usage'])


def refuse_with_confirmation(proc, TIMEOUT):
    """"""Ensures that fix can be refused when confirmation enabled.""""""
    _set_confirmation(proc, True)

    proc.sendline(u'ehco test')

    proc.sendline(u'fuck')
    assert proc.expect([TIMEOUT, u'echo test'])
    assert proc.expect([TIMEOUT, u'enter'])
    assert proc.expect_exact([TIMEOUT, u'ctrl+c'])
    proc.send('\003')

    assert proc.expect([TIMEOUT, u'Aborted'])


def without_confirmation(proc, TIMEOUT):
    """"""Ensures that command can be fixed when confirmation disabled.""""""
    _set_confirmation(proc, False)

    proc.sendline(u'ehco test')

    proc.sendline(u'fuck')
    assert proc.expect([TIMEOUT, u'echo test'])
    assert proc.expect([TIMEOUT, u'test'])


def how_to_configure(proc, TIMEOUT):
    proc.sendline(u'fuck')
    assert proc.expect([TIMEOUT, u""alias isn't configured""])<EOS>"
"<BOS>import pytest
from tests.functional.plots import with_confirmation, without_confirmation, \
    refuse_with_confirmation, select_command_with_arrows

containers = (('thefuck/python3-fish',
               u'''FROM python:3
                   # Use jessie-backports since it has the fish package. See here for details:
                   # https://github.com/tianon/docker-brew-debian/blob/88ae21052affd8a14553bb969f9d41c464032122/jessie/backports/Dockerfile
                   RUN awk '$1 ~ ""^deb"" { $3 = $3 ""-backports""; print; exit }' /etc/apt/sources.list > /etc/apt/sources.list.d/backports.list
                   RUN apt-get update
                   RUN apt-get install -yy fish''',
               u'fish'),
              ('thefuck/python2-fish',
               u'''FROM python:2
                   # Use jessie-backports since it has the fish package. See here for details:
                   # https://github.com/tianon/docker-brew-debian/blob/88ae21052affd8a14553bb969f9d41c464032122/jessie/backports/Dockerfile
                   RUN awk '$1 ~ ""^deb"" { $3 = $3 ""-backports""; print; exit }' /etc/apt/sources.list > /etc/apt/sources.list.d/backports.list
                   RUN apt-get update
                   RUN apt-get install -yy fish''',
               u'fish'))


@pytest.fixture(params=containers)
def proc(request, spawnu, TIMEOUT):
    proc = spawnu(*request.param)
    proc.sendline(u""pip install /src"")
    assert proc.expect([TIMEOUT, u'Successfully installed'])
    proc.sendline(u'thefuck --alias > ~/.config/fish/config.fish')
    proc.sendline(u'fish')
    return proc


@pytest.mark.functional
def test_with_confirmation(proc, TIMEOUT):
    with_confirmation(proc, TIMEOUT)


@pytest.mark.functional
def test_select_command_with_arrows(proc, TIMEOUT):
    select_command_with_arrows(proc, TIMEOUT)


@pytest.mark.functional
def test_refuse_with_confirmation(proc, TIMEOUT):
    refuse_with_confirmation(proc, TIMEOUT)


@pytest.mark.functional
def test_without_confirmation(proc, TIMEOUT):
    without_confirmation(proc, TIMEOUT)

# TODO: ensure that history changes.<EOS>"
"<BOS>import pytest
from tests.functional.plots import with_confirmation, without_confirmation, \
    refuse_with_confirmation, history_changed, history_not_changed, \
    select_command_with_arrows, how_to_configure


python_3 = ('thefuck/python3-zsh',
            u'''FROM python:3
                RUN apt-get update
                RUN apt-get install -yy zsh''',
            u'sh')

python_2 = ('thefuck/python2-zsh',
            u'''FROM python:2
                RUN apt-get update
                RUN apt-get install -yy zsh''',
            u'sh')


init_zshrc = u'''echo '
export SHELL=/usr/bin/zsh
export HISTFILE=~/.zsh_history
echo > $HISTFILE
export SAVEHIST=100
export HISTSIZE=100
eval $(thefuck --alias {})
setopt INC_APPEND_HISTORY
echo ""instant mode ready: $THEFUCK_INSTANT_MODE""
' > ~/.zshrc'''


@pytest.fixture(params=[(python_3, False),
                        (python_3, True),
                        (python_2, False)])
def proc(request, spawnu, TIMEOUT):
    container, instant_mode = request.param
    proc = spawnu(*container)
    proc.sendline(u'pip install /src')
    assert proc.expect([TIMEOUT, u'Successfully installed'])
    proc.sendline(init_zshrc.format(
        u'--enable-experimental-instant-mode' if instant_mode else ''))
    proc.sendline(u""zsh"")
    if instant_mode:
        assert proc.expect([TIMEOUT, u'instant mode ready: True'])
    return proc


@pytest.mark.functional
def test_with_confirmation(proc, TIMEOUT):
    with_confirmation(proc, TIMEOUT)
    history_changed(proc, TIMEOUT, u'echo test')


@pytest.mark.functional
def test_select_command_with_arrows(proc, TIMEOUT):
    select_command_with_arrows(proc, TIMEOUT)
    history_changed(proc, TIMEOUT, u'git help')


@pytest.mark.functional
def test_refuse_with_confirmation(proc, TIMEOUT):
    refuse_with_confirmation(proc, TIMEOUT)
    history_not_changed(proc, TIMEOUT)


@pytest.mark.functional
def test_without_confirmation(proc, TIMEOUT):
    without_confirmation(proc, TIMEOUT)
    history_changed(proc, TIMEOUT, u'echo test')


@pytest.mark.functional
def test_how_to_configure_alias(proc, TIMEOUT):
    proc.sendline(u'unfunction fuck')
    how_to_configure(proc, TIMEOUT)<EOS>"
"<BOS>import pytest


@pytest.fixture
def builtins_open(mocker):
    return mocker.patch('six.moves.builtins.open')


@pytest.fixture
def isfile(mocker):
    return mocker.patch('os.path.isfile', return_value=True)


@pytest.fixture
@pytest.mark.usefixtures('isfile')
def history_lines(mocker):
    def aux(lines):
        mock = mocker.patch('io.open')
        mock.return_value.__enter__ \
            .return_value.readlines.return_value = lines

    return aux


@pytest.fixture
def config_exists(mocker):
    path_mock = mocker.patch('thefuck.shells.generic.Path')
    return path_mock.return_value \
        .expanduser.return_value \
        .exists<EOS>"
"<BOS># -*- coding: utf-8 -*-

import os
import pytest
from thefuck.shells.zsh import Zsh


@pytest.mark.usefixtures('isfile', 'no_memoize', 'no_cache')
class TestZsh(object):
    @pytest.fixture
    def shell(self):
        return Zsh()

    @pytest.fixture(autouse=True)
    def Popen(self, mocker):
        mock = mocker.patch('thefuck.shells.zsh.Popen')
        return mock

    @pytest.fixture(autouse=True)
    def shell_aliases(self):
        os.environ['TF_SHELL_ALIASES'] = (
            'fuck=\'eval $(thefuck $(fc -ln -1 | tail -n 1))\'\n'
            'l=\'ls -CF\'\n'
            'la=\'ls -A\'\n'
            'll=\'ls -alF\'')

    @pytest.mark.parametrize('before, after', [
        ('fuck', 'eval $(thefuck $(fc -ln -1 | tail -n 1))'),
        ('pwd', 'pwd'),
        ('ll', 'ls -alF')])
    def test_from_shell(self, before, after, shell):
        assert shell.from_shell(before) == after

    def test_to_shell(self, shell):
        assert shell.to_shell('pwd') == 'pwd'

    def test_and_(self, shell):
        assert shell.and_('ls', 'cd') == 'ls && cd'

    def test_or_(self, shell):
        assert shell.or_('ls', 'cd') == 'ls || cd'

    def test_get_aliases(self, shell):
        assert shell.get_aliases() == {
            'fuck': 'eval $(thefuck $(fc -ln -1 | tail -n 1))',
            'l': 'ls -CF',
            'la': 'ls -A',
            'll': 'ls -alF'}

    def test_app_alias(self, shell):
        assert 'fuck () {' in shell.app_alias('fuck')
        assert 'FUCK () {' in shell.app_alias('FUCK')
        assert 'thefuck' in shell.app_alias('fuck')
        assert 'PYTHONIOENCODING' in shell.app_alias('fuck')

    def test_app_alias_variables_correctly_set(self, shell):
        alias = shell.app_alias('fuck')
        assert ""fuck () {"" in alias
        assert 'TF_SHELL=zsh' in alias
        assert ""TF_ALIAS=fuck"" in alias
        assert 'PYTHONIOENCODING=utf-8' in alias
        assert 'TF_SHELL_ALIASES=$(alias)' in alias

    def test_get_history(self, history_lines, shell):
        history_lines([': 1432613911:0;ls', ': 1432613916:0;rm'])
        assert list(shell.get_history()) == ['ls', 'rm']

    def test_how_to_configure(self, shell, config_exists):
        config_exists.return_value = True
        assert shell.how_to_configure().can_configure_automatically

    def test_how_to_configure_when_config_not_found(self, shell,
                                                    config_exists):
        config_exists.return_value = False
        assert not shell.how_to_configure().can_configure_automatically

    def test_info(self, shell, Popen):
        Popen.return_value.stdout.read.side_effect = [b'3.5.9']
        assert shell.info() == 'ZSH 3.5.9'

    def test_get_version_error(self, shell, Popen):
        Popen.return_value.stdout.read.side_effect = OSError
        with pytest.raises(OSError):
            shell._get_version()
        assert Popen.call_args[0][0] == ['zsh', '-c', 'echo $ZSH_VERSION']<EOS>"
"<BOS># -*- coding: utf-8 -*-

import pytest
from thefuck.shells.tcsh import Tcsh


@pytest.mark.usefixtures('isfile', 'no_memoize', 'no_cache')
class TestTcsh(object):
    @pytest.fixture
    def shell(self):
        return Tcsh()

    @pytest.fixture(autouse=True)
    def Popen(self, mocker):
        mock = mocker.patch('thefuck.shells.tcsh.Popen')
        mock.return_value.stdout.read.return_value = (
            b'fuck\teval $(thefuck $(fc -ln -1))\n'
            b'l\tls -CF\n'
            b'la\tls -A\n'
            b'll\tls -alF')
        return mock

    @pytest.mark.parametrize('before, after', [
        ('pwd', 'pwd'),
        ('fuck', 'eval $(thefuck $(fc -ln -1))'),
        ('awk', 'awk'),
        ('ll', 'ls -alF')])
    def test_from_shell(self, before, after, shell):
        assert shell.from_shell(before) == after

    def test_to_shell(self, shell):
        assert shell.to_shell('pwd') == 'pwd'

    def test_and_(self, shell):
        assert shell.and_('ls', 'cd') == 'ls && cd'

    def test_or_(self, shell):
        assert shell.or_('ls', 'cd') == 'ls || cd'

    def test_get_aliases(self, shell):
        assert shell.get_aliases() == {'fuck': 'eval $(thefuck $(fc -ln -1))',
                                       'l': 'ls -CF',
                                       'la': 'ls -A',
                                       'll': 'ls -alF'}

    def test_app_alias(self, shell):
        assert 'setenv TF_SHELL tcsh' in shell.app_alias('fuck')
        assert 'alias fuck' in shell.app_alias('fuck')
        assert 'alias FUCK' in shell.app_alias('FUCK')
        assert 'thefuck' in shell.app_alias('fuck')

    def test_get_history(self, history_lines, shell):
        history_lines(['ls', 'rm'])
        assert list(shell.get_history()) == ['ls', 'rm']

    def test_how_to_configure(self, shell, config_exists):
        config_exists.return_value = True
        assert shell.how_to_configure().can_configure_automatically

    def test_how_to_configure_when_config_not_found(self, shell,
                                                    config_exists):
        config_exists.return_value = False
        assert not shell.how_to_configure().can_configure_automatically

    def test_info(self, shell, Popen):
        Popen.return_value.stdout.read.side_effect = [
            b'tcsh 6.20.00 (Astron) 2016-11-24 (unknown-unknown-bsd44) \n']
        assert shell.info() == 'Tcsh 6.20.00'
        assert Popen.call_args[0][0] == ['tcsh', '--version']

    @pytest.mark.parametrize('side_effect, exception', [
        ([b'\n'], IndexError), (OSError, OSError)])
    def test_get_version_error(self, side_effect, exception, shell, Popen):
        Popen.return_value.stdout.read.side_effect = side_effect
        with pytest.raises(exception):
            shell._get_version()
        assert Popen.call_args[0][0] == ['tcsh', '--version']<EOS>"
"<BOS># -*- coding: utf-8 -*-

import pytest
from thefuck.shells import Powershell


@pytest.mark.usefixtures('isfile', 'no_memoize', 'no_cache')
class TestPowershell(object):
    @pytest.fixture
    def shell(self):
        return Powershell()

    @pytest.fixture(autouse=True)
    def Popen(self, mocker):
        mock = mocker.patch('thefuck.shells.powershell.Popen')
        return mock

    def test_and_(self, shell):
        assert shell.and_('ls', 'cd') == '(ls) -and (cd)'

    def test_app_alias(self, shell):
        assert 'function fuck' in shell.app_alias('fuck')
        assert 'function FUCK' in shell.app_alias('FUCK')
        assert 'thefuck' in shell.app_alias('fuck')

    def test_how_to_configure(self, shell):
        assert not shell.how_to_configure().can_configure_automatically

    @pytest.mark.parametrize('side_effect, expected_version, call_args', [
        ([b'''Major  Minor  Build  Revision
-----  -----  -----  --------
5      1      17763  316     \n'''], 'PowerShell 5.1.17763.316', ['powershell.exe']),
        ([IOError, b'PowerShell 6.1.2\n'], 'PowerShell 6.1.2', ['powershell.exe', 'pwsh'])])
    def test_info(self, side_effect, expected_version, call_args, shell, Popen):
        Popen.return_value.stdout.read.side_effect = side_effect
        assert shell.info() == expected_version
        assert Popen.call_count == len(call_args)
        assert all([Popen.call_args_list[i][0][0][0] == call_arg for i, call_arg in enumerate(call_args)])

    def test_get_version_error(self, shell, Popen):
        Popen.return_value.stdout.read.side_effect = RuntimeError
        with pytest.raises(RuntimeError):
            shell._get_version()
        assert Popen.call_args[0][0] == ['powershell.exe', '$PSVersionTable.PSVersion']<EOS>"
"<BOS># -*- coding: utf-8 -*-

import os
import pytest
from thefuck.shells import Bash


@pytest.mark.usefixtures('isfile', 'no_memoize', 'no_cache')
class TestBash(object):
    @pytest.fixture
    def shell(self):
        return Bash()

    @pytest.fixture(autouse=True)
    def Popen(self, mocker):
        mock = mocker.patch('thefuck.shells.bash.Popen')
        return mock

    @pytest.fixture(autouse=True)
    def shell_aliases(self):
        os.environ['TF_SHELL_ALIASES'] = (
            'alias fuck=\'eval $(thefuck $(fc -ln -1))\'\n'
            'alias l=\'ls -CF\'\n'
            'alias la=\'ls -A\'\n'
            'alias ll=\'ls -alF\'')

    @pytest.mark.parametrize('before, after', [
        ('pwd', 'pwd'),
        ('fuck', 'eval $(thefuck $(fc -ln -1))'),
        ('awk', 'awk'),
        ('ll', 'ls -alF')])
    def test_from_shell(self, before, after, shell):
        assert shell.from_shell(before) == after

    def test_to_shell(self, shell):
        assert shell.to_shell('pwd') == 'pwd'

    def test_and_(self, shell):
        assert shell.and_('ls', 'cd') == 'ls && cd'

    def test_or_(self, shell):
        assert shell.or_('ls', 'cd') == 'ls || cd'

    def test_get_aliases(self, shell):
        assert shell.get_aliases() == {'fuck': 'eval $(thefuck $(fc -ln -1))',
                                       'l': 'ls -CF',
                                       'la': 'ls -A',
                                       'll': 'ls -alF'}

    def test_app_alias(self, shell):
        assert 'fuck () {' in shell.app_alias('fuck')
        assert 'FUCK () {' in shell.app_alias('FUCK')
        assert 'thefuck' in shell.app_alias('fuck')
        assert 'PYTHONIOENCODING' in shell.app_alias('fuck')

    def test_app_alias_variables_correctly_set(self, shell):
        alias = shell.app_alias('fuck')
        assert ""fuck () {"" in alias
        assert 'TF_SHELL=bash' in alias
        assert ""TF_ALIAS=fuck"" in alias
        assert 'PYTHONIOENCODING=utf-8' in alias
        assert 'TF_SHELL_ALIASES=$(alias)' in alias

    def test_get_history(self, history_lines, shell):
        history_lines(['ls', 'rm'])
        assert list(shell.get_history()) == ['ls', 'rm']

    def test_split_command(self, shell):
        command = 'git log -p'
        command_parts = ['git', 'log', '-p']
        assert shell.split_command(command) == command_parts

    def test_how_to_configure(self, shell, config_exists):
        config_exists.return_value = True
        assert shell.how_to_configure().can_configure_automatically

    def test_how_to_configure_when_config_not_found(self, shell,
                                                    config_exists):
        config_exists.return_value = False
        assert not shell.how_to_configure().can_configure_automatically

    def test_info(self, shell, Popen):
        Popen.return_value.stdout.read.side_effect = [b'3.5.9']
        assert shell.info() == 'Bash 3.5.9'

    def test_get_version_error(self, shell, Popen):
        Popen.return_value.stdout.read.side_effect = OSError
        with pytest.raises(OSError):
            shell._get_version()
        assert Popen.call_args[0][0] == ['bash', '-c', 'echo $BASH_VERSION']<EOS>"
"<BOS># -*- coding: utf-8 -*-

import pytest
from thefuck.shells import Generic


class TestGeneric(object):
    @pytest.fixture
    def shell(self):
        return Generic()

    def test_from_shell(self, shell):
        assert shell.from_shell('pwd') == 'pwd'

    def test_to_shell(self, shell):
        assert shell.to_shell('pwd') == 'pwd'

    def test_and_(self, shell):
        assert shell.and_('ls', 'cd') == 'ls && cd'

    def test_or_(self, shell):
        assert shell.or_('ls', 'cd') == 'ls || cd'

    def test_get_aliases(self, shell):
        assert shell.get_aliases() == {}

    def test_app_alias(self, shell):
        assert 'alias fuck' in shell.app_alias('fuck')
        assert 'alias FUCK' in shell.app_alias('FUCK')
        assert 'thefuck' in shell.app_alias('fuck')
        assert 'TF_ALIAS=fuck PYTHONIOENCODING' in shell.app_alias('fuck')
        assert 'PYTHONIOENCODING=utf-8 thefuck' in shell.app_alias('fuck')

    def test_get_history(self, history_lines, shell):
        history_lines(['ls', 'rm'])
        # We don't know what to do in generic shell with history lines,
        # so just ignore them:
        assert list(shell.get_history()) == []

    def test_split_command(self, shell):
        assert shell.split_command('ls') == ['ls']
        assert shell.split_command(u'echo café') == [u'echo', u'café']

    def test_how_to_configure(self, shell):
        assert shell.how_to_configure() is None

    @pytest.mark.parametrize('side_effect, expected_info, warn', [
        ([u'3.5.9'], u'Generic Shell 3.5.9', False),
        ([OSError], u'Generic Shell', True),
    ])
    def test_info(self, side_effect, expected_info, warn, shell, mocker):
        warn_mock = mocker.patch('thefuck.shells.generic.warn')
        shell._get_version = mocker.Mock(side_effect=side_effect)
        assert shell.info() == expected_info
        assert warn_mock.called is warn
        assert shell._get_version.called<EOS>"
"<BOS># -*- coding: utf-8 -*-

import pytest
from thefuck.const import ARGUMENT_PLACEHOLDER
from thefuck.shells import Fish


@pytest.mark.usefixtures('isfile', 'no_memoize', 'no_cache')
class TestFish(object):
    @pytest.fixture
    def shell(self):
        return Fish()

    @pytest.fixture(autouse=True)
    def Popen(self, mocker):
        mock = mocker.patch('thefuck.shells.fish.Popen')
        mock.return_value.stdout.read.side_effect = [(
            b'cd\nfish_config\nfuck\nfunced\nfuncsave\ngrep\nhistory\nll\nls\n'
            b'man\nmath\npopd\npushd\nruby'),
            (b'alias fish_key_reader /usr/bin/fish_key_reader\nalias g git\n'
             b'alias alias_with_equal_sign=echo\ninvalid_alias'), b'func1\nfunc2', b'']
        return mock

    @pytest.mark.parametrize('key, value', [
        ('TF_OVERRIDDEN_ALIASES', 'cut,git,sed'),  # legacy
        ('THEFUCK_OVERRIDDEN_ALIASES', 'cut,git,sed'),
        ('THEFUCK_OVERRIDDEN_ALIASES', 'cut, git, sed'),
        ('THEFUCK_OVERRIDDEN_ALIASES', ' cut,\tgit,sed\n'),
        ('THEFUCK_OVERRIDDEN_ALIASES', '\ncut,\n\ngit,\tsed\r')])
    def test_get_overridden_aliases(self, shell, os_environ, key, value):
        os_environ[key] = value
        overridden = shell._get_overridden_aliases()
        assert set(overridden) == {'cd', 'cut', 'git', 'grep',
                                   'ls', 'man', 'open', 'sed'}

    @pytest.mark.parametrize('before, after', [
        ('cd', 'cd'),
        ('pwd', 'pwd'),
        ('fuck', 'fish -ic ""fuck""'),
        ('find', 'find'),
        ('funced', 'fish -ic ""funced""'),
        ('grep', 'grep'),
        ('awk', 'awk'),
        ('math ""2 + 2""', r'fish -ic ""math \""2 + 2\""""'),
        ('man', 'man'),
        ('open', 'open'),
        ('vim', 'vim'),
        ('ll', 'fish -ic ""ll""'),
        ('ls', 'ls'),
        ('g', 'git')])
    def test_from_shell(self, before, after, shell):
        assert shell.from_shell(before) == after

    def test_to_shell(self, shell):
        assert shell.to_shell('pwd') == 'pwd'

    def test_and_(self, shell):
        assert shell.and_('foo', 'bar') == 'foo; and bar'

    def test_or_(self, shell):
        assert shell.or_('foo', 'bar') == 'foo; or bar'

    def test_get_aliases(self, shell):
        assert shell.get_aliases() == {'fish_config': 'fish_config',
                                       'fuck': 'fuck',
                                       'funced': 'funced',
                                       'funcsave': 'funcsave',
                                       'history': 'history',
                                       'll': 'll',
                                       'math': 'math',
                                       'popd': 'popd',
                                       'pushd': 'pushd',
                                       'ruby': 'ruby',
                                       'g': 'git',
                                       'fish_key_reader': '/usr/bin/fish_key_reader',
                                       'alias_with_equal_sign': 'echo'}
        assert shell.get_aliases() == {'func1': 'func1', 'func2': 'func2'}

    def test_app_alias(self, shell):
        assert 'function fuck' in shell.app_alias('fuck')
        assert 'function FUCK' in shell.app_alias('FUCK')
        assert 'thefuck' in shell.app_alias('fuck')
        assert 'TF_SHELL=fish' in shell.app_alias('fuck')
        assert 'TF_ALIAS=fuck PYTHONIOENCODING' in shell.app_alias('fuck')
        assert 'PYTHONIOENCODING=utf-8 thefuck' in shell.app_alias('fuck')
        assert ARGUMENT_PLACEHOLDER in shell.app_alias('fuck')

    def test_app_alias_alter_history(self, settings, shell):
        settings.alter_history = True
        assert (
            'builtin history delete --exact --case-sensitive -- $fucked_up_command\n'
            in shell.app_alias('FUCK')
        )
        assert 'builtin history merge\n' in shell.app_alias('FUCK')
        settings.alter_history = False
        assert 'builtin history delete' not in shell.app_alias('FUCK')
        assert 'builtin history merge' not in shell.app_alias('FUCK')

    def test_get_history(self, history_lines, shell):
        history_lines(['- cmd: ls', '  when: 1432613911',
                       '- cmd: rm', '  when: 1432613916'])
        assert list(shell.get_history()) == ['ls', 'rm']

    @pytest.mark.parametrize('entry, entry_utf8', [
        ('ls', '- cmd: ls\n   when: 1430707243\n'),
        (u'echo café', '- cmd: echo café\n   when: 1430707243\n')])
    def test_put_to_history(self, entry, entry_utf8, builtins_open, mocker, shell):
        mocker.patch('thefuck.shells.fish.time', return_value=1430707243.3517463)
        shell.put_to_history(entry)
        builtins_open.return_value.__enter__.return_value. \
            write.assert_called_once_with(entry_utf8)

    def test_how_to_configure(self, shell, config_exists):
        config_exists.return_value = True
        assert shell.how_to_configure().can_configure_automatically

    def test_how_to_configure_when_config_not_found(self, shell,
                                                    config_exists):
        config_exists.return_value = False
        assert not shell.how_to_configure().can_configure_automatically

    def test_get_version(self, shell, Popen):
        Popen.return_value.stdout.read.side_effect = [b'fish, version 3.5.9\n']
        assert shell._get_version() == '3.5.9'
        assert Popen.call_args[0][0] == ['fish', '--version']

    @pytest.mark.parametrize('side_effect, exception', [
        ([b'\n'], IndexError),
        (OSError('file not found'), OSError),
    ])
    def test_get_version_error(self, side_effect, exception, shell, Popen):
        Popen.return_value.stdout.read.side_effect = side_effect
        with pytest.raises(exception):
            shell._get_version()
        assert Popen.call_args[0][0] == ['fish', '--version']<EOS>"
"<BOS>import pytest
from thefuck.rules.django_south_ghost import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''Traceback (most recent call last):
  File ""/home/nvbn/work/.../bin/python"", line 42, in <module>
    exec(compile(__file__f.read(), __file__, ""exec""))
  File ""/home/nvbn/work/.../app/manage.py"", line 34, in <module>
    execute_from_command_line(sys.argv)
  File ""/home/nvbn/work/.../lib/django/core/management/__init__.py"", line 443, in execute_from_command_line
    utility.execute()
  File ""/home/nvbn/work/.../lib/django/core/management/__init__.py"", line 382, in execute
    self.fetch_command(subcommand).run_from_argv(self.argv)
  File ""/home/nvbn/work/.../lib/django/core/management/base.py"", line 196, in run_from_argv
    self.execute(*args, **options.__dict__)
  File ""/home/nvbn/work/.../lib/django/core/management/base.py"", line 232, in execute
    output = self.handle(*args, **options)
  File ""/home/nvbn/work/.../app/lib/south/management/commands/migrate.py"", line 108, in handle
    ignore_ghosts = ignore_ghosts,
  File ""/home/nvbn/work/.../app/lib/south/migration/__init__.py"", line 193, in migrate_app
    applied_all = check_migration_histories(applied_all, delete_ghosts, ignore_ghosts)
  File ""/home/nvbn/work/.../app/lib/south/migration/__init__.py"", line 88, in check_migration_histories
    raise exceptions.GhostMigrations(ghosts)
south.exceptions.GhostMigrations: 

 ! These migrations are in the database but not on disk:
    <app1: 0033_auto__...>
    <app1: 0034_fill_...>
    <app1: 0035_rename_...>
    <app2: 0003_add_...>
    <app2: 0004_denormalize_...>
    <app1: 0033_auto....>
    <app1: 0034_fill...>
 ! I'm not trusting myself; either fix this yourself by fiddling
 ! with the south_migrationhistory table, or pass --delete-ghost-migrations
 ! to South to have it delete ALL of these records (this may not be good).
'''  # noqa


def test_match(output):
    assert match(Command('./manage.py migrate', output))
    assert match(Command('python manage.py migrate', output))
    assert not match(Command('./manage.py migrate', ''))
    assert not match(Command('app migrate', output))
    assert not match(Command('./manage.py test', output))


def test_get_new_command():
    assert get_new_command(Command('./manage.py migrate auth', ''))\
        == './manage.py migrate auth --delete-ghost-migrations'<EOS>"
"<BOS>import pytest
from thefuck.rules.git_commit_reset import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('script, output', [
    ('git commit -m ""test""', 'test output'),
    ('git commit', '')])
def test_match(output, script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', [
    'git branch foo',
    'git checkout feature/test_commit',
    'git push'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script', [
    ('git commit -m ""test commit""'),
    ('git commit')])
def test_get_new_command(script):
    assert get_new_command(Command(script, '')) == 'git reset HEAD~'<EOS>"
"<BOS>import pytest
from thefuck.rules.git_two_dashes import match, get_new_command
from thefuck.types import Command


output = 'error: did you mean `{}` (with two dashes ?)'.format


@pytest.mark.parametrize('command', [
    Command('git add -patch', output('--patch')),
    Command('git checkout -patch', output('--patch')),
    Command('git commit -amend', output('--amend')),
    Command('git push -tags', output('--tags')),
    Command('git rebase -continue', output('--continue'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git add --patch', ''),
    Command('git checkout --patch', ''),
    Command('git commit --amend', ''),
    Command('git push --tags', ''),
    Command('git rebase --continue', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, output', [
    (Command('git add -patch', output('--patch')),
        'git add --patch'),
    (Command('git checkout -patch', output('--patch')),
        'git checkout --patch'),
    (Command('git checkout -patch', output('--patch')),
        'git checkout --patch'),
    (Command('git init -bare', output('--bare')),
        'git init --bare'),
    (Command('git commit -amend', output('--amend')),
        'git commit --amend'),
    (Command('git push -tags', output('--tags')),
        'git push --tags'),
    (Command('git rebase -continue', output('--continue')),
        'git rebase --continue')])
def test_get_new_command(command, output):
    assert get_new_command(command) == output<EOS>"
"<BOS>import pytest
from thefuck.rules.vagrant_up import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('vagrant ssh', 'VM must be running to open SSH connection. Run `vagrant up`\nto start the virtual machine.'),
    Command('vagrant ssh devbox', 'VM must be running to open SSH connection. Run `vagrant up`\nto start the virtual machine.'),
    Command('vagrant rdp',
            'VM must be created before running this command. Run `vagrant up` first.'),
    Command('vagrant rdp devbox',
            'VM must be created before running this command. Run `vagrant up` first.')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('vagrant ssh', ''),
    Command('vagrant ssh jeff', 'The machine with the name \'jeff\' was not found configured for this Vagrant environment.'),
    Command('vagrant ssh', 'A Vagrant environment or target machine is required to run this command. Run `vagrant init` to create a new Vagrant environment. Or, get an ID of a target machine from `vagrant global-status` to run this command on. A final option is to change to a directory with a Vagrantfile and to try again.'),
    Command('', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('vagrant ssh', 'VM must be running to open SSH connection. Run `vagrant up`\nto start the virtual machine.'), 'vagrant up && vagrant ssh'),
    (Command('vagrant ssh devbox', 'VM must be running to open SSH connection. Run `vagrant up`\nto start the virtual machine.'), ['vagrant up devbox && vagrant ssh devbox', 'vagrant up && vagrant ssh devbox']),
    (Command('vagrant rdp',
             'VM must be created before running this command. Run `vagrant up` first.'), 'vagrant up && vagrant rdp'),
    (Command('vagrant rdp devbox',
             'VM must be created before running this command. Run `vagrant up` first.'), ['vagrant up devbox && vagrant rdp devbox', 'vagrant up && vagrant rdp devbox'])])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.git_diff_staged import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('git diff foo', ''),
    Command('git diff', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git diff --staged', ''),
    Command('git tag', ''),
    Command('git branch', ''),
    Command('git log', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('git diff', ''), 'git diff --staged'),
    (Command('git diff foo', ''), 'git diff --staged foo')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.grep_arguments_order import get_new_command, match
from thefuck.types import Command

output = 'grep: {}: No such file or directory'.format


@pytest.fixture(autouse=True)
def os_path(monkeypatch):
    monkeypatch.setattr('os.path.isfile', lambda x: not x.startswith('-'))


@pytest.mark.parametrize('script, file', [
    ('grep test.py test', 'test'),
    ('grep -lir . test', 'test'),
    ('egrep test.py test', 'test'),
    ('egrep -lir . test', 'test')])
def test_match(script, file):
    assert match(Command(script, output(file)))


@pytest.mark.parametrize('script, output', [
    ('cat test.py', output('test')),
    ('grep test test.py', ''),
    ('grep -lir test .', ''),
    ('egrep test test.py', ''),
    ('egrep -lir test .', '')])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, output, result', [
    ('grep test.py test', output('test'), 'grep test test.py'),
    ('grep -lir . test', output('test'), 'grep -lir test .'),
    ('grep . test -lir', output('test'), 'grep test -lir .'),
    ('egrep test.py test', output('test'), 'egrep test test.py'),
    ('egrep -lir . test', output('test'), 'egrep -lir test .'),
    ('egrep . test -lir', output('test'), 'egrep test -lir .')])
def test_get_new_command(script, output, result):
    assert get_new_command(Command(script, output)) == result<EOS>"
"<BOS># -*- coding: utf-8 -*-

import pytest
from thefuck.types import Command
from thefuck.rules.heroku_multiple_apps import match, get_new_command


suggest_output = '''
 ▸    Multiple apps in git remotes
 ▸    Usage: --remote heroku-dev
 ▸    or: --app myapp-dev
 ▸    Your local git repository has more than 1 app referenced in git remotes.
 ▸    Because of this, we can't determine which app you want to run this command against.
 ▸    Specify the app you want with --app or --remote.
 ▸    Heroku remotes in repo:
 ▸    myapp (heroku)
 ▸    myapp-dev (heroku-dev)
 ▸
 ▸    https://devcenter.heroku.com/articles/multiple-environments
'''

not_match_output = '''
=== HEROKU_POSTGRESQL_TEAL_URL, DATABASE_URL
Plan:                  Hobby-basic
Status:                Available
Connections:           20/20
PG Version:            9.6.4
Created:               2017-01-01 00:00 UTC
Data Size:             99.9 MB
Tables:                99
Rows:                  12345/10000000 (In compliance)
Fork/Follow:           Unsupported
Rollback:              Unsupported
Continuous Protection: Off
Add-on:                postgresql-round-12345
'''


@pytest.mark.parametrize('cmd', ['pg'])
def test_match(cmd):
    assert match(
        Command('heroku {}'.format(cmd), suggest_output))


@pytest.mark.parametrize('script, output', [
    ('heroku pg', not_match_output)])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('cmd, result', [
    ('pg', ['heroku pg --app myapp', 'heroku pg --app myapp-dev'])])
def test_get_new_command(cmd, result):
    command = Command('heroku {}'.format(cmd), suggest_output)
    assert get_new_command(command) == result<EOS>"
"<BOS>import pytest
from thefuck.rules.mvn_unknown_lifecycle_phase import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('mvn cle', '[ERROR] Unknown lifecycle phase ""cle"". You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('mvn clean', """"""
[INFO] Scanning for projects...[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building test 0.2
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ test ---
[INFO] Deleting /home/mlk/code/test/target
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 0.477s
[INFO] Finished at: Wed Aug 26 13:05:47 BST 2015
[INFO] Final Memory: 6M/240M
[INFO] ------------------------------------------------------------------------
""""""),  # noqa
    Command('mvn --help', ''),
    Command('mvn -v', '')
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('mvn cle', '[ERROR] Unknown lifecycle phase ""cle"". You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]'), ['mvn clean', 'mvn compile']),
    (Command('mvn claen package', '[ERROR] Unknown lifecycle phase ""claen"". You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]'), ['mvn clean package'])])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.path_from_history import match, get_new_command
from thefuck.types import Command


@pytest.fixture(autouse=True)
def history(mocker):
    return mocker.patch(
        'thefuck.rules.path_from_history.get_valid_history_without_current',
        return_value=['cd /opt/java', 'ls ~/work/project/'])


@pytest.fixture(autouse=True)
def path_exists(mocker):
    path_mock = mocker.patch('thefuck.rules.path_from_history.Path')
    exists_mock = path_mock.return_value.expanduser.return_value.exists
    exists_mock.return_value = True
    return exists_mock


@pytest.mark.parametrize('script, output', [
    ('ls project', 'no such file or directory: project'),
    ('cd project', ""can't cd to project""),
])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output', [
    ('myapp cats', 'no such file or directory: project'),
    ('cd project', """"),
])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, output, result', [
    ('ls project', 'no such file or directory: project', 'ls ~/work/project'),
    ('cd java', ""can't cd to java"", 'cd /opt/java'),
])
def test_get_new_command(script, output, result):
    new_command = get_new_command(Command(script, output))
    assert new_command[0] == result<EOS>"
"<BOS>import pytest
from thefuck.rules.apt_upgrade import get_new_command, match
from thefuck.types import Command

match_output = '''
Listing... Done
heroku/stable 6.15.2-1 amd64 [upgradable from: 6.14.43-1]
resolvconf/zesty-updates,zesty-updates 1.79ubuntu4.1 all [upgradable from: 1.79ubuntu4]
squashfs-tools/zesty-updates 1:4.3-3ubuntu2.17.04.1 amd64 [upgradable from: 1:4.3-3ubuntu2]
unattended-upgrades/zesty-updates,zesty-updates 0.93.1ubuntu2.4 all [upgradable from: 0.93.1ubuntu2.3]
'''

no_match_output = '''
Listing... Done
'''


def test_match():
    assert match(Command('apt list --upgradable', match_output))
    assert match(Command('sudo apt list --upgradable', match_output))


@pytest.mark.parametrize('command', [
    Command('apt list --upgradable', no_match_output),
    Command('sudo apt list --upgradable', no_match_output)
])
def test_not_match(command):
    assert not match(command)


def test_get_new_command():
    new_command = get_new_command(Command('apt list --upgradable', match_output))
    assert new_command == 'apt upgrade'

    new_command = get_new_command(Command('sudo apt list --upgradable', match_output))
    assert new_command == 'sudo apt upgrade'<EOS>"
"<BOS>from thefuck.rules.git_branch_list import match, get_new_command
from thefuck.shells import shell
from thefuck.types import Command


def test_match():
    assert match(Command('git branch list', ''))


def test_not_match():
    assert not match(Command('', ''))
    assert not match(Command('git commit', ''))
    assert not match(Command('git branch', ''))
    assert not match(Command('git stash list', ''))


def test_get_new_command():
    assert (get_new_command(Command('git branch list', '')) ==
            shell.and_('git branch --delete list', 'git branch'))<EOS>"
"<BOS>import pytest
from thefuck.rules.git_push_different_branch_names import get_new_command, match
from thefuck.types import Command


output = """"""fatal: The upstream branch of your current branch does not match
the name of your current branch.  To push to the upstream branch
on the remote, use

    git push origin HEAD:%s

To push to the branch of the same name on the remote, use

    git push origin %s

To choose either option permanently, see push.default in 'git help config'.
""""""


def error_msg(localbranch, remotebranch):
    return output % (remotebranch, localbranch)


def test_match():
    assert match(Command('git push', error_msg('foo', 'bar')))


@pytest.mark.parametrize('command', [
    Command('vim', ''),
    Command('git status', error_msg('foo', 'bar')),
    Command('git push', '')
])
def test_not_match(command):
    assert not match(command)


def test_get_new_command():
    new_command = get_new_command(Command('git push', error_msg('foo', 'bar')))
    assert new_command == 'git push origin HEAD:bar'<EOS>"
"<BOS>import pytest
from thefuck.rules.git_remote_delete import get_new_command, match
from thefuck.types import Command


def test_match():
    assert match(Command('git remote delete foo', ''))


@pytest.mark.parametrize('command', [
    Command('git remote remove foo', ''),
    Command('git remote add foo', ''),
    Command('git commit', '')
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('git remote delete foo', ''), 'git remote remove foo'),
    (Command('git remote delete delete', ''), 'git remote remove delete'),
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>from thefuck.rules.ls_all import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('ls', ''))
    assert not match(Command('ls', 'file.py\n'))


def test_get_new_command():
    assert get_new_command(Command('ls empty_dir', '')) == 'ls -A empty_dir'
    assert get_new_command(Command('ls', '')) == 'ls -A'<EOS>"
"<BOS>import pytest
from io import BytesIO
from thefuck.types import Command
from thefuck.rules.npm_missing_script import match, get_new_command

output = '''
npm ERR! Linux 4.4.0-31-generic
npm ERR! argv ""/opt/node/bin/node"" ""/opt/node/bin/npm"" ""run"" ""dvelop""
npm ERR! node v4.4.7
npm ERR! npm  v2.15.8

npm ERR! missing script: {}
npm ERR!
npm ERR! If you need help, you may report this error at:
npm ERR!     <https://github.com/npm/npm/issues>

npm ERR! Please include the following file with any support request:
npm ERR!     /home/nvbn/exp/code_view/client_web/npm-debug.log
'''.format

run_script_stdout = b'''
Lifecycle scripts included in code-view-web:
  test
    jest

available via `npm run-script`:
  build
    cp node_modules/ace-builds/src-min/ -a resources/ace/ && webpack --progress --colors -p --config ./webpack.production.config.js
  develop
    cp node_modules/ace-builds/src/ -a resources/ace/ && webpack-dev-server --progress --colors
  watch-test
    jest --verbose --watch

'''


@pytest.fixture(autouse=True)
def run_script(mocker):
    patch = mocker.patch('thefuck.specific.npm.Popen')
    patch.return_value.stdout = BytesIO(run_script_stdout)
    return patch.return_value


@pytest.mark.parametrize('command', [
    Command('npm ru wach', output('wach')),
    Command('npm run live-tes', output('live-tes')),
    Command('npm run-script sahare', output('sahare'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('npm wach', output('wach')),
    Command('vim live-tes', output('live-tes')),
    Command('npm run-script sahare', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('script, output, result', [
    ('npm ru wach-tests', output('wach-tests'), 'npm ru watch-test'),
    ('npm -i run-script dvelop', output('dvelop'),
     'npm -i run-script develop'),
    ('npm -i run-script buld -X POST', output('buld'),
     'npm -i run-script build -X POST')])
def test_get_new_command(script, output, result):
    command = Command(script, output)

    assert get_new_command(command)[0] == result<EOS>"
"<BOS>import pytest
from thefuck.rules.php_s import get_new_command, match
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('php -s localhost:8000', ''),
    Command('php -t pub -s 0.0.0.0:8080', '')
])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('php -S localhost:8000', ''),
    Command('vim php -s', '')
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('php -s localhost:8000', ''), 'php -S localhost:8000'),
    (Command('php -t pub -s 0.0.0.0:8080', ''), 'php -t pub -S 0.0.0.0:8080')
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.remove_trailing_cedilla import match, get_new_command, CEDILLA
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('wrong' + CEDILLA, ''),
    Command('wrong with args' + CEDILLA, '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('wrong' + CEDILLA, ''), 'wrong'),
    (Command('wrong with args' + CEDILLA, ''), 'wrong with args')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.git_remote_seturl_add import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('git remote set-url origin url', ""fatal: No such remote"")])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git remote set-url origin url', """"),
    Command('git remote add origin url', ''),
    Command('git remote remove origin', ''),
    Command('git remote prune origin', ''),
    Command('git remote set-branches origin branch', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('git remote set-url origin git@github.com:nvbn/thefuck.git', ''),
     'git remote add origin git@github.com:nvbn/thefuck.git')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.java import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('java foo.java', ''),
    Command('java bar.java', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('java foo.java', ''), 'java foo'),
    (Command('java bar.java', ''), 'java bar')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>from thefuck.rules.man_no_space import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('mandiff', 'mandiff: command not found'))
    assert not match(Command('', ''))


def test_get_new_command():
    assert get_new_command(Command('mandiff', '')) == 'man diff'<EOS>"
"<BOS>import pytest
from thefuck.rules.touch import match, get_new_command
from thefuck.types import Command


def output(is_bsd):
    if is_bsd:
        return ""touch: /a/b/c: No such file or directory""
    return ""touch: cannot touch '/a/b/c': No such file or directory""


@pytest.mark.parametrize('script, is_bsd', [
    ('touch /a/b/c', False),
    ('touch /a/b/c', True)])
def test_match(script, is_bsd):
    command = Command(script, output(is_bsd))
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('touch /a/b/c', ''),
    Command('ls /a/b/c', output(False))])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('script, is_bsd', [
    ('touch /a/b/c', False),
    ('touch /a/b/c', True)])
def test_get_new_command(script, is_bsd):
    command = Command(script, output(is_bsd))
    fixed_command = get_new_command(command)
    assert fixed_command == 'mkdir -p /a/b && touch /a/b/c'<EOS>"
"<BOS># -*- coding: utf-8 -*-

import pytest
from thefuck.rules.apt_list_upgradable import get_new_command, match
from thefuck.types import Command

full_english_output = '''
Hit:1 http://us.archive.ubuntu.com/ubuntu zesty InRelease
Hit:2 http://us.archive.ubuntu.com/ubuntu zesty-updates InRelease
Get:3 http://us.archive.ubuntu.com/ubuntu zesty-backports InRelease [89.2 kB]
Hit:4 http://security.ubuntu.com/ubuntu zesty-security InRelease
Hit:5 http://ppa.launchpad.net/ubuntu-mozilla-daily/ppa/ubuntu zesty InRelease
Hit:6 https://download.docker.com/linux/ubuntu zesty InRelease
Hit:7 https://cli-assets.heroku.com/branches/stable/apt ./ InRelease
Fetched 89.2 kB in 0s (122 kB/s)
Reading package lists... Done
Building dependency tree
Reading state information... Done
8 packages can be upgraded. Run 'apt list --upgradable' to see them.
'''

match_output = [
    full_english_output,
    'Führen Sie »apt list --upgradable« aus, um sie anzuzeigen.'  # German
]

no_match_output = '''
Hit:1 http://us.archive.ubuntu.com/ubuntu zesty InRelease
Get:2 http://us.archive.ubuntu.com/ubuntu zesty-updates InRelease [89.2 kB]
Get:3 http://us.archive.ubuntu.com/ubuntu zesty-backports InRelease [89.2 kB]
Get:4 http://security.ubuntu.com/ubuntu zesty-security InRelease [89.2 kB]
Hit:5 https://cli-assets.heroku.com/branches/stable/apt ./ InRelease
Hit:6 http://ppa.launchpad.net/ubuntu-mozilla-daily/ppa/ubuntu zesty InRelease
Hit:7 https://download.docker.com/linux/ubuntu zesty InRelease
Get:8 http://us.archive.ubuntu.com/ubuntu zesty-updates/main i386 Packages [232 kB]
Get:9 http://us.archive.ubuntu.com/ubuntu zesty-updates/main amd64 Packages [235 kB]
Get:10 http://us.archive.ubuntu.com/ubuntu zesty-updates/main amd64 DEP-11 Metadata [55.2 kB]
Get:11 http://us.archive.ubuntu.com/ubuntu zesty-updates/main DEP-11 64x64 Icons [32.3 kB]
Get:12 http://us.archive.ubuntu.com/ubuntu zesty-updates/universe amd64 Packages [156 kB]
Get:13 http://us.archive.ubuntu.com/ubuntu zesty-updates/universe i386 Packages [156 kB]
Get:14 http://us.archive.ubuntu.com/ubuntu zesty-updates/universe amd64 DEP-11 Metadata [175 kB]
Get:15 http://us.archive.ubuntu.com/ubuntu zesty-updates/universe DEP-11 64x64 Icons [253 kB]
Get:16 http://us.archive.ubuntu.com/ubuntu zesty-updates/multiverse amd64 DEP-11 Metadata [5,840 B]
Get:17 http://us.archive.ubuntu.com/ubuntu zesty-backports/universe amd64 DEP-11 Metadata [4,588 B]
Get:18 http://security.ubuntu.com/ubuntu zesty-security/main amd64 DEP-11 Metadata [12.7 kB]
Get:19 http://security.ubuntu.com/ubuntu zesty-security/main DEP-11 64x64 Icons [17.6 kB]
Get:20 http://security.ubuntu.com/ubuntu zesty-security/universe amd64 DEP-11 Metadata [21.6 kB]
Get:21 http://security.ubuntu.com/ubuntu zesty-security/universe DEP-11 64x64 Icons [47.7 kB]
Get:22 http://security.ubuntu.com/ubuntu zesty-security/multiverse amd64 DEP-11 Metadata [208 B]
Fetched 1,673 kB in 0s (1,716 kB/s)
Reading package lists... Done
Building dependency tree
Reading state information... Done
All packages are up to date.
'''


@pytest.mark.parametrize('output', match_output)
def test_match(output):
    assert match(Command('sudo apt update', output))


@pytest.mark.parametrize('command', [
    Command('apt-cache search foo', ''),
    Command('aptitude search foo', ''),
    Command('apt search foo', ''),
    Command('apt-get install foo', ''),
    Command('apt-get source foo', ''),
    Command('apt-get clean', ''),
    Command('apt-get remove', ''),
    Command('apt-get update', ''),
    Command('sudo apt update', no_match_output)
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('output', match_output)
def test_get_new_command(output):
    new_command = get_new_command(Command('sudo apt update', output))
    assert new_command == 'sudo apt list --upgradable'

    new_command = get_new_command(Command('apt update', output))
    assert new_command == 'apt list --upgradable'<EOS>"
"<BOS>import pytest
from thefuck.rules.cd_correction import match
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('cd foo', 'cd: foo: No such file or directory'),
    Command('cd foo/bar/baz',
            'cd: foo: No such file or directory'),
    Command('cd foo/bar/baz', 'cd: can\'t cd to foo/bar/baz'),
    Command('cd /foo/bar/', 'cd: The directory ""/foo/bar/"" does not exist')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('cd foo', ''), Command('', '')])
def test_not_match(command):
    assert not match(command)


# Note that get_new_command uses local filesystem, so not testing it here.
# Instead, see the functional test `functional.test_cd_correction`<EOS>"
"<BOS>import pytest
from thefuck.rules.dry import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('cd cd foo', ''),
    Command('git git push origin/master', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('cd cd foo', ''), 'cd foo'),
    (Command('git git push origin/master', ''), 'git push origin/master')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.git_add_force import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return ('The following paths are ignored by one of your .gitignore files:\n'
            'dist/app.js\n'
            'dist/background.js\n'
            'dist/options.js\n'
            'Use -f if you really want to add them.\n')


def test_match(output):
    assert match(Command('git add dist/*.js', output))
    assert not match(Command('git add dist/*.js', ''))


def test_get_new_command(output):
    assert (get_new_command(Command('git add dist/*.js', output))
            == ""git add --force dist/*.js"")<EOS>"
"<BOS>from thefuck.rules.git_clone_git_clone import match, get_new_command
from thefuck.types import Command


output_clean = """"""
fatal: Too many arguments.

usage: git clone [<options>] [--] <repo> [<dir>]
""""""


def test_match():
    assert match(Command('git clone git clone foo', output_clean))


def test_not_match():
    assert not match(Command('', ''))
    assert not match(Command('git branch', ''))
    assert not match(Command('git clone foo', ''))
    assert not match(Command('git clone foo bar baz', output_clean))


def test_get_new_command():
    assert get_new_command(Command('git clone git clone foo', output_clean)) == 'git clone foo'<EOS>"
"<BOS>import pytest
from thefuck.rules.git_push_pull import match, get_new_command
from thefuck.types import Command


git_err = '''
To /tmp/foo
 ! [rejected]        master -> master (non-fast-forward)
 error: failed to push some refs to '/tmp/bar'
 hint: Updates were rejected because the tip of your current branch is behind
 hint: its remote counterpart. Integrate the remote changes (e.g.
 hint: 'git pull ...') before pushing again.
 hint: See the 'Note about fast-forwards' in 'git push --help' for details.
'''

git_err2 = '''
To /tmp/foo
 ! [rejected]        master -> master (non-fast-forward)
 error: failed to push some refs to '/tmp/bar'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
'''

git_uptodate = 'Everything up-to-date'
git_ok = '''
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 282 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To /tmp/bar
   514eed3..f269c79  master -> master
'''


@pytest.mark.parametrize('command', [
    Command('git push', git_err),
    Command('git push nvbn', git_err),
    Command('git push nvbn master', git_err),
    Command('git push', git_err2),
    Command('git push nvbn', git_err2),
    Command('git push nvbn master', git_err2)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git push', git_ok),
    Command('git push', git_uptodate),
    Command('git push nvbn', git_ok),
    Command('git push nvbn master', git_uptodate),
    Command('git push nvbn', git_ok),
    Command('git push nvbn master', git_uptodate)])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, output', [
    (Command('git push', git_err), 'git pull && git push'),
    (Command('git push nvbn', git_err),
     'git pull nvbn && git push nvbn'),
    (Command('git push nvbn master', git_err),
     'git pull nvbn master && git push nvbn master'),
    (Command('git push', git_err2), 'git pull && git push'),
    (Command('git push nvbn', git_err2),
     'git pull nvbn && git push nvbn'),
    (Command('git push nvbn master', git_err2),
     'git pull nvbn master && git push nvbn master')])
def test_get_new_command(command, output):
    assert get_new_command(command) == output<EOS>"
"<BOS>from thefuck.types import Command
from thefuck.rules.git_push_without_commits import get_new_command, match


def test_match():
    script = ""git push -u origin master""
    output = ""error: src refspec master does not match any\nerror: failed to...""
    assert match(Command(script, output))


def test_not_match():
    script = ""git push -u origin master""
    assert not match(Command(script, ""Everything up-to-date""))


def test_get_new_command():
    script = ""git push -u origin master""
    output = ""error: src refspec master does not match any\nerror: failed to...""
    new_command = 'git commit -m ""Initial commit"" && git push -u origin master'
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.git_stash_pop import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''error: Your local changes to the following files would be overwritten by merge:'''


def test_match(output):
    assert match(Command('git stash pop', output))
    assert not match(Command('git stash', ''))


def test_get_new_command(output):
    assert (get_new_command(Command('git stash pop', output))
            == ""git add --update && git stash pop && git reset ."")<EOS>"
"<BOS>import pytest
from thefuck.rules.npm_wrong_command import match, get_new_command
from thefuck.types import Command

output = '''
Usage: npm <command>

where <command> is one of:
    access, add-user, adduser, apihelp, author, bin, bugs, c,
    cache, completion, config, ddp, dedupe, deprecate, dist-tag,
    dist-tags, docs, edit, explore, faq, find, find-dupes, get,
    help, help-search, home, i, info, init, install, issues, la,
    link, list, ll, ln, login, logout, ls, outdated, owner,
    pack, ping, prefix, prune, publish, r, rb, rebuild, remove,
    repo, restart, rm, root, run-script, s, se, search, set,
    show, shrinkwrap, star, stars, start, stop, t, tag, team,
    test, tst, un, uninstall, unlink, unpublish, unstar, up,
    update, upgrade, v, verison, version, view, whoami

npm <cmd> -h     quick help on <cmd>
npm -l           display full usage info
npm faq          commonly asked questions
npm help <term>  search for help on <term>
npm help npm     involved overview

Specify configs in the ini-formatted file:
    /home/nvbn/.npmrc
or on the command line via: npm <command> --key value
Config info can be viewed via: npm help config

npm@2.14.7 /opt/node/lib/node_modules/npm
'''


@pytest.mark.parametrize('script', [
    'npm urgrdae',
    'npm urgrade -g',
    'npm -f urgrade -g',
    'npm urg'])
def test_match(script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output', [
    ('npm urgrade', ''),
    ('npm', output),
    ('test urgrade', output),
    ('npm -e', output)])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, result', [
    ('npm urgrade', 'npm upgrade'),
    ('npm -g isntall gulp', 'npm -g install gulp'),
    ('npm isntall -g gulp', 'npm install -g gulp')])
def test_get_new_command(script, result):
    assert get_new_command(Command(script, output)) == result<EOS>"
"<BOS>import pytest
from thefuck.rules.whois import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('whois https://en.wikipedia.org/wiki/Main_Page', ''),
    Command('whois https://en.wikipedia.org/', ''),
    Command('whois meta.unix.stackexchange.com', '')])
def test_match(command):
    assert match(command)


def test_not_match():
    assert not match(Command('whois', ''))


# `whois com` actually makes sense
@pytest.mark.parametrize('command, new_command', [
    (Command('whois https://en.wikipedia.org/wiki/Main_Page', ''),
     'whois en.wikipedia.org'),
    (Command('whois https://en.wikipedia.org/', ''),
     'whois en.wikipedia.org'),
    (Command('whois meta.unix.stackexchange.com', ''),
     ['whois unix.stackexchange.com',
      'whois stackexchange.com',
      'whois com'])])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest

from thefuck.rules.wrong_hyphen_before_subcommand import match, get_new_command
from thefuck.types import Command


@pytest.fixture(autouse=True)
def get_all_executables(mocker):
    mocker.patch(
        ""thefuck.rules.wrong_hyphen_before_subcommand.get_all_executables"",
        return_value=[""git"", ""apt"", ""apt-get"", ""ls"", ""pwd""],
    )


@pytest.mark.parametrize(""script"", [""git-log"", ""apt-install python""])
def test_match(script):
    assert match(Command(script, """"))


@pytest.mark.parametrize(""script"", [""ls -la"", ""git2-make"", ""apt-get install python""])
def test_not_match(script):
    assert not match(Command(script, """"))


@pytest.mark.parametrize(
    ""script, new_command"",
    [(""git-log"", ""git log""), (""apt-install python"", ""apt install python"")],
)
def test_get_new_command(script, new_command):
    assert get_new_command(Command(script, """")) == new_command<EOS>"
"<BOS>from thefuck.rules.docker_login import match, get_new_command
from thefuck.types import Command


def test_match():
    err_response1 = """"""
    Sending build context to Docker daemon  118.8kB
Step 1/6 : FROM foo/bar:fdb7c6d
pull access denied for foo/bar, repository does not exist or may require 'docker login'
""""""
    assert match(Command('docker build -t artifactory:9090/foo/bar:fdb7c6d .', err_response1))

    err_response2 = """"""
    The push refers to repository [artifactory:9090/foo/bar]
push access denied for foo/bar, repository does not exist or may require 'docker login'
""""""
    assert match(Command('docker push artifactory:9090/foo/bar:fdb7c6d', err_response2))

    err_response3 = """"""
    docker push artifactory:9090/foo/bar:fdb7c6d
The push refers to repository [artifactory:9090/foo/bar]
9c29c7ad209d: Preparing
71f3ad53dfe0: Preparing
f58ee068224c: Preparing
aeddc924d0f7: Preparing
c2040e5d6363: Preparing
4d42df4f350f: Preparing
35723dab26f9: Preparing
71f3ad53dfe0: Pushed
cb95fa0faeb1: Layer already exists
""""""
    assert not match(Command('docker push artifactory:9090/foo/bar:fdb7c6d', err_response3))


def test_get_new_command():
    assert get_new_command(Command('docker build -t artifactory:9090/foo/bar:fdb7c6d .', '')) == 'docker login && docker build -t artifactory:9090/foo/bar:fdb7c6d .'
    assert get_new_command(Command('docker push artifactory:9090/foo/bar:fdb7c6d', '')) == 'docker login && docker push artifactory:9090/foo/bar:fdb7c6d'<EOS>"
"<BOS>import pytest
from thefuck.rules.git_branch_delete import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''error: The branch 'branch' is not fully merged.
If you are sure you want to delete it, run 'git branch -D branch'.

'''


def test_match(output):
    assert match(Command('git branch -d branch', output))
    assert not match(Command('git branch -d branch', ''))
    assert not match(Command('ls', output))


def test_get_new_command(output):
    assert get_new_command(Command('git branch -d branch', output))\
        == ""git branch -D branch""<EOS>"
"<BOS>import pytest
from thefuck.rules.git_push_force import match, get_new_command
from thefuck.types import Command


git_err = '''
To /tmp/foo
 ! [rejected]        master -> master (non-fast-forward)
 error: failed to push some refs to '/tmp/bar'
 hint: Updates were rejected because the tip of your current branch is behind
 hint: its remote counterpart. Integrate the remote changes (e.g.
 hint: 'git pull ...') before pushing again.
 hint: See the 'Note about fast-forwards' in 'git push --help' for details.
'''

git_uptodate = 'Everything up-to-date'
git_ok = '''
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 282 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To /tmp/bar
   514eed3..f269c79  master -> master
'''


@pytest.mark.parametrize('command', [
    Command('git push', git_err),
    Command('git push nvbn', git_err),
    Command('git push nvbn master', git_err)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git push', git_ok),
    Command('git push', git_uptodate),
    Command('git push nvbn', git_ok),
    Command('git push nvbn master', git_uptodate),
    Command('git push nvbn', git_ok),
    Command('git push nvbn master', git_uptodate)])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, output', [
    (Command('git push', git_err), 'git push --force-with-lease'),
    (Command('git push nvbn', git_err), 'git push --force-with-lease nvbn'),
    (Command('git push nvbn master', git_err), 'git push --force-with-lease nvbn master')])
def test_get_new_command(command, output):
    assert get_new_command(command) == output<EOS>"
"<BOS>import pytest
from thefuck.rules.git_rebase_no_changes import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''Applying: Test commit
No changes - did you forget to use 'git add'?
If there is nothing left to stage, chances are that something else
already introduced the same changes; you might want to skip this patch.

When you have resolved this problem, run ""git rebase --continue"".
If you prefer to skip this patch, run ""git rebase --skip"" instead.
To check out the original branch and stop rebasing, run ""git rebase --abort"".

'''


def test_match(output):
    assert match(Command('git rebase --continue', output))
    assert not match(Command('git rebase --continue', ''))
    assert not match(Command('git rebase --skip', ''))


def test_get_new_command(output):
    assert (get_new_command(Command('git rebase --continue', output)) ==
            'git rebase --skip')<EOS>"
"<BOS>import pytest
from thefuck.rules.lein_not_task import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def is_not_task():
    return ''''rpl' is not a task. See 'lein help'.

Did you mean this?
         repl
         jar
'''


def test_match(is_not_task):
    assert match(Command('lein rpl', is_not_task))
    assert not match(Command('ls', is_not_task))


def test_get_new_command(is_not_task):
    assert (get_new_command(Command('lein rpl --help', is_not_task))
            == ['lein repl --help', 'lein jar --help'])<EOS>"
"<BOS>import pytest
from thefuck.rules.open import is_arg_url, match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output(script):
    return 'The file {} does not exist.\n'.format(script.split(' ', 1)[1])


@pytest.mark.parametrize('script', [
    'open foo.com',
    'open foo.edu',
    'open foo.info',
    'open foo.io',
    'open foo.ly',
    'open foo.me',
    'open foo.net',
    'open foo.org',
    'open foo.se',
    'open www.foo.ru'])
def test_is_arg_url(script):
    assert is_arg_url(Command(script, ''))


@pytest.mark.parametrize('script', ['open foo', 'open bar.txt', 'open egg.doc'])
def test_not_is_arg_url(script):
    assert not is_arg_url(Command(script, ''))


@pytest.mark.parametrize('script', [
    'open foo.com',
    'xdg-open foo.com',
    'gnome-open foo.com',
    'kde-open foo.com',
    'open nonest'])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, new_command', [
    ('open foo.io', ['open http://foo.io']),
    ('xdg-open foo.io', ['xdg-open http://foo.io']),
    ('gnome-open foo.io', ['gnome-open http://foo.io']),
    ('kde-open foo.io', ['kde-open http://foo.io']),
    ('open nonest', ['touch nonest && open nonest',
                     'mkdir nonest && open nonest'])])
def test_get_new_command(script, new_command, output):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.ag_literal import get_new_command, match
from thefuck.types import Command


@pytest.fixture
def output():
    return ('ERR: Bad regex! pcre_compile() failed at position 1: missing )\n'
            'If you meant to search for a literal string, run ag with -Q\n')


@pytest.mark.parametrize('script', ['ag \\('])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', ['ag foo'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, new_cmd', [
    ('ag \\(', 'ag -Q \\(')])
def test_get_new_command(script, new_cmd, output):
    assert get_new_command((Command(script, output))) == new_cmd<EOS>"
"<BOS>import pytest

from thefuck.rules.az_cli import match, get_new_command
from thefuck.types import Command


no_suggestions = '''\
az provider: error: the following arguments are required: _subcommand
usage: az provider [-h] {list,show,register,unregister,operation} ...
'''


misspelled_command = '''\
az: 'providers' is not in the 'az' command group. See 'az --help'.

The most similar choice to 'providers' is:
    provider
'''

misspelled_subcommand = '''\
az provider: 'lis' is not in the 'az provider' command group. See 'az provider --help'.

The most similar choice to 'lis' is:
    list
'''


@pytest.mark.parametrize('command', [
    Command('az providers', misspelled_command),
    Command('az provider lis', misspelled_subcommand)])
def test_match(command):
    assert match(command)


def test_not_match():
    assert not match(Command('az provider', no_suggestions))


@pytest.mark.parametrize('command, result', [
    (Command('az providers list', misspelled_command), ['az provider list']),
    (Command('az provider lis', misspelled_subcommand), ['az provider list'])
])
def test_get_new_command(command, result):
    assert get_new_command(command) == result<EOS>"
"<BOS>import pytest
from thefuck.types import Command
from thefuck.rules.brew_reinstall import get_new_command, match


output = (""Warning: thefuck 9.9 is already installed and up-to-date\nTo ""
          ""reinstall 9.9, run `brew reinstall thefuck`"")


def test_match():
    command = Command('brew install thefuck', output)
    assert match(command)


@pytest.mark.parametrize('script', [
    'brew reinstall thefuck',
    'brew install foo'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, formula, ', [
    ('brew install foo', 'foo'),
    ('brew install bar zap', 'bar zap')])
def test_get_new_command(script, formula):
    command = Command(script, output)
    new_command = 'brew reinstall {}'.format(formula)
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.types import Command
from thefuck.rules.chmod_x import match, get_new_command


@pytest.fixture
def file_exists(mocker):
    return mocker.patch('os.path.exists', return_value=True)


@pytest.fixture
def file_access(mocker):
    return mocker.patch('os.access', return_value=False)


@pytest.mark.usefixtures('file_exists', 'file_access')
@pytest.mark.parametrize('script, output', [
    ('./gradlew build', 'gradlew: Permission denied'),
    ('./install.sh --help', 'install.sh: permission denied')])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output, exists, callable', [
    ('./gradlew build', 'gradlew: Permission denied', True, True),
    ('./gradlew build', 'gradlew: Permission denied', False, False),
    ('./gradlew build', 'gradlew: error', True, False),
    ('gradlew build', 'gradlew: Permission denied', True, False)])
def test_not_match(file_exists, file_access, script, output, exists, callable):
    file_exists.return_value = exists
    file_access.return_value = callable
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, result', [
    ('./gradlew build', 'chmod +x gradlew && ./gradlew build'),
    ('./install.sh --help', 'chmod +x install.sh && ./install.sh --help')])
def test_get_new_command(script, result):
    assert get_new_command(Command(script, '')) == result<EOS>"
"<BOS>from io import BytesIO
import pytest
from thefuck.types import Command
from thefuck.rules.dnf_no_such_command import match, get_new_command, _get_operations


help_text = b'''usage: dnf [options] COMMAND

List of Main Commands:

autoremove                remove all unneeded packages that were originally installed as dependencies
check                     check for problems in the packagedb
check-update              check for available package upgrades
clean                     remove cached data
deplist                   List package's dependencies and what packages provide them
distro-sync               synchronize installed packages to the latest available versions
downgrade                 Downgrade a package
group                     display, or use, the groups information
help                      display a helpful usage message
history                   display, or use, the transaction history
info                      display details about a package or group of packages
install                   install a package or packages on your system
list                      list a package or groups of packages
makecache                 generate the metadata cache
mark                      mark or unmark installed packages as installed by user.
provides                  find what package provides the given value
reinstall                 reinstall a package
remove                    remove a package or packages from your system
repolist                  display the configured software repositories
repoquery                 search for packages matching keyword
repository-packages       run commands on top of all packages in given repository
search                    search package details for the given string
shell                     run an interactive DNF shell
swap                      run an interactive dnf mod for remove and install one spec
updateinfo                display advisories about packages
upgrade                   upgrade a package or packages on your system
upgrade-minimal           upgrade, but only 'newest' package match which fixes a problem that affects your system

List of Plugin Commands:

builddep                  Install build dependencies for package or spec file
config-manager            manage dnf configuration options and repositories
copr                      Interact with Copr repositories.
debug-dump                dump information about installed rpm packages to file
debug-restore             restore packages recorded in debug-dump file
debuginfo-install         install debuginfo packages
download                  Download package to current directory
needs-restarting          determine updated binaries that need restarting
playground                Interact with Playground repository.
repoclosure               Display a list of unresolved dependencies for repositories
repograph                 Output a full package dependency graph in dot format
repomanage                Manage a directory of rpm packages
reposync                  download all packages from remote repo

Optional arguments:
  -c [config file], --config [config file]
                        config file location
  -q, --quiet           quiet operation
  -v, --verbose         verbose operation
  --version             show DNF version and exit
  --installroot [path]  set install root
  --nodocs              do not install documentations
  --noplugins           disable all plugins
  --enableplugin [plugin]
                        enable plugins by name
  --disableplugin [plugin]
                        disable plugins by name
  --releasever RELEASEVER
                        override the value of $releasever in config and repo
                        files
  --setopt SETOPTS      set arbitrary config and repo options
  --skip-broken         resolve depsolve problems by skipping packages
  -h, --help, --help-cmd
                        show command help
  --allowerasing        allow erasing of installed packages to resolve
                        dependencies
  -b, --best            try the best available package versions in
                        transactions.
  -C, --cacheonly       run entirely from system cache, don't update cache
  -R [minutes], --randomwait [minutes]
                        maximum command wait time
  -d [debug level], --debuglevel [debug level]
                        debugging output level
  --debugsolver         dumps detailed solving results into files
  --showduplicates      show duplicates, in repos, in list/search commands
  -e ERRORLEVEL, --errorlevel ERRORLEVEL
                        error output level
  --obsoletes           enables dnf's obsoletes processing logic for upgrade
                        or display capabilities that the package obsoletes for
                        info, list and repoquery
  --rpmverbosity [debug level name]
                        debugging output level for rpm
  -y, --assumeyes       automatically answer yes for all questions
  --assumeno            automatically answer no for all questions
  --enablerepo [repo]
  --disablerepo [repo]
  --repo [repo], --repoid [repo]
                        enable just specific repositories by an id or a glob,
                        can be specified multiple times
  -x [package], --exclude [package], --excludepkgs [package]
                        exclude packages by name or glob
  --disableexcludes [repo], --disableexcludepkgs [repo]
                        disable excludepkgs
  --repofrompath [repo,path]
                        label and path to additional repository, can be
                        specified multiple times.
  --noautoremove        disable removal of dependencies that are no longer
                        used
  --nogpgcheck          disable gpg signature checking
  --color COLOR         control whether colour is used
  --refresh             set metadata as expired before running the command
  -4                    resolve to IPv4 addresses only
  -6                    resolve to IPv6 addresses only
  --destdir DESTDIR, --downloaddir DESTDIR
                        set directory to copy packages to
  --downloadonly        only download packages
  --bugfix              Include bugfix relevant packages, in updates
  --enhancement         Include enhancement relevant packages, in updates
  --newpackage          Include newpackage relevant packages, in updates
  --security            Include security relevant packages, in updates
  --advisory ADVISORY, --advisories ADVISORY
                        Include packages needed to fix the given advisory, in
                        updates
  --bzs BUGZILLA        Include packages needed to fix the given BZ, in
                        updates
  --cves CVES           Include packages needed to fix the given CVE, in
                        updates
  --sec-severity {Critical,Important,Moderate,Low}, --secseverity {Critical,Important,Moderate,Low}
                        Include security relevant packages matching the
                        severity, in updates
  --forcearch ARCH      Force the use of an architecture
'''

dnf_operations = ['autoremove', 'check', 'check-update', 'clean', 'deplist',
                  'distro-sync', 'downgrade', 'group', 'help', 'history',
                  'info', 'install', 'list', 'makecache', 'mark', 'provides',
                  'reinstall', 'remove', 'repolist', 'repoquery',
                  'repository-packages', 'search', 'shell', 'swap', 'updateinfo',
                  'upgrade', 'upgrade-minimal', 'builddep', 'config-manager',
                  'copr', 'debug-dump', 'debug-restore', 'debuginfo-install',
                  'download', 'needs-restarting', 'playground', 'repoclosure',
                  'repograph', 'repomanage', 'reposync']


def invalid_command(command):
    return """"""No such command: %s. Please use /usr/bin/dnf --help
It could be a DNF plugin command, try: ""dnf install 'dnf-command(%s)'""
"""""" % (command, command)


@pytest.mark.parametrize('output', [
    (invalid_command('saerch')),
    (invalid_command('isntall'))
])
def test_match(output):
    assert match(Command('dnf', output))


@pytest.mark.parametrize('script, output', [
    ('pip', invalid_command('isntall')),
    ('vim', """")
])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.fixture
def set_help(mocker):
    mock = mocker.patch('subprocess.Popen')

    def _set_text(text):
        mock.return_value.stdout = BytesIO(text)

    return _set_text


def test_get_operations(set_help):
    set_help(help_text)
    assert _get_operations() == dnf_operations


@pytest.mark.parametrize('script, output, result', [
    ('dnf isntall vim', invalid_command('isntall'),
     'dnf install vim'),
    ('dnf saerch vim', invalid_command('saerch'),
     'dnf search vim'),
])
def test_get_new_command(set_help, output, script, result):
    set_help(help_text)
    assert result in get_new_command(Command(script, output))<EOS>"
"<BOS>import pytest
from thefuck.rules.git_commit_amend import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('script, output', [
    ('git commit -m ""test""', 'test output'),
    ('git commit', '')])
def test_match(output, script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', [
    'git branch foo',
    'git checkout feature/test_commit',
    'git push'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script', [
    ('git commit -m ""test commit""'),
    ('git commit')])
def test_get_new_command(script):
    assert get_new_command(Command(script, '')) == 'git commit --amend'<EOS>"
"<BOS>import pytest
from thefuck.rules.git_pull_uncommitted_changes import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''error: Cannot pull with rebase: You have unstaged changes.'''


def test_match(output):
    assert match(Command('git pull', output))
    assert not match(Command('git pull', ''))
    assert not match(Command('ls', output))


def test_get_new_command(output):
    assert (get_new_command(Command('git pull', output))
            == ""git stash && git pull && git stash pop"")<EOS>"
"<BOS>import pytest
from thefuck.rules.git_tag_force import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''fatal: tag 'alert' already exists'''


def test_match(output):
    assert match(Command('git tag alert', output))
    assert not match(Command('git tag alert', ''))


def test_get_new_command(output):
    assert (get_new_command(Command('git tag alert', output))
            == ""git tag --force alert"")<EOS>"
"<BOS>import pytest
from thefuck.rules.go_run import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('go run foo', ''),
    Command('go run bar', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('go run foo', ''), 'go run foo.go'),
    (Command('go run bar', ''), 'go run bar.go')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from six import BytesIO
from thefuck.rules.ifconfig_device_not_found import match, get_new_command
from thefuck.types import Command


output = '{}: error fetching interface information: Device not found'

stdout = b'''
wlp2s0    Link encap:Ethernet  HWaddr 5c:51:4f:7c:58:5d
          inet addr:192.168.0.103  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::be23:69b9:96d2:6d39/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:23581604 errors:0 dropped:0 overruns:0 frame:0
          TX packets:17017655 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:16148429061 (16.1 GB)  TX bytes:7067533695 (7.0 GB)
'''


@pytest.fixture(autouse=True)
def ifconfig(mocker):
    mock = mocker.patch(
        'thefuck.rules.ifconfig_device_not_found.subprocess.Popen')
    mock.return_value.stdout = BytesIO(stdout)
    return mock


@pytest.mark.parametrize('script, output', [
    ('ifconfig wlan0', output.format('wlan0')),
    ('ifconfig -s eth0', output.format('eth0')),
])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output', [
    ('config wlan0',
     'wlan0: error fetching interface information: Device not found'),
    ('ifconfig eth0', ''),
])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, result', [
    ('ifconfig wlan0', ['ifconfig wlp2s0']),
    ('ifconfig -s wlan0', ['ifconfig -s wlp2s0']),
])
def test_get_new_comman(script, result):
    new_command = get_new_command(
        Command(script, output.format('wlan0')))
    assert new_command == result<EOS>"
"<BOS>import pytest
from thefuck.rules.python_execute import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('python foo', ''),
    Command('python bar', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('python foo', ''), 'python foo.py'),
    (Command('python bar', ''), 'python bar.py')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.rails_migrations_pending import match, get_new_command
from thefuck.types import Command

output_env_development = '''
Migrations are pending. To resolve this issue, run:

        rails db:migrate RAILS_ENV=development
'''
output_env_test = '''
Migrations are pending. To resolve this issue, run:

        bin/rails db:migrate RAILS_ENV=test
'''


@pytest.mark.parametrize(
    ""command"",
    [
        Command("""", output_env_development),
        Command("""", output_env_test),
    ],
)
def test_match(command):
    assert match(command)


@pytest.mark.parametrize(
    ""command"",
    [
        Command(""Environment data not found in the schema. To resolve this issue, run: \n\n"", """"),
    ],
)
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize(
    ""command, new_command"",
    [
        (Command(""bin/rspec"", output_env_development), ""rails db:migrate RAILS_ENV=development && bin/rspec""),
        (Command(""bin/rspec"", output_env_test), ""bin/rails db:migrate RAILS_ENV=test && bin/rspec""),
    ],
)
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>from thefuck.rules.sl_ls import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('sl', ''))
    assert not match(Command('ls', ''))


def test_get_new_command():
    assert get_new_command(Command('sl', '')) == 'ls'<EOS>"
"<BOS>from thefuck.rules.systemctl import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('systemctl nginx start', 'Unknown operation \'nginx\'.'))
    assert match(Command('sudo systemctl nginx start', 'Unknown operation \'nginx\'.'))
    assert not match(Command('systemctl start nginx', ''))
    assert not match(Command('systemctl start nginx', ''))
    assert not match(Command('sudo systemctl nginx', 'Unknown operation \'nginx\'.'))
    assert not match(Command('systemctl nginx', 'Unknown operation \'nginx\'.'))
    assert not match(Command('systemctl start wtf', 'Failed to start wtf.service: Unit wtf.service failed to load: No such file or directory.'))


def test_get_new_command():
    assert get_new_command(Command('systemctl nginx start', '')) == ""systemctl start nginx""
    assert get_new_command(Command('sudo systemctl nginx start', '')) == ""sudo systemctl start nginx""<EOS>"
"<BOS>import pytest

from thefuck.rules.aws_cli import match, get_new_command
from thefuck.types import Command


no_suggestions = '''\
usage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]
To see help text, you can run:

  aws help
  aws <command> help
  aws <command> <subcommand> help
aws: error: argument command: Invalid choice, valid choices are:

dynamodb                                 | dynamodbstreams
ec2                                      | ecr
'''


misspelled_command = '''\
usage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]
To see help text, you can run:

  aws help
  aws <command> help
  aws <command> <subcommand> help
aws: error: argument command: Invalid choice, valid choices are:

dynamodb                                 | dynamodbstreams
ec2                                      | ecr


Invalid choice: 'dynamdb', maybe you meant:

  * dynamodb
'''


misspelled_subcommand = '''\
usage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]
To see help text, you can run:

  aws help
  aws <command> help
  aws <command> <subcommand> help
aws: error: argument operation: Invalid choice, valid choices are:

query                                    | scan
update-item                              | update-table


Invalid choice: 'scn', maybe you meant:

  * scan
'''


misspelled_subcommand_with_multiple_options = '''\
usage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]
To see help text, you can run:

  aws help
  aws <command> help
  aws <command> <subcommand> help
aws: error: argument operation: Invalid choice, valid choices are:

describe-table                           | get-item
list-tables                              | put-item


Invalid choice: 't-item', maybe you meant:

  * put-item
  * get-item
'''


@pytest.mark.parametrize('command', [
    Command('aws dynamdb scan', misspelled_command),
    Command('aws dynamodb scn', misspelled_subcommand),
    Command('aws dynamodb t-item',
            misspelled_subcommand_with_multiple_options)])
def test_match(command):
    assert match(command)


def test_not_match():
    assert not match(Command('aws dynamodb invalid', no_suggestions))


@pytest.mark.parametrize('command, result', [
    (Command('aws dynamdb scan', misspelled_command),
     ['aws dynamodb scan']),
    (Command('aws dynamodb scn', misspelled_subcommand),
     ['aws dynamodb scan']),
    (Command('aws dynamodb t-item',
             misspelled_subcommand_with_multiple_options),
     ['aws dynamodb put-item', 'aws dynamodb get-item'])])
def test_get_new_command(command, result):
    assert get_new_command(command) == result<EOS>"
"<BOS>from thefuck.rules.cd_cs import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('cs', 'cs: command not found'))
    assert match(Command('cs /etc/', 'cs: command not found'))


def test_get_new_command():
    assert get_new_command(Command('cs /etc/', 'cs: command not found')) == 'cd /etc/'<EOS>"
"<BOS>import pytest
from thefuck.rules.cd_mkdir import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('cd foo', 'cd: foo: No such file or directory'),
    Command('cd foo/bar/baz',
            'cd: foo: No such file or directory'),
    Command('cd foo/bar/baz', 'cd: can\'t cd to foo/bar/baz'),
    Command('cd /foo/bar/', 'cd: The directory ""/foo/bar/"" does not exist')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('cd foo', ''), Command('', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('cd foo', ''), 'mkdir -p foo && cd foo'),
    (Command('cd foo/bar/baz', ''), 'mkdir -p foo/bar/baz && cd foo/bar/baz')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.git_fix_stash import match, get_new_command
from thefuck.types import Command


git_stash_err = '''
usage: git stash list [<options>]
   or: git stash show [<stash>]
   or: git stash drop [-q|--quiet] [<stash>]
   or: git stash ( pop | apply ) [--index] [-q|--quiet] [<stash>]
   or: git stash branch <branchname> [<stash>]
   or: git stash [save [--patch] [-k|--[no-]keep-index] [-q|--quiet]
\t\t       [-u|--include-untracked] [-a|--all] [<message>]]
   or: git stash clear
'''


@pytest.mark.parametrize('wrong', [
    'git stash opp',
    'git stash Some message',
    'git stash saev Some message'])
def test_match(wrong):
    assert match(Command(wrong, git_stash_err))


def test_not_match():
    assert not match(Command(""git"", git_stash_err))


@pytest.mark.parametrize('wrong,fixed', [
    ('git stash opp', 'git stash pop'),
    ('git stash Some message', 'git stash save Some message'),
    ('git stash saev Some message', 'git stash save Some message')])
def test_get_new_command(wrong, fixed):
    assert get_new_command(Command(wrong, git_stash_err)) == fixed<EOS>"
"<BOS>import pytest
from thefuck.rules.git_not_command import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def git_not_command():
    return """"""git: 'brnch' is not a git command. See 'git --help'.

The most similar command is
branch
""""""


@pytest.fixture
def git_not_command_one_of_this():
    return """"""git: 'st' is not a git command. See 'git --help'.

The most similar commands are
status
reset
stage
stash
stats
""""""


@pytest.fixture
def git_not_command_closest():
    return '''git: 'tags' is not a git command. See 'git --help'.

The most similar commands are
\tstage
\ttag
'''


@pytest.fixture
def git_command():
    return ""* master""


def test_match(git_not_command, git_command, git_not_command_one_of_this):
    assert match(Command('git brnch', git_not_command))
    assert match(Command('git st', git_not_command_one_of_this))
    assert not match(Command('ls brnch', git_not_command))
    assert not match(Command('git branch', git_command))


def test_get_new_command(git_not_command, git_not_command_one_of_this,
                         git_not_command_closest):
    assert (get_new_command(Command('git brnch', git_not_command))
            == ['git branch'])
    assert (get_new_command(Command('git st', git_not_command_one_of_this))
            == ['git stats', 'git stash', 'git stage'])
    assert (get_new_command(Command('git tags', git_not_command_closest))
            == ['git tag', 'git stage'])<EOS>"
"<BOS># -*- coding: utf-8 -*-

from thefuck.rules.grep_recursive import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('grep blah .', 'grep: .: Is a directory'))
    assert match(Command(u'grep café .', 'grep: .: Is a directory'))
    assert not match(Command('', ''))


def test_get_new_command():
    assert get_new_command(Command('grep blah .', '')) == 'grep -r blah .'
    assert get_new_command(Command(u'grep café .', '')) == u'grep -r café .'<EOS>"
"<BOS>import pytest
from io import BytesIO
from thefuck.types import Command
from thefuck.rules.gulp_not_task import match, get_new_command


def output(task):
    return '''[00:41:11] Using gulpfile gulpfile.js
[00:41:11] Task '{}' is not in your gulpfile
[00:41:11] Please check the documentation for proper gulpfile formatting
'''.format(task)


def test_match():
    assert match(Command('gulp srve', output('srve')))


@pytest.mark.parametrize('script, stdout', [
    ('gulp serve', ''),
    ('cat srve', output('srve'))])
def test_not_march(script, stdout):
    assert not match(Command(script, stdout))


def test_get_new_command(mocker):
    mock = mocker.patch('subprocess.Popen')
    mock.return_value.stdout = BytesIO(b'serve \nbuild \ndefault \n')
    command = Command('gulp srve', output('srve'))
    assert get_new_command(command) == ['gulp serve', 'gulp default']<EOS>"
"<BOS>import pytest
from thefuck.rules.ln_s_order import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def file_exists(mocker):
    return mocker.patch('os.path.exists', return_value=True)


get_output = ""ln: failed to create symbolic link '{}': File exists"".format


@pytest.mark.parametrize('script, output, exists', [
    ('ln dest source', get_output('source'), True),
    ('ls -s dest source', get_output('source'), True),
    ('ln -s dest source', '', True),
    ('ln -s dest source', get_output('source'), False)])
def test_not_match(file_exists, script, output, exists):
    file_exists.return_value = exists
    assert not match(Command(script, output))


@pytest.mark.usefixtures('file_exists')
@pytest.mark.parametrize('script, result', [
    ('ln -s dest source', 'ln -s source dest'),
    ('ln dest -s source', 'ln -s source dest'),
    ('ln dest source -s', 'ln source -s dest')])
def test_match(script, result):
    output = get_output('source')
    assert match(Command(script, output))
    assert get_new_command(Command(script, output)) == result<EOS>"
"<BOS>import pytest
from thefuck.rules.long_form_help import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('output', [
    'Try \'grep --help\' for more information.'])
def test_match(output):
    assert match(Command('grep -h', output))


def test_not_match():
    assert not match(Command('', ''))


@pytest.mark.parametrize('before, after', [
    ('grep -h', 'grep --help'),
    ('tar -h', 'tar --help'),
    ('docker run -h', 'docker run --help'),
    ('cut -h', 'cut --help')])
def test_get_new_command(before, after):
    assert get_new_command(Command(before, '')) == after<EOS>"
"<BOS>import pytest

from thefuck.types import Command
from thefuck.rules.mercurial import (
    extract_possibilities, match, get_new_command
)


@pytest.mark.parametrize('command', [
    Command('hg base', (
        ""hg: unknown command 'base'""
        '\n(did you mean one of blame, phase, rebase?)'
    )),
    Command('hg branchch', (
        ""hg: unknown command 'branchch'""
        '\n(did you mean one of branch, branches?)'
    )),
    Command('hg vert', (
        ""hg: unknown command 'vert'""
        '\n(did you mean one of revert?)'
    )),
    Command('hg lgo -r tip', (
        ""hg: command 're' is ambiguous:""
        '\n(did you mean one of log?)'
    )),
    Command('hg rerere', (
        ""hg: unknown command 'rerere'""
        '\n(did you mean one of revert?)'
    )),
    Command('hg re', (
        ""hg: command 're' is ambiguous:""
        '\n    rebase recover remove rename resolve revert'
    )),
    Command('hg re re', (
        ""hg: command 're' is ambiguous:""
        '\n    rebase recover remove rename resolve revert'
    )),
])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('hg', (
        '\nMercurial Distributed SCM\n\nbasic commands:'
    )),
    Command('hg asdf', (
        ""hg: unknown command 'asdf'""
        '\nMercurial Distributed SCM\n\nbasic commands:'
    )),
    Command('hg qwer', (
        ""hg: unknown command 'qwer'""
        '\nMercurial Distributed SCM\n\nbasic commands:'
    )),
    Command('hg me', (
        ""\nabort: no repository found in './thefuck' (.hg not found)!""
    )),
    Command('hg reb', (
        ""\nabort: no repository found in './thefuck' (.hg not found)!""
    )),
    Command('hg co', (
        ""\nabort: no repository found in './thefuck' (.hg not found)!""
    )),
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, possibilities', [
    (Command('hg base', (
        ""hg: unknown command 'base'""
        '\n(did you mean one of blame, phase, rebase?)'
    )), ['blame', 'phase', 'rebase']),
    (Command('hg branchch', (
        ""hg: unknown command 'branchch'""
        '\n(did you mean one of branch, branches?)'
    )), ['branch', 'branches']),
    (Command('hg vert', (
        ""hg: unknown command 'vert'""
        '\n(did you mean one of revert?)'
    )), ['revert']),
    (Command('hg lgo -r tip', (
        ""hg: command 're' is ambiguous:""
        '\n(did you mean one of log?)'
    )), ['log']),
    (Command('hg rerere', (
        ""hg: unknown command 'rerere'""
        '\n(did you mean one of revert?)'
    )), ['revert']),
    (Command('hg re', (
        ""hg: command 're' is ambiguous:""
        '\n    rebase recover remove rename resolve revert'
    )), ['rebase', 'recover', 'remove', 'rename', 'resolve', 'revert']),
    (Command('hg re re', (
        ""hg: command 're' is ambiguous:""
        '\n    rebase recover remove rename resolve revert'
    )), ['rebase', 'recover', 'remove', 'rename', 'resolve', 'revert']),
])
def test_extract_possibilities(command, possibilities):
    assert extract_possibilities(command) == possibilities


@pytest.mark.parametrize('command, new_command', [
    (Command('hg base', (
        ""hg: unknown command 'base'""
        '\n(did you mean one of blame, phase, rebase?)'
    )), 'hg rebase'),
    (Command('hg branchch', (
        ""hg: unknown command 'branchch'""
        '\n(did you mean one of branch, branches?)'
    )), 'hg branch'),
    (Command('hg vert', (
        ""hg: unknown command 'vert'""
        '\n(did you mean one of revert?)'
    )), 'hg revert'),
    (Command('hg lgo -r tip', (
        ""hg: command 're' is ambiguous:""
        '\n(did you mean one of log?)'
    )), 'hg log -r tip'),
    (Command('hg rerere', (
        ""hg: unknown command 'rerere'""
        '\n(did you mean one of revert?)'
    )), 'hg revert'),
    (Command('hg re', (
        ""hg: command 're' is ambiguous:""
        '\n    rebase recover remove rename resolve revert'
    )), 'hg rebase'),
    (Command('hg re re', (
        ""hg: command 're' is ambiguous:""
        '\n    rebase recover remove rename resolve revert'
    )), 'hg rebase re'),
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.missing_space_before_subcommand import (
    match, get_new_command)
from thefuck.types import Command


@pytest.fixture(autouse=True)
def all_executables(mocker):
    return mocker.patch(
        'thefuck.rules.missing_space_before_subcommand.get_all_executables',
        return_value=['git', 'ls', 'npm', 'w', 'watch'])


@pytest.mark.parametrize('script', [
    'gitbranch', 'ls-la', 'npminstall', 'watchls'])
def test_match(script):
    assert match(Command(script, ''))


@pytest.mark.parametrize('script', ['git branch', 'vimfile'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, result', [
    ('gitbranch', 'git branch'),
    ('ls-la', 'ls -la'),
    ('npminstall webpack', 'npm install webpack'),
    ('watchls', 'watch ls')])
def test_get_new_command(script, result):
    assert get_new_command(Command(script, '')) == result<EOS>"
"<BOS># -*- encoding: utf-8 -*-

import pytest

from thefuck.rules import switch_lang
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command(u'фзе-пуе', 'command not found: фзе-пуе'),
    Command(u'λσ', 'command not found: λσ'),
    Command(u'שפא-עקא', 'command not found: שפא-עקא'),
    Command(u'ךד', 'command not found: ךד'),
    Command(u'녀애 ㅣㄴ', 'command not found: 녀애 ㅣㄴ')])
def test_match(command):
    assert switch_lang.match(command)


@pytest.mark.parametrize('command', [
    Command(u'pat-get', 'command not found: pat-get'),
    Command(u'ls', 'command not found: ls'),
    Command(u'агсл', 'command not found: агсл'),
    Command(u'фзе-пуе', 'some info'),
    Command(u'שפא-עקא', 'some info'),
    Command(u'녀애 ㅣㄴ', 'some info')])
def test_not_match(command):
    assert not switch_lang.match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command(u'фзе-пуе штыефдд мшь', ''), 'apt-get install vim'),
    (Command(u'λσ -λα', ''), 'ls -la'),
    (Command(u'שפא-עקא ןמדאשךך הןצ', ''), 'apt-get install vim'),
    (Command(u'ךד -ךש', ''), 'ls -la'),
    (Command(u'멧-ㅎㄷㅅ ㅑㅜㄴㅅ미ㅣ 퍄ㅡ', ''), 'apt-get install vim'),
    (Command(u'ㅣㄴ -ㅣㅁ', ''), 'ls -la'),
    (Command(u'ㅔㅁㅅ촤', ''), 'patchk'), ])
def test_get_new_command(command, new_command):
    assert switch_lang.get_new_command(command) == new_command<EOS>"
"<BOS>from io import BytesIO
import pytest
from thefuck.types import Command
from thefuck.rules.apt_invalid_operation import match, get_new_command, \
    _get_operations

invalid_operation = 'E: Invalid operation {}'.format
apt_help = b'''apt 1.0.10.2ubuntu1 for amd64 compiled on Oct  5 2015 15:55:05
Usage: apt [options] command

CLI for apt.
Basic commands:
 list - list packages based on package names
 search - search in package descriptions
 show - show package details

 update - update list of available packages

 install - install packages
 remove  - remove packages

 upgrade - upgrade the system by installing/upgrading packages
 full-upgrade - upgrade the system by removing/installing/upgrading packages

 edit-sources - edit the source information file
'''
apt_operations = ['list', 'search', 'show', 'update', 'install', 'remove',
                  'upgrade', 'full-upgrade', 'edit-sources']

apt_get_help = b'''apt 1.0.10.2ubuntu1 for amd64 compiled on Oct  5 2015 15:55:05
Usage: apt-get [options] command
       apt-get [options] install|remove pkg1 [pkg2 ...]
       apt-get [options] source pkg1 [pkg2 ...]

apt-get is a simple command line interface for downloading and
installing packages. The most frequently used commands are update
and install.

Commands:
   update - Retrieve new lists of packages
   upgrade - Perform an upgrade
   install - Install new packages (pkg is libc6 not libc6.deb)
   remove - Remove packages
   autoremove - Remove automatically all unused packages
   purge - Remove packages and config files
   source - Download source archives
   build-dep - Configure build-dependencies for source packages
   dist-upgrade - Distribution upgrade, see apt-get(8)
   dselect-upgrade - Follow dselect selections
   clean - Erase downloaded archive files
   autoclean - Erase old downloaded archive files
   check - Verify that there are no broken dependencies
   changelog - Download and display the changelog for the given package
   download - Download the binary package into the current directory

Options:
  -h  This help text.
  -q  Loggable output - no progress indicator
  -qq No output except for errors
  -d  Download only - do NOT install or unpack archives
  -s  No-act. Perform ordering simulation
  -y  Assume Yes to all queries and do not prompt
  -f  Attempt to correct a system with broken dependencies in place
  -m  Attempt to continue if archives are unlocatable
  -u  Show a list of upgraded packages as well
  -b  Build the source package after fetching it
  -V  Show verbose version numbers
  -c=? Read this configuration file
  -o=? Set an arbitrary configuration option, eg -o dir::cache=/tmp
See the apt-get(8), sources.list(5) and apt.conf(5) manual
pages for more information and options.
                       This APT has Super Cow Powers.
'''
apt_get_operations = ['update', 'upgrade', 'install', 'remove', 'autoremove',
                      'purge', 'source', 'build-dep', 'dist-upgrade',
                      'dselect-upgrade', 'clean', 'autoclean', 'check',
                      'changelog', 'download']

new_apt_get_help = b'''apt 1.6.12 (amd64)
Usage: apt-get [options] command
       apt-get [options] install|remove pkg1 [pkg2 ...]
       apt-get [options] source pkg1 [pkg2 ...]

apt-get is a command line interface for retrieval of packages
and information about them from authenticated sources and
for installation, upgrade and removal of packages together
with their dependencies.

Most used commands:
  update - Retrieve new lists of packages
  upgrade - Perform an upgrade
  install - Install new packages (pkg is libc6 not libc6.deb)
  remove - Remove packages
  purge - Remove packages and config files
  autoremove - Remove automatically all unused packages
  dist-upgrade - Distribution upgrade, see apt-get(8)
  dselect-upgrade - Follow dselect selections
  build-dep - Configure build-dependencies for source packages
  clean - Erase downloaded archive files
  autoclean - Erase old downloaded archive files
  check - Verify that there are no broken dependencies
  source - Download source archives
  download - Download the binary package into the current directory
  changelog - Download and display the changelog for the given package

See apt-get(8) for more information about the available commands.
Configuration options and syntax is detailed in apt.conf(5).
Information about how to configure sources can be found in sources.list(5).
Package and version choices can be expressed via apt_preferences(5).
Security details are available in apt-secure(8).
                                        This APT has Super Cow Powers.
'''
new_apt_get_operations = ['update', 'upgrade', 'install', 'remove', 'purge',
                          'autoremove', 'dist-upgrade', 'dselect-upgrade',
                          'build-dep', 'clean', 'autoclean', 'check',
                          'source', 'download', 'changelog']


@pytest.mark.parametrize('script, output', [
    ('apt', invalid_operation('saerch')),
    ('apt-get', invalid_operation('isntall')),
    ('apt-cache', invalid_operation('rumove'))])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output', [
    ('vim', invalid_operation('vim')),
    ('apt-get', """")])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.fixture
def set_help(mocker):
    mock = mocker.patch('subprocess.Popen')

    def _set_text(text):
        mock.return_value.stdout = BytesIO(text)

    return _set_text


@pytest.mark.parametrize('app, help_text, operations', [
    ('apt', apt_help, apt_operations),
    ('apt-get', apt_get_help, apt_get_operations),
    ('apt-get', new_apt_get_help, new_apt_get_operations)
])
def test_get_operations(set_help, app, help_text, operations):
    set_help(help_text)
    assert _get_operations(app) == operations


@pytest.mark.parametrize('script, output, help_text, result', [
    ('apt-get isntall vim', invalid_operation('isntall'),
     apt_get_help, 'apt-get install vim'),
    ('apt saerch vim', invalid_operation('saerch'),
     apt_help, 'apt search vim'),
    ('apt uninstall vim', invalid_operation('uninstall'),
     apt_help, 'apt remove vim'),
])
def test_get_new_command(set_help, output, script, help_text, result):
    set_help(help_text)
    assert get_new_command(Command(script, output))[0] == result<EOS>"
"<BOS>from thefuck.rules.cd_parent import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('cd..', 'cd..: command not found'))
    assert not match(Command('', ''))


def test_get_new_command():
    assert get_new_command(Command('cd..', '')) == 'cd ..'<EOS>"
"<BOS>import pytest
from thefuck.rules.cp_omitting_directory import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('script, output', [
    ('cp dir', 'cp: dor: is a directory'),
    ('cp dir', ""cp: omitting directory 'dir'"")])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output', [
    ('some dir', 'cp: dor: is a directory'),
    ('some dir', ""cp: omitting directory 'dir'""),
    ('cp dir', '')])
def test_not_match(script, output):
    assert not match(Command(script, output))


def test_get_new_command():
    assert get_new_command(Command('cp dir', '')) == 'cp -a dir'<EOS>"
"<BOS>import pytest
from io import BytesIO
from thefuck.types import Command
from thefuck.rules.docker_not_command import get_new_command, match


_DOCKER_SWARM_OUTPUT = '''
Usage:	docker swarm COMMAND

Manage Swarm

Commands:
  ca          Display and rotate the root CA
  init        Initialize a swarm
  join        Join a swarm as a node and/or manager
  join-token  Manage join tokens
  leave       Leave the swarm
  unlock      Unlock swarm
  unlock-key  Manage the unlock key
  update      Update the swarm

Run 'docker swarm COMMAND --help' for more information on a command.
'''
_DOCKER_IMAGE_OUTPUT = '''
Usage:	docker image COMMAND

Manage images

Commands:
  build       Build an image from a Dockerfile
  history     Show the history of an image
  import      Import the contents from a tarball to create a filesystem image
  inspect     Display detailed information on one or more images
  load        Load an image from a tar archive or STDIN
  ls          List images
  prune       Remove unused images
  pull        Pull an image or a repository from a registry
  push        Push an image or a repository to a registry
  rm          Remove one or more images
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE

Run 'docker image COMMAND --help' for more information on a command.
'''


@pytest.fixture
def docker_help(mocker):
    help = b'''Usage: docker [OPTIONS] COMMAND [arg...]

A self-sufficient runtime for linux containers.

Options:

  --api-cors-header=                   Set CORS headers in the remote API
  -b, --bridge=                        Attach containers to a network bridge
  --bip=                               Specify network bridge IP
  -D, --debug=false                    Enable debug mode
  -d, --daemon=false                   Enable daemon mode
  --default-gateway=                   Container default gateway IPv4 address
  --default-gateway-v6=                Container default gateway IPv6 address
  --default-ulimit=[]                  Set default ulimits for containers
  --dns=[]                             DNS server to use
  --dns-search=[]                      DNS search domains to use
  -e, --exec-driver=native             Exec driver to use
  --exec-opt=[]                        Set exec driver options
  --exec-root=/var/run/docker          Root of the Docker execdriver
  --fixed-cidr=                        IPv4 subnet for fixed IPs
  --fixed-cidr-v6=                     IPv6 subnet for fixed IPs
  -G, --group=docker                   Group for the unix socket
  -g, --graph=/var/lib/docker          Root of the Docker runtime
  -H, --host=[]                        Daemon socket(s) to connect to
  -h, --help=false                     Print usage
  --icc=true                           Enable inter-container communication
  --insecure-registry=[]               Enable insecure registry communication
  --ip=0.0.0.0                         Default IP when binding container ports
  --ip-forward=true                    Enable net.ipv4.ip_forward
  --ip-masq=true                       Enable IP masquerading
  --iptables=true                      Enable addition of iptables rules
  --ipv6=false                         Enable IPv6 networking
  -l, --log-level=info                 Set the logging level
  --label=[]                           Set key=value labels to the daemon
  --log-driver=json-file               Default driver for container logs
  --log-opt=map[]                      Set log driver options
  --mtu=0                              Set the containers network MTU
  -p, --pidfile=/var/run/docker.pid    Path to use for daemon PID file
  --registry-mirror=[]                 Preferred Docker registry mirror
  -s, --storage-driver=                Storage driver to use
  --selinux-enabled=false              Enable selinux support
  --storage-opt=[]                     Set storage driver options
  --tls=false                          Use TLS; implied by --tlsverify
  --tlscacert=~/.docker/ca.pem         Trust certs signed only by this CA
  --tlscert=~/.docker/cert.pem         Path to TLS certificate file
  --tlskey=~/.docker/key.pem           Path to TLS key file
  --tlsverify=false                    Use TLS and verify the remote
  --userland-proxy=true                Use userland proxy for loopback traffic
  -v, --version=false                  Print version information and quit

Commands:
    attach    Attach to a running container
    build     Build an image from a Dockerfile
    commit    Create a new image from a container's changes
    cp        Copy files/folders from a container's filesystem to the host path
    create    Create a new container
    diff      Inspect changes on a container's filesystem
    events    Get real time events from the server
    exec      Run a command in a running container
    export    Stream the contents of a container as a tar archive
    history   Show the history of an image
    images    List images
    import    Create a new filesystem image from the contents of a tarball
    info      Display system-wide information
    inspect   Return low-level information on a container or image
    kill      Kill a running container
    load      Load an image from a tar archive
    login     Register or log in to a Docker registry server
    logout    Log out from a Docker registry server
    logs      Fetch the logs of a container
    pause     Pause all processes within a container
    port      Lookup the public-facing port that is NAT-ed to PRIVATE_PORT
    ps        List containers
    pull      Pull an image or a repository from a Docker registry server
    push      Push an image or a repository to a Docker registry server
    rename    Rename an existing container
    restart   Restart a running container
    rm        Remove one or more containers
    rmi       Remove one or more images
    run       Run a command in a new container
    save      Save an image to a tar archive
    search    Search for an image on the Docker Hub
    start     Start a stopped container
    stats     Display a stream of a containers' resource usage statistics
    stop      Stop a running container
    tag       Tag an image into a repository
    top       Lookup the running processes of a container
    unpause   Unpause a paused container
    version   Show the Docker version information
    wait      Block until a container stops, then print its exit code

Run 'docker COMMAND --help' for more information on a command.
'''
    mock = mocker.patch('subprocess.Popen')
    mock.return_value.stdout = BytesIO(help)
    return mock


@pytest.fixture
def docker_help_new(mocker):
    helptext_new = b'''
Usage:	docker [OPTIONS] COMMAND

A self-sufficient runtime for containers

Options:
      --config string      Location of client config files (default ""/Users/ik1ne/.docker"")
  -c, --context string     Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var
                           and default context set with ""docker context use"")
  -D, --debug              Enable debug mode
  -H, --host list          Daemon socket(s) to connect to
  -l, --log-level string   Set the logging level (""debug""|""info""|""warn""|""error""|""fatal"") (default ""info"")
      --tls                Use TLS; implied by --tlsverify
      --tlscacert string   Trust certs signed only by this CA (default ""/Users/ik1ne/.docker/ca.pem"")
      --tlscert string     Path to TLS certificate file (default ""/Users/ik1ne/.docker/cert.pem"")
      --tlskey string      Path to TLS key file (default ""/Users/ik1ne/.docker/key.pem"")
      --tlsverify          Use TLS and verify the remote
  -v, --version            Print version information and quit

Management Commands:
  builder     Manage builds
  config      Manage Docker configs
  container   Manage containers
  context     Manage contexts
  image       Manage images
  network     Manage networks
  node        Manage Swarm nodes
  plugin      Manage plugins
  secret      Manage Docker secrets
  service     Manage services
  stack       Manage Docker stacks
  swarm       Manage Swarm
  system      Manage Docker
  trust       Manage trust on Docker images
  volume      Manage volumes

Commands:
  attach      Attach local standard input, output, and error streams to a running container
  build       Build an image from a Dockerfile
  commit      Create a new image from a container's changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  diff        Inspect changes to files or directories on a container's filesystem
  events      Get real time events from the server
  exec        Run a command in a running container
  export      Export a container's filesystem as a tar archive
  history     Show the history of an image
  images      List images
  import      Import the contents from a tarball to create a filesystem image
  info        Display system-wide information
  inspect     Return low-level information on Docker objects
  kill        Kill one or more running containers
  load        Load an image from a tar archive or STDIN
  login       Log in to a Docker registry
  logout      Log out from a Docker registry
  logs        Fetch the logs of a container
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  ps          List containers
  pull        Pull an image or a repository from a registry
  push        Push an image or a repository to a registry
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  rmi         Remove one or more images
  run         Run a command in a new container
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  search      Search the Docker Hub for images
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  version     Show the Docker version information
  wait        Block until one or more containers stop, then print their exit codes

Run 'docker COMMAND --help' for more information on a command.
'''
    mock = mocker.patch('subprocess.Popen')
    mock.return_value.stdout = BytesIO(b'')
    mock.return_value.stderr = BytesIO(helptext_new)
    return mock


def output(cmd):
    return ""docker: '{}' is not a docker command.\n"" \
           ""See 'docker --help'."".format(cmd)


def test_match():
    assert match(Command('docker pes', output('pes')))


# tests docker (management command)
@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script, output', [
    ('docker swarn', output('swarn')),
    ('docker imge', output('imge'))])
def test_match_management_cmd(script, output):
    assert match(Command(script, output))


# tests docker (management cmd) (management subcmd)
@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script, output', [
    ('docker swarm int', _DOCKER_SWARM_OUTPUT),
    ('docker image la', _DOCKER_IMAGE_OUTPUT)])
def test_match_management_subcmd(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output', [
    ('docker ps', ''),
    ('cat pes', output('pes'))])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.usefixtures('no_memoize', 'docker_help')
@pytest.mark.parametrize('wrong, fixed', [
    ('pes', ['ps', 'push', 'pause']),
    ('tags', ['tag', 'stats', 'images'])])
def test_get_new_command(wrong, fixed):
    command = Command('docker {}'.format(wrong), output(wrong))
    assert get_new_command(command) == ['docker {}'.format(x) for x in fixed]


@pytest.mark.usefixtures('no_memoize', 'docker_help_new')
@pytest.mark.parametrize('wrong, fixed', [
    ('swarn', ['swarm', 'start', 'search']),
    ('inage', ['image', 'images', 'rename'])])
def test_get_new_management_command(wrong, fixed):
    command = Command('docker {}'.format(wrong), output(wrong))
    assert get_new_command(command) == ['docker {}'.format(x) for x in fixed]


@pytest.mark.usefixtures('no_memoize', 'docker_help_new')
@pytest.mark.parametrize('wrong, fixed, output', [
    ('swarm int', ['swarm init', 'swarm join', 'swarm join-token'], _DOCKER_SWARM_OUTPUT),
    ('image la', ['image load', 'image ls', 'image tag'], _DOCKER_IMAGE_OUTPUT)])
def test_get_new_management_command_subcommand(wrong, fixed, output):
    command = Command('docker {}'.format(wrong), output)
    assert get_new_command(command) == ['docker {}'.format(x) for x in fixed]<EOS>"
"<BOS># -*- coding: utf-8 -*-

import pytest
import os
from collections import namedtuple
from thefuck.rules.fix_file import match, get_new_command
from thefuck.types import Command

FixFileTest = namedtuple('FixFileTest', ['script', 'file', 'line', 'col', 'output'])

tests = (
    FixFileTest('gcc a.c', 'a.c', 3, 1, """"""
a.c: In function 'main':
a.c:3:1: error: expected expression before '}' token
 }
  ^
""""""),

    FixFileTest('clang a.c', 'a.c', 3, 1, """"""
a.c:3:1: error: expected expression
}
^
""""""),

    FixFileTest('perl a.pl', 'a.pl', 3, None, """"""
syntax error at a.pl line 3, at EOF
Execution of a.pl aborted due to compilation errors.
""""""),

    FixFileTest('perl a.pl', 'a.pl', 2, None, """"""
Search pattern not terminated at a.pl line 2.
""""""),

    FixFileTest('sh a.sh', 'a.sh', 2, None, """"""
a.sh: line 2: foo: command not found
""""""),

    FixFileTest('zsh a.sh', 'a.sh', 2, None, """"""
a.sh:2: command not found: foo
""""""),

    FixFileTest('bash a.sh', 'a.sh', 2, None, """"""
a.sh: line 2: foo: command not found
""""""),

    FixFileTest('rustc a.rs', 'a.rs', 2, 5, """"""
a.rs:2:5: 2:6 error: unexpected token: `+`
a.rs:2     +
           ^
""""""),

    FixFileTest('cargo build', 'src/lib.rs', 3, 5, """"""
   Compiling test v0.1.0 (file:///tmp/fix-error/test)
   src/lib.rs:3:5: 3:6 error: unexpected token: `+`
   src/lib.rs:3     +
                    ^
Could not compile `test`.

To learn more, run the command again with --verbose.
""""""),

    FixFileTest('python a.py', 'a.py', 2, None, """"""
  File ""a.py"", line 2
      +
          ^
SyntaxError: invalid syntax
""""""),

    FixFileTest('python a.py', 'a.py', 8, None, """"""
Traceback (most recent call last):
  File ""a.py"", line 8, in <module>
    match(""foo"")
  File ""a.py"", line 5, in match
    m = re.search(None, command)
  File ""/usr/lib/python3.4/re.py"", line 170, in search
    return _compile(pattern, flags).search(string)
  File ""/usr/lib/python3.4/re.py"", line 293, in _compile
    raise TypeError(""first argument must be string or compiled pattern"")
TypeError: first argument must be string or compiled pattern
""""""),

    FixFileTest(u'python café.py', u'café.py', 8, None, u""""""
Traceback (most recent call last):
  File ""café.py"", line 8, in <module>
    match(""foo"")
  File ""café.py"", line 5, in match
    m = re.search(None, command)
  File ""/usr/lib/python3.4/re.py"", line 170, in search
    return _compile(pattern, flags).search(string)
  File ""/usr/lib/python3.4/re.py"", line 293, in _compile
    raise TypeError(""first argument must be string or compiled pattern"")
TypeError: first argument must be string or compiled pattern
""""""),

    FixFileTest('ruby a.rb', 'a.rb', 3, None, """"""
a.rb:3: syntax error, unexpected keyword_end
""""""),

    FixFileTest('lua a.lua', 'a.lua', 2, None, """"""
lua: a.lua:2: unexpected symbol near '+'
""""""),

    FixFileTest('fish a.sh', '/tmp/fix-error/a.sh', 2, None, """"""
fish: Unknown command 'foo'
/tmp/fix-error/a.sh (line 2): foo
                              ^
""""""),

    FixFileTest('./a', './a', 2, None, """"""
awk: ./a:2: BEGIN { print ""Hello, world!"" + }
awk: ./a:2:                                 ^ syntax error
""""""),

    FixFileTest('llc a.ll', 'a.ll', 1, 2, """"""
llc: a.ll:1:2: error: expected top-level entity
+
^
""""""),

    FixFileTest('go build a.go', 'a.go', 1, 2, """"""
can't load package:
a.go:1:2: expected 'package', found '+'
""""""),

    FixFileTest('make', 'Makefile', 2, None, """"""
bidule
make: bidule: Command not found
Makefile:2: recipe for target 'target' failed
make: *** [target] Error 127
""""""),

    FixFileTest('git st', '/home/martin/.config/git/config', 1, None, """"""
fatal: bad config file line 1 in /home/martin/.config/git/config
""""""),

    FixFileTest('node fuck.js asdf qwer', '/Users/pablo/Workspace/barebones/fuck.js', '2', 5, """"""
/Users/pablo/Workspace/barebones/fuck.js:2
conole.log(arg);  // this should read console.log(arg);
^
ReferenceError: conole is not defined
    at /Users/pablo/Workspace/barebones/fuck.js:2:5
    at Array.forEach (native)
    at Object.<anonymous> (/Users/pablo/Workspace/barebones/fuck.js:1:85)
    at Module._compile (module.js:460:26)
    at Object.Module._extensions..js (module.js:478:10)
    at Module.load (module.js:355:32)
    at Function.Module._load (module.js:310:12)
    at Function.Module.runMain (module.js:501:10)
    at startup (node.js:129:16)
    at node.js:814:3
""""""),

    FixFileTest('pep8', './tests/rules/test_systemctl.py', 17, 80, """"""
./tests/rules/test_systemctl.py:17:80: E501 line too long (93 > 79 characters)
./tests/rules/test_systemctl.py:18:80: E501 line too long (103 > 79 characters)
./tests/rules/test_whois.py:20:80: E501 line too long (89 > 79 characters)
./tests/rules/test_whois.py:22:80: E501 line too long (83 > 79 characters)
""""""),

    FixFileTest('py.test', '/home/thefuck/tests/rules/test_fix_file.py', 218, None, """"""
monkeypatch = <_pytest.monkeypatch.monkeypatch object at 0x7fdb76a25b38>
test = ('fish a.sh', '/tmp/fix-error/a.sh', 2, None, '', ""\\nfish: Unknown command 'foo'\\n/tmp/fix-error/a.sh (line 2): foo\\n                              ^\\n"")

    @pytest.mark.parametrize('test', tests)
    @pytest.mark.usefixtures('no_memoize')
    def test_get_new_command(monkeypatch, test):
>       mocker.patch('os.path.isfile', return_value=True)
E       NameError: name 'mocker' is not defined

/home/thefuck/tests/rules/test_fix_file.py:218: NameError
""""""),
)


@pytest.mark.parametrize('test', tests)
@pytest.mark.usefixtures('no_memoize')
def test_match(mocker, monkeypatch, test):
    mocker.patch('os.path.isfile', return_value=True)
    monkeypatch.setenv('EDITOR', 'dummy_editor')
    assert match(Command('', test.output))


@pytest.mark.parametrize('test', tests)
@pytest.mark.usefixtures('no_memoize')
def test_no_editor(mocker, monkeypatch, test):
    mocker.patch('os.path.isfile', return_value=True)
    if 'EDITOR' in os.environ:
        monkeypatch.delenv('EDITOR')

    assert not match(Command('', test.output))


@pytest.mark.parametrize('test', tests)
@pytest.mark.usefixtures('no_memoize')
def test_not_file(mocker, monkeypatch, test):
    mocker.patch('os.path.isfile', return_value=False)
    monkeypatch.setenv('EDITOR', 'dummy_editor')

    assert not match(Command('', test.output))


@pytest.mark.parametrize('test', tests)
@pytest.mark.usefixtures('no_memoize')
def test_get_new_command(mocker, monkeypatch, test):
    mocker.patch('os.path.isfile', return_value=True)
    monkeypatch.setenv('EDITOR', 'dummy_editor')


@pytest.mark.parametrize('test', tests)
@pytest.mark.usefixtures('no_memoize')
def test_get_new_command_with_settings(mocker, monkeypatch, test, settings):
    mocker.patch('os.path.isfile', return_value=True)
    monkeypatch.setenv('EDITOR', 'dummy_editor')

    cmd = Command(test.script, test.output)
    settings.fixcolcmd = '{editor} {file} +{line}:{col}'

    if test.col:
        assert (get_new_command(cmd) ==
                u'dummy_editor {} +{}:{} && {}'.format(test.file, test.line, test.col, test.script))
    else:
        assert (get_new_command(cmd) ==
                u'dummy_editor {} +{} && {}'.format(test.file, test.line, test.script))<EOS>"
"<BOS>import pytest
from thefuck.rules.git_add import match, get_new_command
from thefuck.types import Command


@pytest.fixture(autouse=True)
def path_exists(mocker):
    return mocker.patch('thefuck.rules.git_add.Path.exists',
                        return_value=True)


@pytest.fixture
def output(target):
    return (""error: pathspec '{}' did not match any ""
            'file(s) known to git.'.format(target))


@pytest.mark.parametrize('script, target', [
    ('git submodule update unknown', 'unknown'),
    ('git commit unknown', 'unknown')])
def test_match(output, script, target):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, target, exists', [
    ('git submodule update known', '', True),
    ('git commit known', '', True),
    ('git submodule update known', output, False)])
def test_not_match(path_exists, output, script, target, exists):
    path_exists.return_value = exists
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, target, new_command', [
    ('git submodule update unknown', 'unknown',
     'git add -- unknown && git submodule update unknown'),
    ('git commit unknown', 'unknown',
     'git add -- unknown && git commit unknown')])
def test_get_new_command(output, script, target, new_command):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.git_merge import match, get_new_command
from thefuck.types import Command


output = 'merge: local - not something we can merge\n\n' \
         'Did you mean this?\n\tremote/local'


def test_match():
    assert match(Command('git merge test', output))
    assert not match(Command('git merge master', ''))
    assert not match(Command('ls', output))


@pytest.mark.parametrize('command, new_command', [
    (Command('git merge local', output),
     'git merge remote/local'),
    (Command('git merge -m ""test"" local', output),
     'git merge -m ""test"" remote/local'),
    (Command('git merge -m ""test local"" local', output),
     'git merge -m ""test local"" remote/local')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.rm_root import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('rm -rf /', 'add --no-preserve-root'))


@pytest.mark.parametrize('command', [
    Command('ls', 'add --no-preserve-root'),
    Command('rm --no-preserve-root /', 'add --no-preserve-root'),
    Command('rm -rf /', '')])
def test_not_match(command):
    assert not match(command)


def test_get_new_command():
    assert (get_new_command(Command('rm -rf /', ''))
            == 'rm -rf / --no-preserve-root')<EOS>"
"<BOS>import os
import pytest
from thefuck.rules.ssh_known_hosts import match, get_new_command,\
    side_effect
from thefuck.types import Command


@pytest.fixture
def ssh_error(tmpdir):
    path = os.path.join(str(tmpdir), 'known_hosts')

    def reset(path):
        with open(path, 'w') as fh:
            lines = [
                '123.234.567.890 asdjkasjdakjsd\n'
                '98.765.432.321 ejioweojwejrosj\n'
                '111.222.333.444 qwepoiwqepoiss\n'
            ]
            fh.writelines(lines)

    def known_hosts(path):
        with open(path, 'r') as fh:
            return fh.readlines()

    reset(path)

    errormsg = u""""""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
b6:cb:07:34:c0:a0:94:d3:0d:69:83:31:f4:c5:20:9b.
Please contact your system administrator.
Add correct host key in {0} to get rid of this message.
Offending RSA key in {0}:2
RSA host key for {1} has changed and you have requested strict checking.
Host key verification failed."""""".format(path, '98.765.432.321')

    return errormsg, path, reset, known_hosts


def test_match(ssh_error):
    errormsg, _, _, _ = ssh_error
    assert match(Command('ssh', errormsg))
    assert match(Command('ssh', errormsg))
    assert match(Command('scp something something', errormsg))
    assert match(Command('scp something something', errormsg))
    assert not match(Command(errormsg, ''))
    assert not match(Command('notssh', errormsg))
    assert not match(Command('ssh', ''))


@pytest.mark.skipif(os.name == 'nt', reason='Skip if testing on Windows')
def test_side_effect(ssh_error):
    errormsg, path, reset, known_hosts = ssh_error
    command = Command('ssh user@host', errormsg)
    side_effect(command, None)
    expected = ['123.234.567.890 asdjkasjdakjsd\n', '111.222.333.444 qwepoiwqepoiss\n']
    assert known_hosts(path) == expected


def test_get_new_command(ssh_error, monkeypatch):
    errormsg, _, _, _ = ssh_error
    assert get_new_command(Command('ssh user@host', errormsg)) == 'ssh user@host'<EOS>"
"<BOS>import pytest
from thefuck.rules.sudo import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('output', [
    'Permission denied',
    'permission denied',
    ""npm ERR! Error: EACCES, unlink"",
    'requested operation requires superuser privilege',
    'need to be root',
    'need root',
    'must be root',
    'You don\'t have access to the history DB.',
    ""error: [Errno 13] Permission denied: '/usr/local/lib/python2.7/dist-packages/ipaddr.py'""])
def test_match(output):
    assert match(Command('', output))


def test_not_match():
    assert not match(Command('', ''))
    assert not match(Command('sudo ls', 'Permission denied'))


@pytest.mark.parametrize('before, after', [
    ('ls', 'sudo ls'),
    ('echo a > b', 'sudo sh -c ""echo a > b""'),
    ('echo ""a"" >> b', 'sudo sh -c ""echo \\""a\\"" >> b""'),
    ('mkdir && touch a', 'sudo sh -c ""mkdir && touch a""')])
def test_get_new_command(before, after):
    assert get_new_command(Command(before, '')) == after<EOS>"
"<BOS>import os
import pytest
import tarfile
from thefuck.rules.dirty_untar import match, get_new_command, side_effect, \
                                      tar_extensions  # noqa: E126
from thefuck.types import Command


@pytest.fixture
def tar_error(tmpdir):
    def fixture(filename):
        path = os.path.join(str(tmpdir), filename)

        def reset(path):
            os.mkdir('d')
            with tarfile.TarFile(path, 'w') as archive:
                for file in ('a', 'b', 'c', 'd/e'):
                    with open(file, 'w') as f:
                        f.write('*')

                    archive.add(file)

                    os.remove(file)

            with tarfile.TarFile(path, 'r') as archive:
                archive.extractall()

        os.chdir(str(tmpdir))
        reset(path)

        assert set(os.listdir('.')) == {filename, 'a', 'b', 'c', 'd'}
        assert set(os.listdir('./d')) == {'e'}

    return fixture


parametrize_extensions = pytest.mark.parametrize('ext', tar_extensions)

# (filename as typed by the user, unquoted filename, quoted filename as per shells.quote)
parametrize_filename = pytest.mark.parametrize('filename, unquoted, quoted', [
    ('foo{}', 'foo{}', 'foo{}'),
    ('""foo bar{}""', 'foo bar{}', ""'foo bar{}'"")])

parametrize_script = pytest.mark.parametrize('script, fixed', [
    ('tar xvf {}', 'mkdir -p {dir} && tar xvf {filename} -C {dir}'),
    ('tar -xvf {}', 'mkdir -p {dir} && tar -xvf {filename} -C {dir}'),
    ('tar --extract -f {}', 'mkdir -p {dir} && tar --extract -f {filename} -C {dir}')])


@parametrize_extensions
@parametrize_filename
@parametrize_script
def test_match(ext, tar_error, filename, unquoted, quoted, script, fixed):
    tar_error(unquoted.format(ext))
    assert match(Command(script.format(filename.format(ext)), ''))


@parametrize_extensions
@parametrize_filename
@parametrize_script
def test_side_effect(ext, tar_error, filename, unquoted, quoted, script, fixed):
    tar_error(unquoted.format(ext))
    side_effect(Command(script.format(filename.format(ext)), ''), None)
    assert set(os.listdir('.')) == {unquoted.format(ext), 'd'}


@parametrize_extensions
@parametrize_filename
@parametrize_script
def test_get_new_command(ext, tar_error, filename, unquoted, quoted, script, fixed):
    tar_error(unquoted.format(ext))
    assert (get_new_command(Command(script.format(filename.format(ext)), ''))
            == fixed.format(dir=quoted.format(''), filename=filename.format(ext)))<EOS>"
"<BOS>import pytest
from six import BytesIO
from thefuck.rules.gem_unknown_command import match, get_new_command
from thefuck.types import Command

output = '''
ERROR:  While executing gem ... (Gem::CommandLineError)
    Unknown command {}
'''

gem_help_commands_stdout = b'''
GEM commands are:

    build             Build a gem from a gemspec
    cert              Manage RubyGems certificates and signing settings
    check             Check a gem repository for added or missing files
    cleanup           Clean up old versions of installed gems
    contents          Display the contents of the installed gems
    dependency        Show the dependencies of an installed gem
    environment       Display information about the RubyGems environment
    fetch             Download a gem and place it in the current directory
    generate_index    Generates the index files for a gem server directory
    help              Provide help on the 'gem' command
    install           Install a gem into the local repository
    list              Display local gems whose name matches REGEXP
    lock              Generate a lockdown list of gems
    mirror            Mirror all gem files (requires rubygems-mirror)
    open              Open gem sources in editor
    outdated          Display all gems that need updates
    owner             Manage gem owners of a gem on the push server
    pristine          Restores installed gems to pristine condition from files
                      located in the gem cache
    push              Push a gem up to the gem server
    query             Query gem information in local or remote repositories
    rdoc              Generates RDoc for pre-installed gems
    search            Display remote gems whose name matches REGEXP
    server            Documentation and gem repository HTTP server
    sources           Manage the sources and cache file RubyGems uses to search
                      for gems
    specification     Display gem specification (in yaml)
    stale             List gems along with access times
    uninstall         Uninstall gems from the local repository
    unpack            Unpack an installed gem to the current directory
    update            Update installed gems to the latest version
    which             Find the location of a library file you can require
    yank              Remove a pushed gem from the index

For help on a particular command, use 'gem help COMMAND'.

Commands may be abbreviated, so long as they are unambiguous.
e.g. 'gem i rake' is short for 'gem install rake'.

'''


@pytest.fixture(autouse=True)
def gem_help_commands(mocker):
    patch = mocker.patch('subprocess.Popen')
    patch.return_value.stdout = BytesIO(gem_help_commands_stdout)
    return patch


@pytest.mark.parametrize('script, command', [
    ('gem isntall jekyll', 'isntall'),
    ('gem last --local', 'last')])
def test_match(script, command):
    assert match(Command(script, output.format(command)))


@pytest.mark.parametrize('script, output', [
    ('gem install jekyll', ''),
    ('git log', output.format('log'))])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, output, result', [
    ('gem isntall jekyll', output.format('isntall'), 'gem install jekyll'),
    ('gem last --local', output.format('last'), 'gem list --local')])
def test_get_new_command(script, output, result):
    new_command = get_new_command(Command(script, output))
    assert new_command[0] == result<EOS>"
"<BOS>import pytest
from thefuck.rules.git_branch_exists import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output(src_branch_name):
    return ""fatal: A branch named '{}' already exists."".format(src_branch_name)


@pytest.fixture
def new_command(branch_name):
    return [cmd.format(branch_name) for cmd in [
        'git branch -d {0} && git branch {0}',
        'git branch -d {0} && git checkout -b {0}',
        'git branch -D {0} && git branch {0}',
        'git branch -D {0} && git checkout -b {0}', 'git checkout {0}']]


@pytest.mark.parametrize('script, src_branch_name, branch_name', [
    ('git branch foo', 'foo', 'foo'),
    ('git checkout bar', 'bar', 'bar'),
    ('git checkout -b ""let\'s-push-this""', '""let\'s-push-this""', '""let\'s-push-this""')])
def test_match(output, script, branch_name):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', [
    'git branch foo',
    'git checkout bar',
    'git checkout -b ""let\'s-push-this""'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, src_branch_name, branch_name', [
    ('git branch foo', 'foo', 'foo'),
    ('git checkout bar', 'bar', 'bar'),
    ('git checkout -b ""let\'s-push-this""', ""let's-push-this"", ""let\\'s-push-this"")])
def test_get_new_command(output, new_command, script, src_branch_name, branch_name):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.git_pull_uncommitted_changes import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''error: Cannot pull with rebase: Your index contains uncommitted changes.'''


def test_match(output):
    assert match(Command('git pull', output))
    assert not match(Command('git pull', ''))
    assert not match(Command('ls', output))


def test_get_new_command(output):
    assert (get_new_command(Command('git pull', output))
            == ""git stash && git pull && git stash pop"")<EOS>"
"<BOS>import pytest
from thefuck.rules.sudo_command_from_user_path import match, get_new_command
from thefuck.types import Command


output = 'sudo: {}: command not found'


@pytest.fixture(autouse=True)
def which(mocker):
    return mocker.patch('thefuck.rules.sudo_command_from_user_path.which',
                        return_value='/usr/bin/app')


@pytest.mark.parametrize('script, output', [
    ('sudo npm install -g react-native-cli', output.format('npm')),
    ('sudo -u app appcfg update .', output.format('appcfg'))])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output, which_result', [
    ('npm --version', output.format('npm'), '/usr/bin/npm'),
    ('sudo npm --version', '', '/usr/bin/npm'),
    ('sudo npm --version', output.format('npm'), None)])
def test_not_match(which, script, output, which_result):
    which.return_value = which_result
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, output, result', [
    ('sudo npm install -g react-native-cli',
     output.format('npm'),
     'sudo env ""PATH=$PATH"" npm install -g react-native-cli'),
    ('sudo -u app appcfg update .',
     output.format('appcfg'),
     'sudo -u app env ""PATH=$PATH"" appcfg update .')])
def test_get_new_command(script, output, result):
    assert get_new_command(Command(script, output)) == result<EOS>"
"<BOS>import pytest
from thefuck.rules.composer_not_command import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def composer_not_command():
    # that weird spacing is part of the actual command output
    return (
        '\n'
        '\n'
        '                                    \n'
        '  [InvalidArgumentException]        \n'
        '  Command ""udpate"" is not defined.  \n'
        '  Did you mean this?                \n'
        '      update                        \n'
        '                                    \n'
        '\n'
        '\n'
    )


@pytest.fixture
def composer_not_command_one_of_this():
    # that weird spacing is part of the actual command output
    return (
        '\n'
        '\n'
        '                                   \n'
        '  [InvalidArgumentException]       \n'
        '  Command ""pdate"" is not defined.  \n'
        '  Did you mean one of these?       \n'
        '      selfupdate                   \n'
        '      self-update                  \n'
        '      update                       \n'
        '                                   \n'
        '\n'
        '\n'
    )


@pytest.fixture
def composer_require_instead_of_install():
    return 'Invalid argument package. Use ""composer require package"" instead to add packages to your composer.json.'


def test_match(composer_not_command, composer_not_command_one_of_this, composer_require_instead_of_install):
    assert match(Command('composer udpate',
                         composer_not_command))
    assert match(Command('composer pdate',
                         composer_not_command_one_of_this))
    assert match(Command('composer install package',
                         composer_require_instead_of_install))
    assert not match(Command('ls update', composer_not_command))


def test_get_new_command(composer_not_command, composer_not_command_one_of_this, composer_require_instead_of_install):
    assert (get_new_command(Command('composer udpate',
                                    composer_not_command))
            == 'composer update')
    assert (get_new_command(Command('composer pdate',
                                    composer_not_command_one_of_this))
            == 'composer selfupdate')
    assert (get_new_command(Command('composer install package',
                                    composer_require_instead_of_install))
            == 'composer require package')<EOS>"
"<BOS>import pytest
from thefuck.rules.git_rm_staged import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output(target):
    return ('error: the following file has changes staged in the index:\n    {}\n(use '
            '--cached to keep the file, or -f to force removal)').format(target)


@pytest.mark.parametrize('script, target', [
    ('git rm foo', 'foo'),
    ('git rm foo bar', 'bar')])
def test_match(output, script, target):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', ['git rm foo', 'git rm foo bar', 'git rm'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, target, new_command', [
    ('git rm foo', 'foo', ['git rm --cached foo', 'git rm -f foo']),
    ('git rm foo bar', 'bar', ['git rm --cached foo bar', 'git rm -f foo bar'])])
def test_get_new_command(output, script, target, new_command):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS># -*- coding: utf-8 -*-

import pytest
from thefuck.types import Command
from thefuck.rules.heroku_not_command import match, get_new_command


suggest_output = '''
 ▸    log is not a heroku command.
 ▸    Perhaps you meant logs?
 ▸    Run heroku _ to run heroku logs.
 ▸    Run heroku help for a list of available commands.'''


@pytest.mark.parametrize('cmd', ['log'])
def test_match(cmd):
    assert match(
        Command('heroku {}'.format(cmd), suggest_output))


@pytest.mark.parametrize('script, output', [
    ('cat log', suggest_output)])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('cmd, result', [
    ('log', 'heroku logs')])
def test_get_new_command(cmd, result):
    command = Command('heroku {}'.format(cmd), suggest_output)
    assert get_new_command(command) == result<EOS>"
"<BOS>import pytest
from thefuck.rules.no_such_file import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('mv foo bar/foo', ""mv: cannot move 'foo' to 'bar/foo': No such file or directory""),
    Command('mv foo bar/', ""mv: cannot move 'foo' to 'bar/': No such file or directory""),
])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('mv foo bar/', """"),
    Command('mv foo bar/foo', ""mv: permission denied""),
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('mv foo bar/foo', ""mv: cannot move 'foo' to 'bar/foo': No such file or directory""), 'mkdir -p bar && mv foo bar/foo'),
    (Command('mv foo bar/', ""mv: cannot move 'foo' to 'bar/': No such file or directory""), 'mkdir -p bar && mv foo bar/'),
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from mock import patch
from thefuck.rules import pacman
from thefuck.rules.pacman import match, get_new_command
from thefuck.types import Command


pacman_cmd = getattr(pacman, 'pacman', 'pacman')

PKGFILE_OUTPUT_SUDO = 'core/sudo 1.8.13-13/usr/bin/sudo'
PKGFILE_OUTPUT_CONVERT = 'extra/imagemagick 6.9.1.0-1\t/usr/bin/convert'

PKGFILE_OUTPUT_VIM = '''extra/gvim 7.4.712-1        \t/usr/bin/vim
extra/gvim-python3 7.4.712-1\t/usr/bin/vim
extra/vim 7.4.712-1         \t/usr/bin/vim
extra/vim-minimal 7.4.712-1 \t/usr/bin/vim
extra/vim-python3 7.4.712-1 \t/usr/bin/vim'''


@pytest.mark.skipif(not getattr(pacman, 'enabled_by_default', True),
                    reason='Skip if pacman is not available')
@pytest.mark.parametrize('command', [
    Command('vim', 'vim: command not found'),
    Command('sudo vim', 'sudo: vim: command not found')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, return_value', [
    (Command('vim', 'vim: command not found'), PKGFILE_OUTPUT_VIM),
    (Command('sudo vim', 'sudo: vim: command not found'), PKGFILE_OUTPUT_VIM)])
@patch('thefuck.specific.archlinux.subprocess')
@patch.multiple(pacman, create=True, pacman=pacman_cmd)
def test_match_mocked(subp_mock, command, return_value):
    subp_mock.check_output.return_value = return_value
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('vim', ''), Command('', ''),
    Command('sudo vim', ''), Command('', '')])
def test_not_match(command):
    assert not match(command)


sudo_vim_possibilities = ['{} -S extra/gvim && sudo vim',
                          '{} -S extra/gvim-python3 && sudo vim',
                          '{} -S extra/vim && sudo vim',
                          '{} -S extra/vim-minimal && sudo vim',
                          '{} -S extra/vim-python3 && sudo vim']
sudo_vim_possibilities = [s.format(pacman_cmd) for s in sudo_vim_possibilities]

vim_possibilities = ['{} -S extra/gvim && vim',
                     '{} -S extra/gvim-python3 && vim',
                     '{} -S extra/vim && vim',
                     '{} -S extra/vim-minimal && vim',
                     '{} -S extra/vim-python3 && vim']
vim_possibilities = [s.format(pacman_cmd) for s in vim_possibilities]


@pytest.mark.skipif(not getattr(pacman, 'enabled_by_default', True),
                    reason='Skip if pacman is not available')
@pytest.mark.parametrize('command, new_command', [
    (Command('vim', ''), vim_possibilities),
    (Command('sudo vim', ''), sudo_vim_possibilities),
    (Command('convert', ''), ['{} -S extra/imagemagick && convert'.format(pacman_cmd)]),
    (Command('sudo convert', ''), ['{} -S extra/imagemagick && sudo convert'.format(pacman_cmd)])])
def test_get_new_command(command, new_command, mocker):
    assert get_new_command(command) == new_command


@pytest.mark.parametrize('command, new_command, return_value', [
    (Command('vim', ''), vim_possibilities, PKGFILE_OUTPUT_VIM),
    (Command('sudo vim', ''), sudo_vim_possibilities, PKGFILE_OUTPUT_VIM),
    (Command('convert', ''), ['{} -S extra/imagemagick && convert'.format(pacman_cmd)], PKGFILE_OUTPUT_CONVERT),
    (Command('sudo', ''), ['{} -S core/sudo && sudo'.format(pacman_cmd)], PKGFILE_OUTPUT_SUDO),
    (Command('sudo convert', ''), ['{} -S extra/imagemagick && sudo convert'.format(pacman_cmd)], PKGFILE_OUTPUT_CONVERT)])
@patch('thefuck.specific.archlinux.subprocess')
@patch.multiple(pacman, create=True, pacman=pacman_cmd)
def test_get_new_command_mocked(subp_mock, command, new_command, return_value):
    subp_mock.check_output.return_value = return_value
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.prove_recursively import match, get_new_command
from thefuck.types import Command


output = '''Files=0, Tests=0,  0 wallclock secs ( 0.00 usr +  0.00 sys =  0.00 CPU)
Result: NOTESTS'''


@pytest.fixture
def isdir(mocker):
    return mocker.patch('thefuck.rules.prove_recursively'
                        '.os.path.isdir')


@pytest.mark.parametrize('script, output', [
    ('prove -lv t', output),
    ('prove app/t', output)])
def test_match(isdir, script, output):
    isdir.return_value = True
    command = Command(script, output)
    assert match(command)


@pytest.mark.parametrize('script, output, isdir_result', [
    ('prove -lv t', output, False),
    ('prove -r t', output, True),
    ('prove --recurse t', output, True)])
def test_not_match(isdir, script, output, isdir_result):
    isdir.return_value = isdir_result
    command = Command(script, output)
    assert not match(command)


@pytest.mark.parametrize('before, after', [
    ('prove -lv t', 'prove -r -lv t'),
    ('prove t', 'prove -r t')])
def test_get_new_command(before, after):
    command = Command(before, output)
    assert get_new_command(command) == after<EOS>"
"<BOS>from io import BytesIO

import pytest

from thefuck.rules.yum_invalid_operation import match, get_new_command, _get_operations
from thefuck.types import Command

yum_help_text = '''Loaded plugins: extras_suggestions, langpacks, priorities, update-motd
Usage: yum [options] COMMAND

List of Commands:

check          Check for problems in the rpmdb
check-update   Check for available package updates
clean          Remove cached data
deplist        List a package's dependencies
distribution-synchronization Synchronize installed packages to the latest available versions
downgrade      downgrade a package
erase          Remove a package or packages from your system
fs             Acts on the filesystem data of the host, mainly for removing docs/lanuages for minimal hosts.
fssnapshot     Creates filesystem snapshots, or lists/deletes current snapshots.
groups         Display, or use, the groups information
help           Display a helpful usage message
history        Display, or use, the transaction history
info           Display details about a package or group of packages
install        Install a package or packages on your system
langavailable  Check available languages
langinfo       List languages information
langinstall    Install appropriate language packs for a language
langlist       List installed languages
langremove     Remove installed language packs for a language
list           List a package or groups of packages
load-transaction load a saved transaction from filename
makecache      Generate the metadata cache
provides       Find what package provides the given value
reinstall      reinstall a package
repo-pkgs      Treat a repo. as a group of packages, so we can install/remove all of them
repolist       Display the configured software repositories
search         Search package details for the given string
shell          Run an interactive yum shell
swap           Simple way to swap packages, instead of using shell
update         Update a package or packages on your system
update-minimal Works like upgrade, but goes to the 'newest' package match which fixes a problem that affects your system
updateinfo     Acts on repository update information
upgrade        Update packages taking obsoletes into account
version        Display a version for the machine and/or available repos.


Options:
  -h, --help            show this help message and exit
  -t, --tolerant        be tolerant of errors
  -C, --cacheonly       run entirely from system cache, don't update cache
  -c [config file], --config=[config file]
                        config file location
  -R [minutes], --randomwait=[minutes]
                        maximum command wait time
  -d [debug level], --debuglevel=[debug level]
                        debugging output level
  --showduplicates      show duplicates, in repos, in list/search commands
  -e [error level], --errorlevel=[error level]
                        error output level
  --rpmverbosity=[debug level name]
                        debugging output level for rpm
  -q, --quiet           quiet operation
  -v, --verbose         verbose operation
  -y, --assumeyes       answer yes for all questions
  --assumeno            answer no for all questions
  --version             show Yum version and exit
  --installroot=[path]  set install root
  --enablerepo=[repo]   enable one or more repositories (wildcards allowed)
  --disablerepo=[repo]  disable one or more repositories (wildcards allowed)
  -x [package], --exclude=[package]
                        exclude package(s) by name or glob
  --disableexcludes=[repo]
                        disable exclude from main, for a repo or for
                        everything
  --disableincludes=[repo]
                        disable includepkgs for a repo or for everything
  --obsoletes           enable obsoletes processing during updates
  --noplugins           disable Yum plugins
  --nogpgcheck          disable gpg signature checking
  --disableplugin=[plugin]
                        disable plugins by name
  --enableplugin=[plugin]
                        enable plugins by name
  --skip-broken         skip packages with depsolving problems
  --color=COLOR         control whether color is used
  --releasever=RELEASEVER
                        set value of $releasever in yum config and repo files
  --downloadonly        don't update, just download
  --downloaddir=DLDIR   specifies an alternate directory to store packages
  --setopt=SETOPTS      set arbitrary config and repo options
  --bugfix              Include bugfix relevant packages, in updates
  --security            Include security relevant packages, in updates
  --advisory=ADVS, --advisories=ADVS
                        Include packages needed to fix the given advisory, in
                        updates
  --bzs=BZS             Include packages needed to fix the given BZ, in
                        updates
  --cves=CVES           Include packages needed to fix the given CVE, in
                        updates
  --sec-severity=SEVS, --secseverity=SEVS
                        Include security relevant packages matching the
                        severity, in updates

  Plugin Options:
    --samearch-priorities
                        Priority-exclude packages based on name + arch
'''
yum_unsuccessful_search_text = '''Warning: No matches found for: {}
No matches found
'''
yum_successful_vim_search_text = '''================================================== N/S matched: vim ===================================================
protobuf-vim.x86_64 : Vim syntax highlighting for Google Protocol Buffers descriptions
vim-X11.x86_64 : The VIM version of the vi editor for the X Window System - GVim
vim-common.x86_64 : The common files needed by any version of the VIM editor
vim-enhanced.x86_64 : A version of the VIM editor which includes recent enhancements
vim-filesystem.x86_64 : VIM filesystem layout
vim-filesystem.noarch : VIM filesystem layout
vim-minimal.x86_64 : A minimal version of the VIM editor

  Name and summary matches only, use ""search all"" for everything.
'''

yum_invalid_op_text = '''Loaded plugins: extras_suggestions, langpacks, priorities, update-motd
No such command: {}. Please use /usr/bin/yum --help
'''

yum_operations = [
    'check', 'check-update', 'clean', 'deplist', 'distribution-synchronization', 'downgrade', 'erase', 'fs',
    'fssnapshot', 'groups', 'help', 'history', 'info', 'install', 'langavailable', 'langinfo', 'langinstall',
    'langlist', 'langremove', 'list', 'load-transaction', 'makecache', 'provides', 'reinstall', 'repo-pkgs', 'repolist',
    'search', 'shell', 'swap', 'update', 'update-minimal', 'updateinfo', 'upgrade', 'version', ]


@pytest.mark.parametrize('command', [
    'saerch', 'uninstall',
])
def test_match(command):
    assert match(Command('yum {}'.format(command), yum_invalid_op_text.format(command)))


@pytest.mark.parametrize('command, output', [
    ('vim', ''),
    ('yum', yum_help_text,),
    ('yum help', yum_help_text,),
    ('yum search asdf', yum_unsuccessful_search_text.format('asdf'),),
    ('yum search vim', yum_successful_vim_search_text)
])
def test_not_match(command, output):
    assert not match(Command(command, output))


@pytest.fixture
def yum_help(mocker):
    mock = mocker.patch('subprocess.Popen')
    mock.return_value.stdout = BytesIO(bytes(yum_help_text.encode('utf-8')))
    return mock


@pytest.mark.usefixtures('no_memoize', 'yum_help')
def test_get_operations():
    assert _get_operations() == yum_operations


@pytest.mark.usefixtures('no_memoize', 'yum_help')
@pytest.mark.parametrize('script, output, result', [
    ('yum uninstall', yum_invalid_op_text.format('uninstall'), 'yum remove',),
    ('yum saerch asdf', yum_invalid_op_text.format('saerch'), 'yum search asdf',),
    ('yum hlep', yum_invalid_op_text.format('hlep'), 'yum help',),
])
def test_get_new_command(script, output, result):
    assert get_new_command(Command(script, output))[0] == result<EOS>"
"<BOS>import pytest
from thefuck.rules.apt_get_search import get_new_command, match
from thefuck.types import Command


def test_match():
    assert match(Command('apt-get search foo', ''))


@pytest.mark.parametrize('command', [
    Command('apt-cache search foo', ''),
    Command('aptitude search foo', ''),
    Command('apt search foo', ''),
    Command('apt-get install foo', ''),
    Command('apt-get source foo', ''),
    Command('apt-get clean', ''),
    Command('apt-get remove', ''),
    Command('apt-get update', '')
])
def test_not_match(command):
    assert not match(command)


def test_get_new_command():
    new_command = get_new_command(Command('apt-get search foo', ''))
    assert new_command == 'apt-cache search foo'<EOS>"
"<BOS># -*- coding: utf-8 -*-

import os
import pytest
import zipfile
from thefuck.rules.dirty_unzip import match, get_new_command, side_effect
from thefuck.types import Command
from unicodedata import normalize


@pytest.fixture
def zip_error(tmpdir):
    def zip_error_inner(filename):
        path = os.path.join(str(tmpdir), filename)

        def reset(path):
            with zipfile.ZipFile(path, 'w') as archive:
                archive.writestr('a', '1')
                archive.writestr('b', '2')
                archive.writestr('c', '3')

                archive.writestr('d/e', '4')

                archive.extractall()

        os.chdir(str(tmpdir))
        reset(path)

        dir_list = os.listdir(u'.')
        if filename not in dir_list:
            filename = normalize('NFD', filename)

        assert set(dir_list) == {filename, 'a', 'b', 'c', 'd'}
        assert set(os.listdir('./d')) == {'e'}
    return zip_error_inner


@pytest.mark.parametrize('script,filename', [
    (u'unzip café', u'café.zip'),
    (u'unzip café.zip', u'café.zip'),
    (u'unzip foo', u'foo.zip'),
    (u'unzip foo.zip', u'foo.zip')])
def test_match(zip_error, script, filename):
    zip_error(filename)
    assert match(Command(script, ''))


@pytest.mark.parametrize('script,filename', [
    (u'unzip café', u'café.zip'),
    (u'unzip café.zip', u'café.zip'),
    (u'unzip foo', u'foo.zip'),
    (u'unzip foo.zip', u'foo.zip')])
def test_side_effect(zip_error, script, filename):
    zip_error(filename)
    side_effect(Command(script, ''), None)

    dir_list = os.listdir(u'.')
    if filename not in set(dir_list):
        filename = normalize('NFD', filename)

    assert set(dir_list) == {filename, 'd'}


@pytest.mark.parametrize('script,fixed,filename', [
    (u'unzip café', u""unzip café -d 'café'"", u'café.zip'),
    (u'unzip foo', u'unzip foo -d foo', u'foo.zip'),
    (u""unzip 'foo bar.zip'"", u""unzip 'foo bar.zip' -d 'foo bar'"", u'foo.zip'),
    (u'unzip foo.zip', u'unzip foo.zip -d foo', u'foo.zip')])
def test_get_new_command(zip_error, script, fixed, filename):
    zip_error(filename)
    assert get_new_command(Command(script, '')) == fixed<EOS>"
"<BOS>import pytest

from thefuck.rules.git_branch_0flag import get_new_command, match
from thefuck.types import Command


@pytest.fixture
def output_branch_exists():
    return ""fatal: A branch named 'bar' already exists.""


@pytest.mark.parametrize(
    ""script"",
    [
        ""git branch 0a"",
        ""git branch 0d"",
        ""git branch 0f"",
        ""git branch 0r"",
        ""git branch 0v"",
        ""git branch 0d foo"",
        ""git branch 0D foo"",
    ],
)
def test_match(script, output_branch_exists):
    assert match(Command(script, output_branch_exists))


@pytest.mark.parametrize(
    ""script"",
    [
        ""git branch -a"",
        ""git branch -r"",
        ""git branch -v"",
        ""git branch -d foo"",
        ""git branch -D foo"",
    ],
)
def test_not_match(script, output_branch_exists):
    assert not match(Command(script, """"))


@pytest.mark.parametrize(
    ""script, new_command"",
    [
        (""git branch 0a"", ""git branch -D 0a && git branch -a""),
        (""git branch 0v"", ""git branch -D 0v && git branch -v""),
        (""git branch 0d foo"", ""git branch -D 0d && git branch -d foo""),
        (""git branch 0D foo"", ""git branch -D 0D && git branch -D foo""),
        (""git branch 0l 'maint-*'"", ""git branch -D 0l && git branch -l 'maint-*'""),
        (""git branch 0u upstream"", ""git branch -D 0u && git branch -u upstream""),
    ],
)
def test_get_new_command_branch_exists(script, output_branch_exists, new_command):
    assert get_new_command(Command(script, output_branch_exists)) == new_command


@pytest.fixture
def output_not_valid_object():
    return ""fatal: Not a valid object name: 'bar'.""


@pytest.mark.parametrize(
    ""script, new_command"",
    [
        (""git branch 0l 'maint-*'"", ""git branch -l 'maint-*'""),
        (""git branch 0u upstream"", ""git branch -u upstream""),
    ],
)
def test_get_new_command_not_valid_object(script, output_not_valid_object, new_command):
    assert get_new_command(Command(script, output_not_valid_object)) == new_command<EOS>"
"<BOS>import pytest
from io import BytesIO
from thefuck.rules.gradle_no_task import match, get_new_command
from thefuck.types import Command

gradle_tasks = b'''
:tasks

------------------------------------------------------------
All tasks runnable from root project
------------------------------------------------------------

Android tasks
-------------
androidDependencies - Displays the Android dependencies of the project.
signingReport - Displays the signing info for each variant.
sourceSets - Prints out all the source sets defined in this project.

Build tasks
-----------
assemble - Assembles all variants of all applications and secondary packages.
assembleAndroidTest - Assembles all the Test applications.
assembleDebug - Assembles all Debug builds.
assembleRelease - Assembles all Release builds.
build - Assembles and tests this project.
buildDependents - Assembles and tests this project and all projects that depend on it.
buildNeeded - Assembles and tests this project and all projects it depends on.
compileDebugAndroidTestSources
compileDebugSources
compileDebugUnitTestSources
compileReleaseSources
compileReleaseUnitTestSources
extractDebugAnnotations - Extracts Android annotations for the debug variant into the archive file
extractReleaseAnnotations - Extracts Android annotations for the release variant into the archive file
mockableAndroidJar - Creates a version of android.jar that's suitable for unit tests.

Build Setup tasks
-----------------
init - Initializes a new Gradle build. [incubating]
wrapper - Generates Gradle wrapper files. [incubating]

Help tasks
----------
components - Displays the components produced by root project 'org.rerenderer_example.snake'. [incubating]
dependencies - Displays all dependencies declared in root project 'org.rerenderer_example.snake'.
dependencyInsight - Displays the insight into a specific dependency in root project 'org.rerenderer_example.snake'.
help - Displays a help message.
model - Displays the configuration model of root project 'org.rerenderer_example.snake'. [incubating]
projects - Displays the sub-projects of root project 'org.rerenderer_example.snake'.
properties - Displays the properties of root project 'org.rerenderer_example.snake'.
tasks - Displays the tasks runnable from root project 'org.rerenderer_example.snake' (some of the displayed tasks may belong to subprojects).

Install tasks
-------------
installDebug - Installs the Debug build.
installDebugAndroidTest - Installs the android (on device) tests for the Debug build.
installRelease - Installs the Release build.
uninstallAll - Uninstall all applications.
uninstallDebug - Uninstalls the Debug build.
uninstallDebugAndroidTest - Uninstalls the android (on device) tests for the Debug build.
uninstallRelease - Uninstalls the Release build.

React tasks
-----------
bundleDebugJsAndAssets - bundle JS and assets for Debug.
bundleReleaseJsAndAssets - bundle JS and assets for Release.

Verification tasks
------------------
check - Runs all checks.
clean - Deletes the build directory.
connectedAndroidTest - Installs and runs instrumentation tests for all flavors on connected devices.
connectedCheck - Runs all device checks on currently connected devices.
connectedDebugAndroidTest - Installs and runs the tests for debug on connected devices.
deviceAndroidTest - Installs and runs instrumentation tests using all Device Providers.
deviceCheck - Runs all device checks using Device Providers and Test Servers.
lint - Runs lint on all variants.
lintDebug - Runs lint on the Debug build.
lintRelease - Runs lint on the Release build.
test - Run unit tests for all variants.
testDebugUnitTest - Run unit tests for the debug build.
testReleaseUnitTest - Run unit tests for the release build.

Other tasks
-----------
assembleDefault
copyDownloadableDepsToLibs
jarDebugClasses
jarReleaseClasses

To see all tasks and more detail, run gradlew tasks --all

To see more detail about a task, run gradlew help --task <task>

BUILD SUCCESSFUL

Total time: 1.936 secs
'''

output_not_found = '''

FAILURE: Build failed with an exception.

* What went wrong:
Task '{}' not found in root project 'org.rerenderer_example.snake'.

* Try:
Run gradlew tasks to get a list of available tasks. Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.
'''.format

output_ambiguous = '''

FAILURE: Build failed with an exception.

* What went wrong:
Task '{}' is ambiguous in root project 'org.rerenderer_example.snake'. Candidates are: 'assembleRelease', 'assembleReleaseUnitTest'.

* Try:
Run gradlew tasks to get a list of available tasks. Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.
'''.format


@pytest.fixture(autouse=True)
def tasks(mocker):
    patch = mocker.patch('thefuck.rules.gradle_no_task.Popen')
    patch.return_value.stdout = BytesIO(gradle_tasks)
    return patch


@pytest.mark.parametrize('command', [
    Command('./gradlew assembler', output_ambiguous('assembler')),
    Command('./gradlew instar', output_not_found('instar')),
    Command('gradle assembler', output_ambiguous('assembler')),
    Command('gradle instar', output_not_found('instar'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('./gradlew assemble', ''),
    Command('gradle assemble', ''),
    Command('npm assembler', output_ambiguous('assembler')),
    Command('npm instar', output_not_found('instar'))])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, result', [
    (Command('./gradlew assembler', output_ambiguous('assembler')),
     './gradlew assemble'),
    (Command('./gradlew instardebug', output_not_found('instardebug')),
     './gradlew installDebug'),
    (Command('gradle assembler', output_ambiguous('assembler')),
     'gradle assemble'),
    (Command('gradle instardebug', output_not_found('instardebug')),
     'gradle installDebug')])
def test_get_new_command(command, result):
    assert get_new_command(command)[0] == result<EOS>"
"<BOS>import pytest
from thefuck.rules.gradle_wrapper import match, get_new_command
from thefuck.types import Command


@pytest.fixture(autouse=True)
def exists(mocker):
    return mocker.patch('thefuck.rules.gradle_wrapper.os.path.isfile',
                        return_value=True)


@pytest.mark.parametrize('command', [
    Command('gradle tasks', 'gradle: not found'),
    Command('gradle build', 'gradle: not found')])
def test_match(mocker, command):
    mocker.patch('thefuck.rules.gradle_wrapper.which', return_value=None)

    assert match(command)


@pytest.mark.parametrize('command, gradlew, which', [
    (Command('gradle tasks', 'gradle: not found'), False, None),
    (Command('gradle tasks', 'command not found'), True, '/usr/bin/gradle'),
    (Command('npm tasks', 'npm: not found'), True, None)])
def test_not_match(mocker, exists, command, gradlew, which):
    mocker.patch('thefuck.rules.gradle_wrapper.which', return_value=which)
    exists.return_value = gradlew

    assert not match(command)


@pytest.mark.parametrize('script, result', [
    ('gradle assemble', './gradlew assemble'),
    ('gradle --help', './gradlew --help'),
    ('gradle build -c', './gradlew build -c')])
def test_get_new_command(script, result):
    command = Command(script, '')
    assert get_new_command(command) == result<EOS>"
"<BOS>import pytest
from thefuck.rules.tsuru_login import match, get_new_command
from thefuck.types import Command


error_msg = (
    ""Error: you're not authenticated or your session has expired."",
    (""You're not authenticated or your session has expired. ""
     ""Please use \""login\"" command for authentication.""),
)


@pytest.mark.parametrize('command', [
    Command('tsuru app-shell', error_msg[0]),
    Command('tsuru app-log -f', error_msg[1]),
])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('tsuru', ''),
    Command('tsuru app-restart', 'Error: unauthorized'),
    Command('tsuru app-log -f', 'Error: unparseable data'),
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('tsuru app-shell', error_msg[0]),
     'tsuru login && tsuru app-shell'),
    (Command('tsuru app-log -f', error_msg[1]),
     'tsuru login && tsuru app-log -f'),
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.workon_doesnt_exists import match, get_new_command
from thefuck.types import Command


@pytest.fixture(autouse=True)
def envs(mocker):
    return mocker.patch(
        'thefuck.rules.workon_doesnt_exists._get_all_environments',
        return_value=['thefuck', 'code_view'])


@pytest.mark.parametrize('script', [
    'workon tehfuck', 'workon code-view', 'workon new-env'])
def test_match(script):
    assert match(Command(script, ''))


@pytest.mark.parametrize('script', [
    'workon thefuck', 'workon code_view', 'work on tehfuck'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, result', [
    ('workon tehfuck', 'workon thefuck'),
    ('workon code-view', 'workon code_view'),
    ('workon zzzz', 'mkvirtualenv zzzz')])
def test_get_new_command(script, result):
    assert get_new_command(Command(script, ''))[0] == result<EOS>"
"<BOS>import pytest
from thefuck.rules.git_branch_delete_checked_out import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return ""error: Cannot delete branch 'foo' checked out at '/bar/foo'""


@pytest.mark.parametrize(""script"", [""git branch -d foo"", ""git branch -D foo""])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize(""script"", [""git branch -d foo"", ""git branch -D foo""])
def test_not_match(script):
    assert not match(Command(script, ""Deleted branch foo (was a1b2c3d).""))


@pytest.mark.parametrize(
    ""script, new_command"",
    [
        (""git branch -d foo"", ""git checkout master && git branch -D foo""),
        (""git branch -D foo"", ""git checkout master && git branch -D foo""),
    ],
)
def test_get_new_command(script, new_command, output):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS>import pytest

from thefuck.rules.git_lfs_mistype import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def mistype_response():
    return """"""
Error: unknown command ""evn"" for ""git-lfs""

Did you mean this?
        env
        ext

Run 'git-lfs --help' for usage.
    """"""


def test_match(mistype_response):
    assert match(Command('git lfs evn', mistype_response))
    err_response = 'bash: git: command not found'
    assert not match(Command('git lfs env', err_response))
    assert not match(Command('docker lfs env', mistype_response))


def test_get_new_command(mistype_response):
    assert (get_new_command(Command('git lfs evn', mistype_response))
            == ['git lfs env', 'git lfs ext'])<EOS>"
"<BOS>from thefuck.rules.ls_lah import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('ls', ''))
    assert match(Command('ls file.py', ''))
    assert match(Command('ls /opt', ''))
    assert not match(Command('ls -lah /opt', ''))
    assert not match(Command('pacman -S binutils', ''))
    assert not match(Command('lsof', ''))


def test_get_new_command():
    assert get_new_command(Command('ls file.py', '')) == 'ls -lah file.py'
    assert get_new_command(Command('ls', '')) == 'ls -lah'<EOS>"
"<BOS>import pytest
from thefuck.rules.pacman_invalid_option import get_new_command, match
from thefuck.types import Command

good_output = """"""community/shared_meataxe 1.0-3
    A set of programs for working with matrix representations over finite fields
""""""

bad_output = ""error: invalid option '-""


@pytest.mark.parametrize(""option"", ""SURQFDVT"")
def test_not_match_good_output(option):
    assert not match(Command(""pacman -{}s meat"".format(option), good_output))


@pytest.mark.parametrize(""option"", ""azxcbnm"")
def test_not_match_bad_output(option):
    assert not match(Command(""pacman -{}v meat"".format(option), bad_output))


@pytest.mark.parametrize(""option"", ""surqfdvt"")
def test_match(option):
    assert match(Command(""pacman -{}v meat"".format(option), bad_output))


@pytest.mark.parametrize(""option"", ""surqfdvt"")
def test_get_new_command(option):
    new_command = get_new_command(Command(""pacman -{}v meat"".format(option), """"))
    assert new_command == ""pacman -{}v meat"".format(option.upper())<EOS>"
"<BOS>import pytest

from thefuck.rules.python_module_error import get_new_command, match
from thefuck.types import Command


@pytest.fixture
def module_error_output(filename, module_name):
    return """"""Traceback (most recent call last):
  File ""{0}"", line 1, in <module>
    import {1}
ModuleNotFoundError: No module named '{1}'"""""".format(
        filename, module_name
    )


@pytest.mark.parametrize(
    ""test"",
    [
        Command(""python hello_world.py"", ""Hello World""),
        Command(
            ""./hello_world.py"",
            """"""Traceback (most recent call last):
  File ""hello_world.py"", line 1, in <module>
    pritn(""Hello World"")
NameError: name 'pritn' is not defined"""""",
        ),
    ],
)
def test_not_match(test):
    assert not match(test)


positive_tests = [
    (
        ""python some_script.py"",
        ""some_script.py"",
        ""more_itertools"",
        ""pip install more_itertools && python some_script.py"",
    ),
    (
        ""./some_other_script.py"",
        ""some_other_script.py"",
        ""a_module"",
        ""pip install a_module && ./some_other_script.py"",
    ),
]


@pytest.mark.parametrize(
    ""script, filename, module_name, corrected_script"", positive_tests
)
def test_match(script, filename, module_name, corrected_script, module_error_output):
    assert match(Command(script, module_error_output))


@pytest.mark.parametrize(
    ""script, filename, module_name, corrected_script"", positive_tests
)
def test_get_new_command(
    script, filename, module_name, corrected_script, module_error_output
):
    assert get_new_command(Command(script, module_error_output)) == corrected_script<EOS>"
"<BOS>import pytest
from thefuck.rules.quotation_marks import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command(""git commit -m \'My Message\"""", ''),
    Command(""git commit -am \""Mismatched Quotation Marks\'"", ''),
    Command(""echo \""hello\'"", '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command(""git commit -m \'My Message\"""", ''), ""git commit -m \""My Message\""""),
    (Command(""git commit -am \""Mismatched Quotation Marks\'"", ''), ""git commit -am \""Mismatched Quotation Marks\""""),
    (Command(""echo \""hello\'"", ''), ""echo \""hello\"""")])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.adb_unknown_command import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''Android Debug Bridge version 1.0.31

 -d                            - directs command to the only connected USB device
                                 returns an error if more than one USB device is present.
 -e                            - directs command to the only running emulator.
                                 returns an error if more than one emulator is running.
 -s <specific device>          - directs command to the device or emulator with the given
                                 serial number or qualifier. Overrides ANDROID_SERIAL
                                 environment variable.
'''


@pytest.mark.parametrize('script', [
    ('adb lgcat'),
    ('adb puhs')])
def test_match(output, script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', [
    'git branch foo',
    'abd push'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, new_command', [
    ('adb puhs test.bin /sdcard/test.bin', 'adb push test.bin /sdcard/test.bin'),
    ('adb -s 1111 logcta', 'adb -s 1111 logcat'),
    ('adb -P 666 pulll /sdcard/test.bin', 'adb -P 666 pull /sdcard/test.bin'),
    ('adb -d logcatt', 'adb -d logcat'),
    ('adb -e reboott', 'adb -e reboot')])
def test_get_new_command(script, output, new_command):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.cargo_no_command import match, get_new_command
from thefuck.types import Command


no_such_subcommand_old = """"""No such subcommand

        Did you mean `build`?
""""""

no_such_subcommand = """"""error: no such subcommand

\tDid you mean `build`?
""""""


@pytest.mark.parametrize('command', [
    Command('cargo buid', no_such_subcommand_old),
    Command('cargo buils', no_such_subcommand)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('cargo buid', no_such_subcommand_old), 'cargo build'),
    (Command('cargo buils', no_such_subcommand), 'cargo build')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.git_push import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output(branch_name):
    if not branch_name:
        return ''
    return '''fatal: The current branch {} has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin {}

'''.format(branch_name, branch_name)


@pytest.fixture
def output_bitbucket():
    return '''Total 0 (delta 0), reused 0 (delta 0)
remote:
remote: Create pull request for feature/set-upstream:
remote:   https://bitbucket.org/set-upstream
remote:
To git@bitbucket.org:test.git
   e5e7fbb..700d998  feature/set-upstream -> feature/set-upstream
Branch feature/set-upstream set up to track remote branch feature/set-upstream from origin.
'''


@pytest.mark.parametrize('script, branch_name', [
    ('git push', 'master'),
    ('git push origin', 'master')])
def test_match(output, script, branch_name):
    assert match(Command(script, output))


def test_match_bitbucket(output_bitbucket):
    assert not match(Command('git push origin', output_bitbucket))


@pytest.mark.parametrize('script, branch_name', [
    ('git push master', None),
    ('ls', 'master')])
def test_not_match(output, script, branch_name):
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, branch_name, new_command', [
    ('git push', 'master',
     'git push --set-upstream origin master'),
    ('git push master', 'master',
     'git push --set-upstream origin master'),
    ('git push -u', 'master',
     'git push --set-upstream origin master'),
    ('git push -u origin', 'master',
     'git push --set-upstream origin master'),
    ('git push origin', 'master',
     'git push --set-upstream origin master'),
    ('git push --set-upstream origin', 'master',
     'git push --set-upstream origin master'),
    ('git push --quiet', 'master',
     'git push --set-upstream origin master --quiet'),
    ('git push --quiet origin', 'master',
     'git push --set-upstream origin master --quiet'),
    ('git -c test=test push --quiet origin', 'master',
     'git -c test=test push --set-upstream origin master --quiet'),
    ('git push', ""test's"",
     ""git push --set-upstream origin test\\'s""),
    ('git push --force', 'master',
     'git push --set-upstream origin master --force'),
    ('git push --force-with-lease', 'master',
     'git push --set-upstream origin master --force-with-lease')])
def test_get_new_command(output, script, branch_name, new_command):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.pip_unknown_command import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def pip_unknown_cmd_without_recommend():
    return '''ERROR: unknown command ""i""'''


@pytest.fixture
def broken():
    return 'instatl'


@pytest.fixture
def suggested():
    return 'install'


@pytest.fixture
def pip_unknown_cmd(broken, suggested):
    return 'ERROR: unknown command ""{}"" - maybe you meant ""{}""'.format(broken, suggested)


def test_match(pip_unknown_cmd, pip_unknown_cmd_without_recommend):
    assert match(Command('pip instatl', pip_unknown_cmd))
    assert not match(Command('pip i',
                             pip_unknown_cmd_without_recommend))


@pytest.mark.parametrize('script, broken, suggested, new_cmd', [
    ('pip un+install thefuck', 'un+install', 'uninstall', 'pip uninstall thefuck'),
    ('pip instatl', 'instatl', 'install', 'pip install')])
def test_get_new_command(script, new_cmd, pip_unknown_cmd):
    assert get_new_command(Command(script,
                                   pip_unknown_cmd)) == new_cmd<EOS>"
"<BOS>import pytest
from thefuck.rules.mkdir_p import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('mkdir foo/bar/baz', 'mkdir: foo/bar: No such file or directory'),
    Command('./bin/hdfs dfs -mkdir foo/bar/baz', 'mkdir: `foo/bar/baz\': No such file or directory'),
    Command('hdfs dfs -mkdir foo/bar/baz', 'mkdir: `foo/bar/baz\': No such file or directory')
])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('mkdir foo/bar/baz', ''),
    Command('mkdir foo/bar/baz', 'foo bar baz'),
    Command('hdfs dfs -mkdir foo/bar/baz', ''),
    Command('./bin/hdfs dfs -mkdir foo/bar/baz', ''),
    Command('', ''),
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('mkdir foo/bar/baz', ''), 'mkdir -p foo/bar/baz'),
    (Command('hdfs dfs -mkdir foo/bar/baz', ''), 'hdfs dfs -mkdir -p foo/bar/baz'),
    (Command('./bin/hdfs dfs -mkdir foo/bar/baz', ''), './bin/hdfs dfs -mkdir -p foo/bar/baz'),
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from io import BytesIO
from thefuck.rules.npm_run_script import match, get_new_command
from thefuck.types import Command

output = '''
Usage: npm <command>

where <command> is one of:
    access, add-user, adduser, apihelp, author, bin, bugs, c,
    cache, completion, config, ddp, dedupe, deprecate, dist-tag,
    dist-tags, docs, edit, explore, faq, find, find-dupes, get,
    help, help-search, home, i, info, init, install, issues, la,
    link, list, ll, ln, login, logout, ls, outdated, owner,
    pack, ping, prefix, prune, publish, r, rb, rebuild, remove,
    repo, restart, rm, root, run-script, s, se, search, set,
    show, shrinkwrap, star, stars, start, stop, t, tag, team,
    test, tst, un, uninstall, unlink, unpublish, unstar, up,
    update, upgrade, v, version, view, whoami

npm <cmd> -h     quick help on <cmd>
npm -l           display full usage info
npm faq          commonly asked questions
npm help <term>  search for help on <term>
npm help npm     involved overview

Specify configs in the ini-formatted file:
    /home/nvbn/.npmrc
or on the command line via: npm <command> --key value
Config info can be viewed via: npm help config

'''

run_script_stdout = b'''
Lifecycle scripts included in code-view-web:
  test
    jest

available via `npm run-script`:
  build
    cp node_modules/ace-builds/src-min/ -a resources/ace/ && webpack --progress --colors -p --config ./webpack.production.config.js
  develop
    cp node_modules/ace-builds/src/ -a resources/ace/ && webpack-dev-server --progress --colors
  watch-test
    jest --verbose --watch

'''


@pytest.fixture(autouse=True)
def run_script(mocker):
    patch = mocker.patch('thefuck.specific.npm.Popen')
    patch.return_value.stdout = BytesIO(run_script_stdout)
    return patch.return_value


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script', [
    'npm watch-test', 'npm develop'])
def test_match(script):
    command = Command(script, output)
    assert match(command)


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('command, run_script_out', [
    (Command('npm test', 'TEST FAIL'), run_script_stdout),
    (Command('npm watch-test', 'TEST FAIL'), run_script_stdout),
    (Command('npm test', output), run_script_stdout),
    (Command('vim watch-test', output), run_script_stdout)])
def test_not_match(run_script, command, run_script_out):
    run_script.stdout = BytesIO(run_script_out)
    assert not match(command)


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script, result', [
    ('npm watch-test', 'npm run-script watch-test'),
    ('npm -i develop', 'npm run-script -i develop'),
    ('npm -i watch-script --path ..',
     'npm run-script -i watch-script --path ..')])
def test_get_new_command(script, result):
    command = Command(script, output)
    assert get_new_command(command) == result<EOS>"
"<BOS>import pytest
from thefuck.rules.unknown_command import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('./bin/hdfs dfs ls', 'ls: Unknown command\nDid you mean -ls?  This command begins with a dash.'),
    Command('hdfs dfs ls',
            'ls: Unknown command\nDid you mean -ls?  This command begins with a dash.'),
    Command('hdfs dfs ls /foo/bar', 'ls: Unknown command\nDid you mean -ls?  This command begins with a dash.')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('./bin/hdfs dfs -ls', ''),
    Command('./bin/hdfs dfs -ls /foo/bar', ''),
    Command('hdfs dfs -ls -R /foo/bar', ''),
    Command('', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('hdfs dfs ls',
             'ls: Unknown command\nDid you mean -ls?  This command begins with a dash.'), ['hdfs dfs -ls']),
    (Command('hdfs dfs rm /foo/bar',
             'rm: Unknown command\nDid you mean -rm?  This command begins with a dash.'), ['hdfs dfs -rm /foo/bar']),
    (Command('./bin/hdfs dfs ls -R /foo/bar',
             'ls: Unknown command\nDid you mean -ls?  This command begins with a dash.'), ['./bin/hdfs dfs -ls -R /foo/bar']),
    (Command('./bin/hdfs dfs -Dtest=fred ls -R /foo/bar',
             'ls: Unknown command\nDid you mean -ls?  This command begins with a dash.'), ['./bin/hdfs dfs -Dtest=fred -ls -R /foo/bar'])])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.brew_install import match, get_new_command
from thefuck.rules.brew_install import _get_formulas
from thefuck.types import Command


@pytest.fixture
def brew_no_available_formula():
    return '''Error: No available formula for elsticsearch '''


@pytest.fixture
def brew_install_no_argument():
    return '''This command requires a formula argument'''


@pytest.fixture
def brew_already_installed():
    return '''Warning: git-2.3.5 already installed'''


def _is_not_okay_to_test():
    return 'elasticsearch' not in _get_formulas()


@pytest.mark.skipif(_is_not_okay_to_test(),
                    reason='No need to run if there\'s no formula')
def test_match(brew_no_available_formula, brew_already_installed,
               brew_install_no_argument):
    assert match(Command('brew install elsticsearch',
                         brew_no_available_formula))
    assert not match(Command('brew install git',
                             brew_already_installed))
    assert not match(Command('brew install', brew_install_no_argument))


@pytest.mark.skipif(_is_not_okay_to_test(),
                    reason='No need to run if there\'s no formula')
def test_get_new_command(brew_no_available_formula):
    assert get_new_command(Command('brew install elsticsearch',
                                   brew_no_available_formula))\
        == 'brew install elasticsearch'

    assert get_new_command(Command('brew install aa',
                                   brew_no_available_formula))\
        != 'brew install aha'<EOS>"
"<BOS>import pytest
from thefuck.rules.choco_install import match, get_new_command
from thefuck.types import Command


package_not_found_error = (
    'Chocolatey v0.10.15\n'
    'Installing the following packages:\n'
    'logstitcher\n'
    'By installing you accept licenses for the packages.\n'
    'logstitcher not installed. The package was not found with the source(s) listed.\n'
    ' Source(s): \'https://chocolatey.org/api/v2/\'\n'
    ' NOTE: When you specify explicit sources, it overrides default sources.\n'
    'If the package version is a prerelease and you didn\'t specify `--pre`,\n'
    ' the package may not be found.\n'
    'Please see https://chocolatey.org/docs/troubleshooting for more\n'
    ' assistance.\n'
    '\n'
    'Chocolatey installed 0/1 packages. 1 packages failed.\n'
    ' See the log for details (C:\\ProgramData\\chocolatey\\logs\\chocolatey.log).\n'
    '\n'
    'Failures\n'
    ' - logstitcher - logstitcher not installed. The package was not found with the source(s) listed.\n'
    ' Source(s): \'https://chocolatey.org/api/v2/\'\n'
    ' NOTE: When you specify explicit sources, it overrides default sources.\n'
    'If the package version is a prerelease and you didn\'t specify `--pre`,\n'
    ' the package may not be found.\n'
    'Please see https://chocolatey.org/docs/troubleshooting for more\n'
    ' assistance.\n'
)


@pytest.mark.parametrize('command', [
    Command('choco install logstitcher', package_not_found_error),
    Command('cinst logstitcher', package_not_found_error),
    Command('choco install logstitcher -y', package_not_found_error),
    Command('cinst logstitcher -y', package_not_found_error),
    Command('choco install logstitcher -y -n=test', package_not_found_error),
    Command('cinst logstitcher -y -n=test', package_not_found_error),
    Command('choco install logstitcher -y -n=test /env', package_not_found_error),
    Command('cinst logstitcher -y -n=test /env', package_not_found_error),
    Command('choco install chocolatey -y', package_not_found_error),
    Command('cinst chocolatey -y', package_not_found_error)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('choco /?', ''),
    Command('choco upgrade logstitcher', ''),
    Command('cup logstitcher', ''),
    Command('choco upgrade logstitcher -y', ''),
    Command('cup logstitcher -y', ''),
    Command('choco upgrade logstitcher -y -n=test', ''),
    Command('cup logstitcher -y -n=test', ''),
    Command('choco upgrade logstitcher -y -n=test /env', ''),
    Command('cup logstitcher -y -n=test /env', ''),
    Command('choco upgrade chocolatey -y', ''),
    Command('cup chocolatey -y', ''),
    Command('choco uninstall logstitcher', ''),
    Command('cuninst logstitcher', ''),
    Command('choco uninstall logstitcher -y', ''),
    Command('cuninst logstitcher -y', ''),
    Command('choco uninstall logstitcher -y -n=test', ''),
    Command('cuninst logstitcher -y -n=test', ''),
    Command('choco uninstall logstitcher -y -n=test /env', ''),
    Command('cuninst logstitcher -y -n=test /env', ''),
    Command('choco uninstall chocolatey -y', ''),
    Command('cuninst chocolatey -y', '')])
def not_test_match(command):
    assert not match(command)


@pytest.mark.parametrize('before, after', [
    ('choco install logstitcher', 'choco install logstitcher.install'),
    ('cinst logstitcher', 'cinst logstitcher.install'),
    ('choco install logstitcher -y', 'choco install logstitcher.install -y'),
    ('cinst logstitcher -y', 'cinst logstitcher.install -y'),
    ('choco install logstitcher -y -n=test', 'choco install logstitcher.install -y -n=test'),
    ('cinst logstitcher -y -n=test', 'cinst logstitcher.install -y -n=test'),
    ('choco install logstitcher -y -n=test /env', 'choco install logstitcher.install -y -n=test /env'),
    ('cinst logstitcher -y -n=test /env', 'cinst logstitcher.install -y -n=test /env'),
    ('choco install chocolatey -y', 'choco install chocolatey.install -y'),
    ('cinst chocolatey -y', 'cinst chocolatey.install -y'), ])
def test_get_new_command(before, after):
    assert (get_new_command(Command(before, '')) == after)<EOS>"
"<BOS>import pytest
from thefuck.rules.django_south_merge import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''Running migrations for app:
 ! Migration app:0003_auto... should not have been applied before app:0002_auto__add_field_query_due_date_ but was.
Traceback (most recent call last):
  File ""/home/nvbn/work/.../bin/python"", line 42, in <module>
    exec(compile(__file__f.read(), __file__, ""exec""))
  File ""/home/nvbn/work/.../app/manage.py"", line 34, in <module>
    execute_from_command_line(sys.argv)
  File ""/home/nvbn/work/.../lib/django/core/management/__init__.py"", line 443, in execute_from_command_line
    utility.execute()
  File ""/home/nvbn/work/.../lib/django/core/management/__init__.py"", line 382, in execute
    self.fetch_command(subcommand).run_from_argv(self.argv)
  File ""/home/nvbn/work/.../lib/django/core/management/base.py"", line 196, in run_from_argv
    self.execute(*args, **options.__dict__)
  File ""/home/nvbn/work/.../lib/django/core/management/base.py"", line 232, in execute
    output = self.handle(*args, **options)
  File ""/home/nvbn/work/.../app/lib/south/management/commands/migrate.py"", line 108, in handle
    ignore_ghosts = ignore_ghosts,
  File ""/home/nvbn/work/.../app/lib/south/migration/__init__.py"", line 207, in migrate_app
    raise exceptions.InconsistentMigrationHistory(problems)
south.exceptions.InconsistentMigrationHistory: Inconsistent migration history
The following options are available:
    --merge: will just attempt the migration ignoring any potential dependency conflicts.
'''


def test_match(output):
    assert match(Command('./manage.py migrate', output))
    assert match(Command('python manage.py migrate', output))
    assert not match(Command('./manage.py migrate', ''))
    assert not match(Command('app migrate', output))
    assert not match(Command('./manage.py test', output))


def test_get_new_command():
    assert (get_new_command(Command('./manage.py migrate auth', ''))
            == './manage.py migrate auth --merge')<EOS>"
"<BOS>import pytest
from thefuck.rules.git_flag_after_filename import match, get_new_command
from thefuck.types import Command

command1 = Command('git log README.md -p',
                   ""fatal: bad flag '-p' used after filename"")
command2 = Command('git log README.md -p CONTRIBUTING.md',
                   ""fatal: bad flag '-p' used after filename"")
command3 = Command('git log -p README.md --name-only',
                   ""fatal: bad flag '--name-only' used after filename"")
command4 = Command('git log README.md -p',
                   ""fatal: option '-p' must come before non-option arguments"")
command5 = Command('git log README.md -p CONTRIBUTING.md',
                   ""fatal: option '-p' must come before non-option arguments"")
command6 = Command('git log -p README.md --name-only',
                   ""fatal: option '--name-only' must come before non-option arguments"")


@pytest.mark.parametrize('command', [
    command1, command2, command3, command4, command5, command6])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git log README.md', ''),
    Command('git log -p README.md', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, result', [
    (command1, ""git log -p README.md""),
    (command2, ""git log -p README.md CONTRIBUTING.md""),
    (command3, ""git log -p --name-only README.md""),
    (command4, ""git log -p README.md""),
    (command5, ""git log -p README.md CONTRIBUTING.md""),
    (command6, ""git log -p --name-only README.md"")])
def test_get_new_command(command, result):
    assert get_new_command(command) == result<EOS>"
"<BOS>import pytest
from thefuck.rules.git_rm_local_modifications import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output(target):
    return ('error: the following file has local modifications:\n    {}\n(use '
            '--cached to keep the file, or -f to force removal)').format(target)


@pytest.mark.parametrize('script, target', [
    ('git rm foo', 'foo'),
    ('git rm foo bar', 'bar')])
def test_match(output, script, target):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', ['git rm foo', 'git rm foo bar', 'git rm'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, target, new_command', [
    ('git rm foo', 'foo', ['git rm --cached foo', 'git rm -f foo']),
    ('git rm foo bar', 'bar', ['git rm --cached foo bar', 'git rm -f foo bar'])])
def test_get_new_command(output, script, target, new_command):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.man import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('man read', ''),
    Command('man 2 read', ''),
    Command('man 3 read', ''),
    Command('man -s2 read', ''),
    Command('man -s3 read', ''),
    Command('man -s 2 read', ''),
    Command('man -s 3 read', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('man', ''),
    Command('man ', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('man read', ''), ['man 3 read', 'man 2 read', 'read --help']),
    (Command('man missing', ""No manual entry for missing\n""), ['missing --help']),
    (Command('man 2 read', ''), 'man 3 read'),
    (Command('man 3 read', ''), 'man 2 read'),
    (Command('man -s2 read', ''), 'man -s3 read'),
    (Command('man -s3 read', ''), 'man -s2 read'),
    (Command('man -s 2 read', ''), 'man -s 3 read'),
    (Command('man -s 3 read', ''), 'man -s 2 read')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.mvn_no_command import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('mvn', '[ERROR] No goals have been specified for this build. You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('mvn clean', """"""
[INFO] Scanning for projects...[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building test 0.2
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ test ---
[INFO] Deleting /home/mlk/code/test/target
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 0.477s
[INFO] Finished at: Wed Aug 26 13:05:47 BST 2015
[INFO] Final Memory: 6M/240M
[INFO] ------------------------------------------------------------------------
""""""),  # noqa
    Command('mvn --help', ''),
    Command('mvn -v', '')
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('mvn', '[ERROR] No goals have been specified for this build. You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]'), ['mvn clean package', 'mvn clean install']),
    (Command('mvn -N', '[ERROR] No goals have been specified for this build. You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]'), ['mvn -N clean package', 'mvn -N clean install'])])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.no_command import match, get_new_command
from thefuck.types import Command


@pytest.fixture(autouse=True)
def get_all_executables(mocker):
    mocker.patch('thefuck.rules.no_command.get_all_executables',
                 return_value=['vim', 'fsck', 'git', 'go', 'python'])


@pytest.fixture(autouse=True)
def history_without_current(mocker):
    return mocker.patch(
        'thefuck.rules.no_command.get_valid_history_without_current',
        return_value=['git commit'])


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script, output', [
    ('vom file.py', 'vom: not found'),
    ('fucck', 'fucck: not found'),
    ('puthon', ""'puthon' is not recognized as an internal or external command""),
    ('got commit', 'got: command not found')])
def test_match(mocker, script, output):
    mocker.patch('thefuck.rules.no_command.which', return_value=None)

    assert match(Command(script, output))


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script, output, which', [
    ('qweqwe', 'qweqwe: not found', None),
    ('vom file.py', 'some text', None),
    ('vim file.py', 'vim: not found', 'vim')])
def test_not_match(mocker, script, output, which):
    mocker.patch('thefuck.rules.no_command.which', return_value=which)

    assert not match(Command(script, output))


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('script, result', [
    ('vom file.py', ['vim file.py']),
    ('fucck', ['fsck']),
    ('got commit', ['git commit', 'go commit'])])
def test_get_new_command(script, result):
    assert get_new_command(Command(script, '')) == result<EOS>"
"<BOS>import pytest
from mock import patch
from thefuck.rules import pacman_not_found
from thefuck.rules.pacman_not_found import match, get_new_command
from thefuck.types import Command

PKGFILE_OUTPUT_LLC = '''extra/llvm 3.6.0-5      /usr/bin/llc
extra/llvm35 3.5.2-13/usr/bin/llc'''


@pytest.mark.skipif(not getattr(pacman_not_found, 'enabled_by_default', True),
                    reason='Skip if pacman is not available')
@pytest.mark.parametrize('command', [
    Command('yay -S llc', 'error: target not found: llc'),
    Command('yaourt -S llc', 'error: target not found: llc'),
    Command('pacman llc', 'error: target not found: llc'),
    Command('sudo pacman llc', 'error: target not found: llc')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('yay -S llc', 'error: target not found: llc'),
    Command('yaourt -S llc', 'error: target not found: llc'),
    Command('pacman llc', 'error: target not found: llc'),
    Command('sudo pacman llc', 'error: target not found: llc')])
@patch('thefuck.specific.archlinux.subprocess')
def test_match_mocked(subp_mock, command):
    subp_mock.check_output.return_value = PKGFILE_OUTPUT_LLC
    assert match(command)


@pytest.mark.skipif(not getattr(pacman_not_found, 'enabled_by_default', True),
                    reason='Skip if pacman is not available')
@pytest.mark.parametrize('command, fixed', [
    (Command('yay -S llc', 'error: target not found: llc'), ['yay -S extra/llvm', 'yay -S extra/llvm35']),
    (Command('yaourt -S llc', 'error: target not found: llc'), ['yaourt -S extra/llvm', 'yaourt -S extra/llvm35']),
    (Command('pacman -S llc', 'error: target not found: llc'), ['pacman -S extra/llvm', 'pacman -S extra/llvm35']),
    (Command('sudo pacman -S llc', 'error: target not found: llc'), ['sudo pacman -S extra/llvm', 'sudo pacman -S extra/llvm35'])])
def test_get_new_command(command, fixed):
    assert get_new_command(command) == fixed


@pytest.mark.parametrize('command, fixed', [
    (Command('yay -S llc', 'error: target not found: llc'), ['yay -S extra/llvm', 'yay -S extra/llvm35']),
    (Command('yaourt -S llc', 'error: target not found: llc'), ['yaourt -S extra/llvm', 'yaourt -S extra/llvm35']),
    (Command('pacman -S llc', 'error: target not found: llc'), ['pacman -S extra/llvm', 'pacman -S extra/llvm35']),
    (Command('sudo pacman -S llc', 'error: target not found: llc'), ['sudo pacman -S extra/llvm', 'sudo pacman -S extra/llvm35'])])
@patch('thefuck.specific.archlinux.subprocess')
def test_get_new_command_mocked(subp_mock, command, fixed):
    subp_mock.check_output.return_value = PKGFILE_OUTPUT_LLC
    assert get_new_command(command) == fixed<EOS>"
"<BOS># -*- coding: UTF-8 -*-
from thefuck.rules.pip_install import match, get_new_command
from thefuck.types import Command


def test_match():
    response1 = """"""
    Could not install packages due to an EnvironmentError: [Errno 13] Permission denied: '/Library/Python/2.7/site-packages/entrypoints.pyc'
Consider using the `--user` option or check the permissions.
""""""
    assert match(Command('pip install -r requirements.txt', response1))

    response2 = """"""
Collecting bacon
  Downloading https://files.pythonhosted.org/packages/b2/81/19fb79139ee71c8bc4e5a444546f318e2b87253b8939ec8a7e10d63b7341/bacon-0.3.1.zip (11.0MB)
    100% |████████████████████████████████| 11.0MB 3.0MB/s
Installing collected packages: bacon
  Running setup.py install for bacon ... done
Successfully installed bacon-0.3.1
""""""
    assert not match(Command('pip install bacon', response2))


def test_get_new_command():
    assert get_new_command(Command('pip install -r requirements.txt', '')) == 'pip install --user -r requirements.txt'
    assert get_new_command(Command('pip install bacon', '')) == 'pip install --user bacon'
    assert get_new_command(Command('pip install --user -r requirements.txt', '')) == 'sudo pip install -r requirements.txt'<EOS>"
"<BOS>import pytest
from thefuck.rules.scm_correction import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def get_actual_scm_mock(mocker):
    return mocker.patch('thefuck.rules.scm_correction._get_actual_scm',
                        return_value=None)


@pytest.mark.parametrize('script, output, actual_scm', [
    ('git log', 'fatal: Not a git repository '
                '(or any of the parent directories): .git',
     'hg'),
    ('hg log', ""abort: no repository found in '/home/nvbn/exp/thefuck' ""
               ""(.hg not found)!"",
     'git')])
def test_match(get_actual_scm_mock, script, output, actual_scm):
    get_actual_scm_mock.return_value = actual_scm
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output, actual_scm', [
    ('git log', '', 'hg'),
    ('git log', 'fatal: Not a git repository '
                '(or any of the parent directories): .git',
     None),
    ('hg log', ""abort: no repository found in '/home/nvbn/exp/thefuck' ""
               ""(.hg not found)!"",
     None),
    ('not-scm log', ""abort: no repository found in '/home/nvbn/exp/thefuck' ""
                    ""(.hg not found)!"",
     'git')])
def test_not_match(get_actual_scm_mock, script, output, actual_scm):
    get_actual_scm_mock.return_value = actual_scm
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, actual_scm, result', [
    ('git log', 'hg', 'hg log'),
    ('hg log', 'git', 'git log')])
def test_get_new_command(get_actual_scm_mock, script, actual_scm, result):
    get_actual_scm_mock.return_value = actual_scm
    new_command = get_new_command(Command(script, ''))
    assert new_command == result<EOS>"
"<BOS>import pytest
from thefuck.rules.cp_create_destination import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize(
    ""script, output"",
    [(""cp"", ""cp: directory foo does not exist\n""), (""mv"", ""No such file or directory"")],
)
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize(
    ""script, output"", [(""cp"", """"), (""mv"", """"), (""ls"", ""No such file or directory"")]
)
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize(
    ""script, output, new_command"",
    [
        (""cp foo bar/"", ""cp: directory foo does not exist\n"", ""mkdir -p bar/ && cp foo bar/""),
        (""mv foo bar/"", ""No such file or directory"", ""mkdir -p bar/ && mv foo bar/""),
        (""cp foo bar/baz/"", ""cp: directory foo does not exist\n"", ""mkdir -p bar/baz/ && cp foo bar/baz/""),
    ],
)
def test_get_new_command(script, output, new_command):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.git_merge_unrelated import match, get_new_command
from thefuck.types import Command


output = 'fatal: refusing to merge unrelated histories'


def test_match():
    assert match(Command('git merge test', output))
    assert not match(Command('git merge master', ''))
    assert not match(Command('ls', output))


@pytest.mark.parametrize('command, new_command', [
    (Command('git merge local', output),
     'git merge local --allow-unrelated-histories'),
    (Command('git merge -m ""test"" local', output),
     'git merge -m ""test"" local --allow-unrelated-histories'),
    (Command('git merge -m ""test local"" local', output),
     'git merge -m ""test local"" local --allow-unrelated-histories')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.remove_shell_prompt_literal import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return ""$: command not found""


@pytest.mark.parametrize(
    ""script"",
    [
        ""$ cd newdir"",
        "" $ cd newdir"",
        ""$ $ cd newdir"",
        "" $ $ cd newdir"",
    ],
)
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize(
    ""command"",
    [
        Command(""$"", ""$: command not found""),
        Command("" $"", ""$: command not found""),
        Command(""$?"", ""127: command not found""),
        Command("" $?"", ""127: command not found""),
        Command("""", """"),
    ],
)
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize(
    ""script, new_command"",
    [
        (""$ cd newdir"", ""cd newdir""),
        (""$ $ cd newdir"", ""cd newdir""),
        (""$ python3 -m virtualenv env"", ""python3 -m virtualenv env""),
        ("" $ $ $ python3 -m virtualenv env"", ""python3 -m virtualenv env""),
    ],
)
def test_get_new_command(script, new_command, output):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.yarn_alias import match, get_new_command
from thefuck.types import Command


output_remove = 'error Did you mean `yarn remove`?'
output_etl = 'error Command ""etil"" not found. Did you mean ""etl""?'
output_list = 'error Did you mean `yarn list`?'


@pytest.mark.parametrize('command', [
    Command('yarn rm', output_remove),
    Command('yarn etil', output_etl),
    Command('yarn ls', output_list)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('yarn rm', output_remove), 'yarn remove'),
    (Command('yarn etil', output_etl), 'yarn etl'),
    (Command('yarn ls', output_list), 'yarn list')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.types import Command
from thefuck.rules.brew_link import get_new_command, match


@pytest.fixture
def output():
    return (""Error: Could not symlink bin/gcp\n""
            ""Target /usr/local/bin/gcp\n""
            ""already exists. You may want to remove it:\n""
            ""  rm '/usr/local/bin/gcp'\n""
            ""\n""
            ""To force the link and overwrite all conflicting files:\n""
            ""  brew link --overwrite coreutils\n""
            ""\n""
            ""To list all files that would be deleted:\n""
            ""  brew link --overwrite --dry-run coreutils\n"")


@pytest.fixture
def new_command(formula):
    return 'brew link --overwrite --dry-run {}'.format(formula)


@pytest.mark.parametrize('script', ['brew link coreutils', 'brew ln coreutils'])
def test_match(output, script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', ['brew link coreutils'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, formula, ', [('brew link coreutils', 'coreutils')])
def test_get_new_command(output, new_command, script, formula):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.cat_dir import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def isdir(mocker):
    return mocker.patch('thefuck.rules.cat_dir'
                        '.os.path.isdir')


@pytest.mark.parametrize('command', [
    Command('cat foo', 'cat: foo: Is a directory\n'),
    Command('cat /foo/bar/', 'cat: /foo/bar/: Is a directory\n'),
    Command('cat cat/', 'cat: cat/: Is a directory\n'),
])
def test_match(command, isdir):
    isdir.return_value = True
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('cat foo', 'foo bar baz'),
    Command('cat foo bar', 'foo bar baz'),
    Command('notcat foo bar', 'some output'),
])
def test_not_match(command, isdir):
    isdir.return_value = False
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('cat foo', 'cat: foo: Is a directory\n'), 'ls foo'),
    (Command('cat /foo/bar/', 'cat: /foo/bar/: Is a directory\n'), 'ls /foo/bar/'),
    (Command('cat cat', 'cat: cat: Is a directory\n'), 'ls cat'),
])
def test_get_new_command(command, new_command):
    isdir.return_value = True
    assert get_new_command(command) == new_command<EOS>"
"<BOS># -*- encoding: utf-8 -*-

from thefuck.rules.fix_alt_space import match, get_new_command
from thefuck.types import Command


def test_match():
    """"""The character before 'grep' is Alt+Space, which happens frequently
    on the Mac when typing the pipe character (Alt+7), and holding the Alt
    key pressed for longer than necessary.

    """"""
    assert match(Command(u'ps -ef | grep foo',
                         u'-bash:  grep: command not found'))
    assert not match(Command('ps -ef | grep foo', ''))
    assert not match(Command('', ''))


def test_get_new_command():
    """""" Replace the Alt+Space character by a simple space """"""
    assert (get_new_command(Command(u'ps -ef | grep foo', ''))
            == 'ps -ef | grep foo')<EOS>"
"<BOS>import pytest
from thefuck.rules.git_diff_no_index import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('git diff foo bar', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git diff --no-index foo bar', ''),
    Command('git diff foo', ''),
    Command('git diff foo bar baz', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('git diff foo bar', ''), 'git diff --no-index foo bar')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>from mock import patch
from thefuck.rules.has_exists_script import match, get_new_command
from thefuck.types import Command


def test_match():
    with patch('os.path.exists', return_value=True):
        assert match(Command('main', 'main: command not found'))
        assert match(Command('main --help',
                             'main: command not found'))
        assert not match(Command('main', ''))

    with patch('os.path.exists', return_value=False):
        assert not match(Command('main', 'main: command not found'))


def test_get_new_command():
    assert get_new_command(Command('main --help', '')) == './main --help'<EOS>"
"<BOS>from thefuck.rules.python_command import match, get_new_command
from thefuck.types import Command


def test_match():
    assert match(Command('temp.py', 'Permission denied'))
    assert not match(Command('', ''))


def test_get_new_command():
    assert (get_new_command(Command('./test_sudo.py', ''))
            == 'python ./test_sudo.py')<EOS>"
"<BOS>import pytest
from io import BytesIO
from thefuck.rules.react_native_command_unrecognized import match, \
    get_new_command
from thefuck.types import Command

output = ""Unrecognized command '{}'"".format

stdout = b'''
Scanning 615 folders for symlinks in /home/nvbn/work/zcho/BookkaWebView/node_modules (6ms)

  Usage: react-native [options] [command]


  Options:

    -V, --version  output the version number
    -h, --help     output usage information


  Commands:

    start [options]                    starts the webserver
    run-ios [options]                  builds your app and starts it on iOS simulator
    run-android [options]              builds your app and starts it on a connected Android emulator or device
    new-library [options]              generates a native library bridge
    bundle [options]                   builds the javascript bundle for offline use
    unbundle [options]                 builds javascript as ""unbundle"" for offline use
    eject [options]                    Re-create the iOS and Android folders and native code
    link [options] [packageName]       links all native dependencies (updates native build files)
    unlink [options] <packageName>     unlink native dependency
    install [options] <packageName>    install and link native dependencies
    uninstall [options] <packageName>  uninstall and unlink native dependencies
    upgrade [options]                  upgrade your app's template files to the latest version; run this after updating the react-native version in your package.json and running npm install
    log-android [options]              starts adb logcat
    log-ios [options]                  starts iOS device syslog tail
'''


@pytest.mark.parametrize('command', [
    Command('react-native star', output('star')),
    Command('react-native android-logs', output('android-logs'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('gradle star', output('star')),
    Command('react-native start', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, result', [
    (Command('react-native star', output('star')),
     'react-native start'),
    (Command('react-native logsandroid -f', output('logsandroid')),
     'react-native log-android -f')])
def test_get_new_command(mocker, command, result):
    patch = mocker.patch(
        'thefuck.rules.react_native_command_unrecognized.Popen')
    patch.return_value.stdout = BytesIO(stdout)
    assert get_new_command(command)[0] == result<EOS>"
"<BOS>import pytest
from thefuck.rules.unsudo import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('output', [
    'you cannot perform this operation as root'])
def test_match(output):
    assert match(Command('sudo ls', output))


def test_not_match():
    assert not match(Command('', ''))
    assert not match(Command('sudo ls', 'Permission denied'))
    assert not match(Command('ls', 'you cannot perform this operation as root'))


@pytest.mark.parametrize('before, after', [
    ('sudo ls', 'ls'),
    ('sudo pacaur -S helloworld', 'pacaur -S helloworld')])
def test_get_new_command(before, after):
    assert get_new_command(Command(before, '')) == after<EOS>"
"<BOS>import pytest
from thefuck.rules.brew_cask_dependency import match, get_new_command
from thefuck.types import Command


output = '''sshfs: OsxfuseRequirement unsatisfied!

You can install with Homebrew-Cask:
  brew cask install osxfuse

You can download from:
  https://osxfuse.github.io/
Error: An unsatisfied requirement failed this build.'''


def test_match():
    command = Command('brew install sshfs', output)
    assert match(command)


@pytest.mark.parametrize('script, output', [
    ('brew link sshfs', output),
    ('cat output', output),
    ('brew install sshfs', '')])
def test_not_match(script, output):
    command = Command(script, output)
    assert not match(command)


@pytest.mark.parametrize('before, after', [
    ('brew install sshfs',
     'brew cask install osxfuse && brew install sshfs')])
def test_get_new_command(before, after):
    command = Command(before, output)
    assert get_new_command(command) == after<EOS>"
"<BOS>from thefuck.rules.docker_image_being_used_by_container import match, get_new_command
from thefuck.types import Command


def test_match():
    err_response = """"""Error response from daemon: conflict: unable to delete cd809b04b6ff (cannot be forced) - image is being used by running container e5e2591040d1""""""
    assert match(Command('docker image rm -f cd809b04b6ff', err_response))


def test_not_match():
    err_response = 'bash: docker: command not found'
    assert not match(Command('docker image rm -f cd809b04b6ff', err_response))


def test_not_docker_command():
    err_response = """"""Error response from daemon: conflict: unable to delete cd809b04b6ff (cannot be forced) - image is being used by running container e5e2591040d1""""""
    assert not match(Command('git image rm -f cd809b04b6ff', err_response))


def test_get_new_command():
    err_response = """"""
        Error response from daemon: conflict: unable to delete cd809b04b6ff (cannot be forced) - image
        is being used by running container e5e2591040d1
        """"""
    result = get_new_command(Command('docker image rm -f cd809b04b6ff', err_response))
    expected = 'docker container rm -f e5e2591040d1 && docker image rm -f cd809b04b6ff'
    assert result == expected<EOS>"
"<BOS>import pytest
from io import BytesIO
from thefuck.rules.git_checkout import match, get_branches, get_new_command
from thefuck.types import Command


def did_not_match(target, did_you_forget=False):
    error = (""error: pathspec '{}' did not match any ""
             ""file(s) known to git."".format(target))
    if did_you_forget:
        error = (""{}\nDid you forget to 'git add'?'"".format(error))
    return error


@pytest.fixture
def git_branch(mocker, branches):
    mock = mocker.patch('subprocess.Popen')
    mock.return_value.stdout = BytesIO(branches)
    return mock


@pytest.mark.parametrize('command', [
    Command('git checkout unknown', did_not_match('unknown')),
    Command('git commit unknown', did_not_match('unknown'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git submodule update unknown',
            did_not_match('unknown', True)),
    Command('git checkout known', ''),
    Command('git commit known', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('branches, branch_list', [
    (b'', []),
    (b'* master', ['master']),
    (b'  remotes/origin/master', ['master']),
    (b'  remotes/origin/test/1', ['test/1']),
    (b'  remotes/origin/test/1/2/3', ['test/1/2/3']),
    (b'  test/1', ['test/1']),
    (b'  test/1/2/3', ['test/1/2/3']),
    (b'  remotes/origin/HEAD -> origin/master', []),
    (b'  just-another-branch', ['just-another-branch']),
    (b'* master\n  just-another-branch', ['master', 'just-another-branch']),
    (b'* master\n  remotes/origin/master\n  just-another-branch',
     ['master', 'master', 'just-another-branch'])])
def test_get_branches(branches, branch_list, git_branch):
    git_branch(branches)
    assert list(get_branches()) == branch_list


@pytest.mark.parametrize('branches, command, new_command', [
    (b'',
     Command('git checkout unknown', did_not_match('unknown')),
     ['git checkout -b unknown']),
    (b'',
     Command('git commit unknown', did_not_match('unknown')),
     ['git branch unknown && git commit unknown']),
    (b'  test-random-branch-123',
     Command('git checkout tst-rdm-brnch-123',
             did_not_match('tst-rdm-brnch-123')),
     ['git checkout test-random-branch-123', 'git checkout -b tst-rdm-brnch-123']),
    (b'  test-random-branch-123',
     Command('git commit tst-rdm-brnch-123',
             did_not_match('tst-rdm-brnch-123')),
     ['git commit test-random-branch-123'])])
def test_get_new_command(branches, command, new_command, git_branch):
    git_branch(branches)
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.git_rebase_merge_dir import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return ('\n\nIt seems that there is already a rebase-merge directory, and\n'
            'I wonder if you are in the middle of another rebase.  If that is the\n'
            'case, please try\n'
            '\tgit rebase (--continue | --abort | --skip)\n'
            'If that is not the case, please\n'
            '\trm -fr ""/foo/bar/baz/egg/.git/rebase-merge""\n'
            'and run me again.  I am stopping in case you still have something\n'
            'valuable there.\n')


@pytest.mark.parametrize('script', [
    'git rebase master',
    'git rebase -skip',
    'git rebase'])
def test_match(output, script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', ['git rebase master', 'git rebase -abort'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, result', [
    ('git rebase master', [
        'git rebase --abort', 'git rebase --skip', 'git rebase --continue',
        'rm -fr ""/foo/bar/baz/egg/.git/rebase-merge""']),
    ('git rebase -skip', [
        'git rebase --skip', 'git rebase --abort', 'git rebase --continue',
        'rm -fr ""/foo/bar/baz/egg/.git/rebase-merge""']),
    ('git rebase', [
        'git rebase --skip', 'git rebase --abort', 'git rebase --continue',
        'rm -fr ""/foo/bar/baz/egg/.git/rebase-merge""'])])
def test_get_new_command(output, script, result):
    assert get_new_command(Command(script, output)) == result<EOS>"
"<BOS>import pytest
from thefuck.rules.git_stash import match, get_new_command
from thefuck.types import Command


cherry_pick_error = (
    'error: Your local changes would be overwritten by cherry-pick.\n'
    'hint: Commit your changes or stash them to proceed.\n'
    'fatal: cherry-pick failed')


rebase_error = (
    'Cannot rebase: Your index contains uncommitted changes.\n'
    'Please commit or stash them.')


@pytest.mark.parametrize('command', [
    Command('git cherry-pick a1b2c3d', cherry_pick_error),
    Command('git rebase -i HEAD~7', rebase_error)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('git cherry-pick a1b2c3d', ''),
    Command('git rebase -i HEAD~7', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('git cherry-pick a1b2c3d', cherry_pick_error),
     'git stash && git cherry-pick a1b2c3d'),
    (Command('git rebase -i HEAD~7', rebase_error),
     'git stash && git rebase -i HEAD~7')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.rm_dir import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('rm foo', 'rm: foo: is a directory'),
    Command('rm foo', 'rm: foo: Is a directory'),
    Command('hdfs dfs -rm foo', 'rm: `foo`: Is a directory'),
    Command('./bin/hdfs dfs -rm foo', 'rm: `foo`: Is a directory'),
])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('rm foo', ''),
    Command('hdfs dfs -rm foo', ''),
    Command('./bin/hdfs dfs -rm foo', ''),
    Command('', ''),
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('rm foo', ''), 'rm -rf foo'),
    (Command('hdfs dfs -rm foo', ''), 'hdfs dfs -rm -r foo'),
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.sed_unterminated_s import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def sed_unterminated_s():
    return ""sed: -e expression #1, char 9: unterminated `s' command""


def test_match(sed_unterminated_s):
    assert match(Command('sed -e s/foo/bar', sed_unterminated_s))
    assert match(Command('sed -es/foo/bar', sed_unterminated_s))
    assert match(Command('sed -e s/foo/bar -e s/baz/quz', sed_unterminated_s))
    assert not match(Command('sed -e s/foo/bar', ''))
    assert not match(Command('sed -es/foo/bar', ''))
    assert not match(Command('sed -e s/foo/bar -e s/baz/quz', ''))


def test_get_new_command(sed_unterminated_s):
    assert (get_new_command(Command('sed -e s/foo/bar', sed_unterminated_s))
            == 'sed -e s/foo/bar/')
    assert (get_new_command(Command('sed -es/foo/bar', sed_unterminated_s))
            == 'sed -es/foo/bar/')
    assert (get_new_command(Command(r""sed -e 's/\/foo/bar'"", sed_unterminated_s))
            == r""sed -e 's/\/foo/bar/'"")
    assert (get_new_command(Command(r""sed -e s/foo/bar -es/baz/quz"", sed_unterminated_s))
            == r""sed -e s/foo/bar/ -es/baz/quz/"")<EOS>"
"<BOS>import pytest
from thefuck.rules.tmux import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def tmux_ambiguous():
    return ""ambiguous command: list, could be: "" \
           ""list-buffers, list-clients, list-commands, list-keys, "" \
           ""list-panes, list-sessions, list-windows""


def test_match(tmux_ambiguous):
    assert match(Command('tmux list', tmux_ambiguous))


def test_get_new_command(tmux_ambiguous):
    assert get_new_command(Command('tmux list', tmux_ambiguous))\
        == ['tmux list-keys', 'tmux list-panes', 'tmux list-windows']<EOS>"
"<BOS>import pytest

from thefuck.rules.conda_mistype import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def mistype_response():
    return """"""

CommandNotFoundError: No command 'conda lst'.
Did you mean 'conda list'?

    """"""


def test_match(mistype_response):
    assert match(Command('conda lst', mistype_response))
    err_response = 'bash: codna: command not found'
    assert not match(Command('codna list', err_response))


def test_get_new_command(mistype_response):
    assert (get_new_command(Command('conda lst', mistype_response)) == ['conda list'])<EOS>"
"<BOS>import pytest
from thefuck.rules.git_commit_add import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize(
    ""script, output"",
    [
        ('git commit -m ""test""', ""no changes added to commit""),
        (""git commit"", ""no changes added to commit""),
    ],
)
def test_match(output, script):
    assert match(Command(script, output))


@pytest.mark.parametrize(
    ""script, output"",
    [
        ('git commit -m ""test""', "" 1 file changed, 15 insertions(+), 14 deletions(-)""),
        (""git branch foo"", """"),
        (""git checkout feature/test_commit"", """"),
        (""git push"", """"),
    ],
)
def test_not_match(output, script):
    assert not match(Command(script, output))


@pytest.mark.parametrize(
    ""script, new_command"",
    [
        (""git commit"", [""git commit -a"", ""git commit -p""]),
        ('git commit -m ""foo""', ['git commit -a -m ""foo""', 'git commit -p -m ""foo""']),
    ],
)
def test_get_new_command(script, new_command):
    assert get_new_command(Command(script, """")) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.git_help_aliased import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('script, output', [
    ('git help st', ""`git st' is aliased to `status'""),
    ('git help ds', ""`git ds' is aliased to `diff --staged'"")])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output', [
    ('git help status', ""GIT-STATUS(1)...Git Manual...GIT-STATUS(1)""),
    ('git help diff', ""GIT-DIFF(1)...Git Manual...GIT-DIFF(1)"")])
def test_not_match(script, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, output, new_command', [
    ('git help st', ""`git st' is aliased to `status'"", 'git help status'),
    ('git help ds', ""`git ds' is aliased to `diff --staged'"", 'git help diff')])
def test_get_new_command(script, output, new_command):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.git_hook_bypass import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize(
    ""command"",
    [
        Command(""git am"", """"),
        Command(""git commit"", """"),
        Command(""git commit -m 'foo bar'"", """"),
        Command(""git push"", """"),
        Command(""git push -u foo bar"", """"),
    ],
)
def test_match(command):
    assert match(command)


@pytest.mark.parametrize(
    ""command"",
    [
        Command(""git add foo"", """"),
        Command(""git status"", """"),
        Command(""git diff foo bar"", """"),
    ],
)
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize(
    ""command, new_command"",
    [
        (Command(""git am"", """"), ""git am --no-verify""),
        (Command(""git commit"", """"), ""git commit --no-verify""),
        (Command(""git commit -m 'foo bar'"", """"), ""git commit --no-verify -m 'foo bar'""),
        (Command(""git push"", """"), ""git push --no-verify""),
        (Command(""git push -p"", """"), ""git push --no-verify -p""),
    ],
)
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.git_main_master import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output(branch_name):
    if not branch_name:
        return """"
    output_str = u""error: pathspec '{}' did not match any file(s) known to git""
    return output_str.format(branch_name)


@pytest.mark.parametrize(
    ""script, branch_name"",
    [
        (""git checkout main"", ""main""),
        (""git checkout master"", ""master""),
        (""git show main"", ""main""),
    ],
)
def test_match(script, branch_name, output):
    assert match(Command(script, output))


@pytest.mark.parametrize(
    ""script, branch_name"",
    [
        (""git checkout master"", """"),
        (""git checkout main"", """"),
        (""git checkout wibble"", ""wibble""),
    ],
)
def test_not_match(script, branch_name, output):
    assert not match(Command(script, output))


@pytest.mark.parametrize(
    ""script, branch_name, new_command"",
    [
        (""git checkout main"", ""main"", ""git checkout master""),
        (""git checkout master"", ""master"", ""git checkout main""),
        (""git checkout wibble"", ""wibble"", ""git checkout wibble""),
    ],
)
def test_get_new_command(script, branch_name, new_command, output):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS># -*- encoding: utf-8 -*-

from io import BytesIO
import pytest
from thefuck.types import Command
from thefuck.rules.grunt_task_not_found import match, get_new_command

output = '''
Warning: Task ""{}"" not found. Use --force to continue.

Aborted due to warnings.


Execution Time (2016-08-13 21:01:40 UTC+3)
loading tasks  11ms  ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 92%
Total 12ms

'''.format

grunt_help_stdout = b'''
Grunt: The JavaScript Task Runner (v0.4.5)

Usage
 grunt [options] [task [task ...]]

Options
    --help, -h  Display this help text.
        --base  Specify an alternate base path. By default, all file paths are
                relative to the Gruntfile. (grunt.file.setBase) *
    --no-color  Disable colored output.
   --gruntfile  Specify an alternate Gruntfile. By default, grunt looks in the
                current or parent directories for the nearest Gruntfile.js or
                Gruntfile.coffee file.
   --debug, -d  Enable debugging mode for tasks that support it.
       --stack  Print a stack trace when exiting with a warning or fatal error.
   --force, -f  A way to force your way past warnings. Want a suggestion? Don't
                use this option, fix your code.
       --tasks  Additional directory paths to scan for task and ""extra"" files.
                (grunt.loadTasks) *
         --npm  Npm-installed grunt plugins to scan for task and ""extra"" files.
                (grunt.loadNpmTasks) *
    --no-write  Disable writing files (dry run).
 --verbose, -v  Verbose mode. A lot more information output.
 --version, -V  Print the grunt version. Combine with --verbose for more info.
  --completion  Output shell auto-completion rules. See the grunt-cli
                documentation for more information.

Options marked with * have methods exposed via the grunt API and should instead
be specified inside the Gruntfile wherever possible.

Available tasks
  autoprefixer  Prefix CSS files. *
    concurrent  Run grunt tasks concurrently *
         clean  Clean files and folders. *
       compass  Compile Sass to CSS using Compass *
        concat  Concatenate files. *
       connect  Start a connect web server. *
          copy  Copy files. *
        cssmin  Minify CSS *
       htmlmin  Minify HTML *
      imagemin  Minify PNG, JPEG, GIF and SVG images *
        jshint  Validate files with JSHint. *
        uglify  Minify files with UglifyJS. *
         watch  Run predefined tasks whenever watched files change.
       filerev  File revisioning based on content hashing *
        cdnify  Replace scripts with refs to the Google CDN *
         karma  run karma. *
         newer  Run a task with only those source files that have been modified
                since the last successful run.
     any-newer  DEPRECATED TASK.  Use the ""newer"" task instead
 newer-postrun  Internal task.
   newer-clean  Remove cached timestamps.
    ngAnnotate  Add, remove and rebuild AngularJS dependency injection
                annotations *
    ngconstant  Dynamic angular constant generator task. *
        svgmin  Minify SVG *
        usemin  Replaces references to non-minified scripts / stylesheets *
 useminPrepare  Using HTML markup as the primary source of information *
       wiredep  Inject Bower components into your source code. *
         serve  Compile then start a connect web server
        server  DEPRECATED TASK. Use the ""serve"" task instead
          test  Alias for ""clean:server"", ""ngconstant:test"", ""wiredep"",
                ""concurrent:test"", ""autoprefixer"", ""connect:test"", ""karma""
                tasks.
         build  Alias for ""ngconstant:production"", ""clean:dist"", ""wiredep"",
                ""useminPrepare"", ""concurrent:dist"", ""autoprefixer"", ""concat"",
                ""ngAnnotate"", ""copy:dist"", ""cdnify"", ""cssmin"", ""uglify"",
                ""filerev"", ""usemin"", ""htmlmin"" tasks.
       default  Alias for ""newer:jshint"", ""test"", ""build"" tasks.

Tasks run in the order specified. Arguments may be passed to tasks that accept
them by using colons, like ""lint:files"". Tasks marked with * are ""multi tasks""
and will iterate over all sub-targets if no argument is specified.

The list of available tasks may change based on tasks directories or grunt
plugins specified in the Gruntfile or via command-line options.

For more information, see http://gruntjs.com/
'''


@pytest.fixture(autouse=True)
def grunt_help(mocker):
    patch = mocker.patch('thefuck.rules.grunt_task_not_found.Popen')
    patch.return_value.stdout = BytesIO(grunt_help_stdout)
    return patch


@pytest.mark.parametrize('command', [
    Command('grunt defualt', output('defualt')),
    Command('grunt buld:css', output('buld:css'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('npm nuild', output('nuild')),
    Command('grunt rm', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, result', [
    (Command('grunt defualt', output('defualt')), 'grunt default'),
    (Command('grunt cmpass:all', output('cmpass:all')), 'grunt compass:all'),
    (Command('grunt cmpass:all --color', output('cmpass:all')),
     'grunt compass:all --color')])
def test_get_new_command(command, result):
    assert get_new_command(command) == result<EOS>"
"<BOS>import pytest
from thefuck.rules.javac import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('javac foo', ''),
    Command('javac bar', '')])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('javac foo', ''), 'javac foo.java'),
    (Command('javac bar', ''), 'javac bar.java')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS># -*- encoding: utf-8 -*-

from io import BytesIO
import pytest
from thefuck.types import Command
from thefuck.rules.yarn_command_not_found import match, get_new_command

output = '''
error Command ""{}"" not found.
'''.format

yarn_help_stdout = b'''

  Usage: yarn [command] [flags]

  Options:

    -h, --help                      output usage information
    -V, --version                   output the version number
    --verbose                       output verbose messages on internal operations
    --offline                       trigger an error if any required dependencies are not available in local cache
    --prefer-offline                use network only if dependencies are not available in local cache
    --strict-semver                 
    --json                          
    --ignore-scripts                don't run lifecycle scripts
    --har                           save HAR output of network traffic
    --ignore-platform               ignore platform checks
    --ignore-engines                ignore engines check
    --ignore-optional               ignore optional dependencies
    --force                         ignore all caches
    --no-bin-links                  don't generate bin links when setting up packages
    --flat                          only allow one version of a package
    --prod, --production [prod]     
    --no-lockfile                   don't read or generate a lockfile
    --pure-lockfile                 don't generate a lockfile
    --frozen-lockfile               don't generate a lockfile and fail if an update is needed
    --link-duplicates               create hardlinks to the repeated modules in node_modules
    --global-folder <path>          
    --modules-folder <path>         rather than installing modules into the node_modules folder relative to the cwd, output them here
    --cache-folder <path>           specify a custom folder to store the yarn cache
    --mutex <type>[:specifier]      use a mutex to ensure only one yarn instance is executing
    --no-emoji                      disable emoji in output
    --proxy <host>                  
    --https-proxy <host>            
    --no-progress                   disable progress bar
    --network-concurrency <number>  maximum number of concurrent network requests

  Commands:

    - access
    - add
    - bin
    - cache
    - check
    - clean
    - config
    - generate-lock-entry
    - global
    - import
    - info
    - init
    - install
    - licenses
    - link
    - list
    - login
    - logout
    - outdated
    - owner
    - pack
    - publish
    - remove
    - run
    - tag
    - team
    - unlink
    - upgrade
    - upgrade-interactive
    - version
    - versions
    - why

  Run `yarn help COMMAND` for more information on specific commands.
  Visit https://yarnpkg.com/en/docs/cli/ to learn more about Yarn.
''' # noqa


@pytest.fixture(autouse=True)
def yarn_help(mocker):
    patch = mocker.patch('thefuck.rules.yarn_command_not_found.Popen')
    patch.return_value.stdout = BytesIO(yarn_help_stdout)
    return patch


@pytest.mark.parametrize('command', [
    Command('yarn whyy webpack', output('whyy'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('npm nuild', output('nuild')),
    Command('yarn install', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, result', [
    (Command('yarn whyy webpack', output('whyy')),
     'yarn why webpack'),
    (Command('yarn require lodash', output('require')),
     'yarn add lodash')])
def test_get_new_command(command, result):
    fixed_command = get_new_command(command)
    if isinstance(fixed_command, list):
        fixed_command = fixed_command[0]

    assert fixed_command == result<EOS>"
"<BOS>import pytest
from thefuck.types import Command
from thefuck.rules.yarn_command_replaced import match, get_new_command


output = ('error `install` has been replaced with `add` to add new '
          'dependencies. Run ""yarn add {}"" instead.').format


@pytest.mark.parametrize('command', [
    Command('yarn install redux', output('redux')),
    Command('yarn install moment', output('moment')),
    Command('yarn install lodash', output('lodash'))])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('yarn install', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('yarn install redux', output('redux')),
     'yarn add redux'),
    (Command('yarn install moment', output('moment')),
     'yarn add moment'),
    (Command('yarn install lodash', output('lodash')),
     'yarn add lodash')])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.rules.apt_get import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command, packages', [
    (Command('vim', 'vim: command not found'),
     [('vim', 'main'), ('vim-tiny', 'main')]),
    (Command('sudo vim', 'vim: command not found'),
     [('vim', 'main'), ('vim-tiny', 'main')]),
    (Command('vim', ""The program 'vim' is currently not installed. You can install it by typing: sudo apt install vim""),
     [('vim', 'main'), ('vim-tiny', 'main')])])
def test_match(mocker, command, packages):
    mocker.patch('thefuck.rules.apt_get.which', return_value=None)
    mocker.patch('thefuck.rules.apt_get._get_packages',
                 create=True, return_value=packages)

    assert match(command)


@pytest.mark.parametrize('command, packages, which', [
    (Command('a_bad_cmd', 'a_bad_cmd: command not found'),
     [], None),
    (Command('vim', ''), [], None),
    (Command('', ''), [], None),
    (Command('vim', 'vim: command not found'),
     ['vim'], '/usr/bin/vim'),
    (Command('sudo vim', 'vim: command not found'),
     ['vim'], '/usr/bin/vim')])
def test_not_match(mocker, command, packages, which):
    mocker.patch('thefuck.rules.apt_get.which', return_value=which)
    mocker.patch('thefuck.rules.apt_get._get_packages',
                 create=True, return_value=packages)

    assert not match(command)


@pytest.mark.parametrize('command, new_command, packages', [
    (Command('vim', ''), 'sudo apt-get install vim && vim',
     [('vim', 'main'), ('vim-tiny', 'main')]),
    (Command('convert', ''), 'sudo apt-get install imagemagick && convert',
     [('imagemagick', 'main'),
      ('graphicsmagick-imagemagick-compat', 'universe')]),
    (Command('sudo vim', ''), 'sudo apt-get install vim && sudo vim',
     [('vim', 'main'), ('vim-tiny', 'main')]),
    (Command('sudo convert', ''), 'sudo apt-get install imagemagick && sudo convert',
     [('imagemagick', 'main'),
      ('graphicsmagick-imagemagick-compat', 'universe')])])
def test_get_new_command(mocker, command, new_command, packages):
    mocker.patch('thefuck.rules.apt_get._get_packages',
                 create=True, return_value=packages)

    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.types import Command
from thefuck.rules.brew_uninstall import get_new_command, match


@pytest.fixture
def output():
    return (""Uninstalling /usr/local/Cellar/tbb/4.4-20160916... (118 files, 1.9M)\n""
            ""tbb 4.4-20160526, 4.4-20160722 are still installed.\n""
            ""Remove all versions with `brew uninstall --force tbb`.\n"")


@pytest.fixture
def new_command(formula):
    return 'brew uninstall --force {}'.format(formula)


@pytest.mark.parametrize('script', ['brew uninstall tbb', 'brew rm tbb', 'brew remove tbb'])
def test_match(output, script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', ['brew remove gnuplot'])
def test_not_match(script):
    output = 'Uninstalling /usr/local/Cellar/gnuplot/5.0.4_1... (44 files, 2.3M)\n'
    assert not match(Command(script, output))


@pytest.mark.parametrize('script, formula, ', [('brew uninstall tbb', 'tbb')])
def test_get_new_command(output, new_command, script, formula):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS>import pytest
from thefuck.types import Command
from thefuck.rules.brew_update_formula import get_new_command, match


output = (""Error: This command updates brew itself, and does not take formula""
          "" names.\nUse 'brew upgrade thefuck'."")


def test_match():
    command = Command('brew update thefuck', output)
    assert match(command)


@pytest.mark.parametrize('script', [
    'brew upgrade foo',
    'brew update'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, formula, ', [
    ('brew update foo', 'foo'),
    ('brew update bar zap', 'bar zap')])
def test_get_new_command(script, formula):
    command = Command(script, output)
    new_command = 'brew upgrade {}'.format(formula)
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest
from thefuck.types import Command
from thefuck.rules.git_bisect_usage import match, get_new_command


@pytest.fixture
def output():
    return (""usage: git bisect [help|start|bad|good|new|old""
            ""|terms|skip|next|reset|visualize|replay|log|run]"")


@pytest.mark.parametrize('script', [
    'git bisect strt', 'git bisect rset', 'git bisect goood'])
def test_match(output, script):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', [
    'git bisect', 'git bisect start', 'git bisect good'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, new_cmd, ', [
    ('git bisect goood', ['good', 'old', 'log']),
    ('git bisect strt', ['start', 'terms', 'reset']),
    ('git bisect rset', ['reset', 'next', 'start'])])
def test_get_new_command(output, script, new_cmd):
    new_cmd = ['git bisect %s' % cmd for cmd in new_cmd]
    assert get_new_command(Command(script, output)) == new_cmd<EOS>"
"<BOS>import pytest
from thefuck.rules.git_pull import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output():
    return '''There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details

    git pull <remote> <branch>

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=<remote>/<branch> master

'''


def test_match(output):
    assert match(Command('git pull', output))
    assert not match(Command('git pull', ''))
    assert not match(Command('ls', output))


def test_get_new_command(output):
    assert (get_new_command(Command('git pull', output))
            == ""git branch --set-upstream-to=origin/master master && git pull"")<EOS>"
"<BOS>import pytest
from thefuck.rules.history import match, get_new_command
from thefuck.types import Command


@pytest.fixture(autouse=True)
def history_without_current(mocker):
    return mocker.patch(
        'thefuck.rules.history.get_valid_history_without_current',
        return_value=['ls cat', 'diff x'])


@pytest.mark.parametrize('script', ['ls cet', 'daff x'])
def test_match(script):
    assert match(Command(script, ''))


@pytest.mark.parametrize('script', ['apt-get', 'nocommand y'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, result', [
    ('ls cet', 'ls cat'),
    ('daff x', 'diff x')])
def test_get_new_command(script, result):
    assert get_new_command(Command(script, '')) == result<EOS>"
"<BOS>import pytest
from thefuck.rules.hostscli import no_website, get_new_command, match
from thefuck.types import Command

no_website_long = '''
{}:

No Domain list found for website: a_website_that_does_not_exist

Please raise a Issue here: https://github.com/dhilipsiva/hostscli/issues/new
if you think we should add domains for this website.

type `hostscli websites` to see a list of websites that you can block/unblock
'''.format(no_website)


@pytest.mark.parametrize('command', [
    Command('hostscli block a_website_that_does_not_exist', no_website_long)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, result', [(
    Command('hostscli block a_website_that_does_not_exist', no_website_long),
    ['hostscli websites'])])
def test_get_new_command(command, result):
    assert get_new_command(command) == result<EOS>"
"<BOS># -*- coding: utf-8 -*-
import pytest
from thefuck.rules.ln_no_hard_link import match, get_new_command
from thefuck.types import Command

error = ""hard link not allowed for directory""


@pytest.mark.parametrize('script, output', [
    (""ln barDir barLink"", ""ln: ‘barDir’: {}""),
    (""sudo ln a b"", ""ln: ‘a’: {}""),
    (""sudo ln -nbi a b"", ""ln: ‘a’: {}"")])
def test_match(script, output):
    command = Command(script, output.format(error))
    assert match(command)


@pytest.mark.parametrize('script, output', [
    ('', ''),
    (""ln a b"", ""... hard link""),
    (""sudo ln a b"", ""... hard link""),
    (""a b"", error)])
def test_not_match(script, output):
    command = Command(script, output)
    assert not match(command)


@pytest.mark.parametrize('script, result', [
    (""ln barDir barLink"", ""ln -s barDir barLink""),
    (""sudo ln barDir barLink"", ""sudo ln -s barDir barLink""),
    (""sudo ln -nbi a b"", ""sudo ln -s -nbi a b""),
    (""ln -nbi a b && ls"", ""ln -s -nbi a b && ls""),
    (""ln a ln"", ""ln -s a ln""),
    (""sudo ln a ln"", ""sudo ln -s a ln"")])
def test_get_new_command(script, result):
    command = Command(script, '')
    assert get_new_command(command) == result<EOS>"
"<BOS>import pytest

from thefuck.rules.omnienv_no_such_command import get_new_command, match
from thefuck.types import Command


@pytest.fixture
def output(pyenv_cmd):
    return ""pyenv: no such command `{}'"".format(pyenv_cmd)


@pytest.fixture(autouse=True)
def Popen(mocker):
    mock = mocker.patch('thefuck.rules.omnienv_no_such_command.Popen')
    mock.return_value.stdout.readlines.return_value = (
        b'--version\nactivate\ncommands\ncompletions\ndeactivate\nexec_\n'
        b'global\nhelp\nhooks\ninit\ninstall\nlocal\nprefix_\n'
        b'realpath.dylib\nrehash\nroot\nshell\nshims\nuninstall\nversion_\n'
        b'version-file\nversion-file-read\nversion-file-write\nversion-name_\n'
        b'version-origin\nversions\nvirtualenv\nvirtualenv-delete_\n'
        b'virtualenv-init\nvirtualenv-prefix\nvirtualenvs_\n'
        b'virtualenvwrapper\nvirtualenvwrapper_lazy\nwhence\nwhich_\n'
    ).split()
    return mock


@pytest.mark.parametrize('script, pyenv_cmd', [
    ('pyenv globe', 'globe'),
    ('pyenv intall 3.8.0', 'intall'),
    ('pyenv list', 'list'),
])
def test_match(script, pyenv_cmd, output):
    assert match(Command(script, output=output))


def test_match_goenv_output_quote():
    """"""test goenv's specific output with quotes (')""""""
    assert match(Command('goenv list', output=""goenv: no such command 'list'""))


@pytest.mark.parametrize('script, output', [
    ('pyenv global', 'system'),
    ('pyenv versions', '  3.7.0\n  3.7.1\n* 3.7.2\n'),
    ('pyenv install --list', '  3.7.0\n  3.7.1\n  3.7.2\n'),
])
def test_not_match(script, output):
    assert not match(Command(script, output=output))


@pytest.mark.parametrize('script, pyenv_cmd, result', [
    ('pyenv globe', 'globe', 'pyenv global'),
    ('pyenv intall 3.8.0', 'intall', 'pyenv install 3.8.0'),
    ('pyenv list', 'list', 'pyenv install --list'),
    ('pyenv remove 3.8.0', 'remove', 'pyenv uninstall 3.8.0'),
])
def test_get_new_command(script, pyenv_cmd, output, result):
    assert result in get_new_command(Command(script, output))<EOS>"
"<BOS>import pytest
from thefuck.rules.terraform_init import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('script, output', [
    ('terraform plan', 'Error: Initialization required. '
                       'Please see the error message above.'),
    ('terraform plan', 'This module is not yet installed. Run ""terraform init"" '
                       'to install all modules required by this configuration.'),
    ('terraform apply', 'Error: Initialization required. '
                        'Please see the error message above.'),
    ('terraform apply', 'This module is not yet installed. Run ""terraform init"" '
                        'to install all modules required by this configuration.')])
def test_match(script, output):
    assert match(Command(script, output))


@pytest.mark.parametrize('script, output', [
    ('terraform --version', 'Terraform v0.12.2'),
    ('terraform plan', 'No changes. Infrastructure is up-to-date.'),
    ('terraform apply', 'Apply complete! Resources: 0 added, 0 changed, 0 destroyed.'),
])
def test_not_match(script, output):
    assert not match(Command(script, output=output))


@pytest.mark.parametrize('command, new_command', [
    (Command('terraform plan', ''), 'terraform init && terraform plan'),
    (Command('terraform apply', ''), 'terraform init && terraform apply'),
])
def test_get_new_command(command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>import pytest

from thefuck.types import Command
from thefuck.rules.tsuru_not_command import match, get_new_command


@pytest.mark.parametrize('command', [
    Command('tsuru log', (
        'tsuru: ""tchururu"" is not a tsuru command. See ""tsuru help"".\n'
        '\nDid you mean?\n'
        '\tapp-log\n'
        '\tlogin\n'
        '\tlogout\n'
    )),
    Command('tsuru app-l', (
        'tsuru: ""tchururu"" is not a tsuru command. See ""tsuru help"".\n'
        '\nDid you mean?\n'
        '\tapp-list\n'
        '\tapp-log\n'
    )),
    Command('tsuru user-list', (
        'tsuru: ""tchururu"" is not a tsuru command. See ""tsuru help"".\n'
        '\nDid you mean?\n'
        '\tteam-user-list\n'
    )),
    Command('tsuru targetlist', (
        'tsuru: ""tchururu"" is not a tsuru command. See ""tsuru help"".\n'
        '\nDid you mean?\n'
        '\ttarget-list\n'
    )),
])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('tsuru tchururu', (
        'tsuru: ""tchururu"" is not a tsuru command. See ""tsuru help"".\n'
        '\nDid you mean?\n'
    )),
    Command('tsuru version', 'tsuru version 0.16.0.'),
    Command('tsuru help', (
        'tsuru version 0.16.0.\n'
        '\nUsage: tsuru command [args]\n'
    )),
    Command('tsuru platform-list', (
        '- java\n'
        '- logstashgiro\n'
        '- newnode\n'
        '- nodejs\n'
        '- php\n'
        '- python\n'
        '- python3\n'
        '- ruby\n'
        '- ruby20\n'
        '- static\n'
    )),
    Command('tsuru env-get', 'Error: App thefuck not found.'),
])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('command, new_commands', [
    (Command('tsuru log', (
        'tsuru: ""log"" is not a tsuru command. See ""tsuru help"".\n'
        '\nDid you mean?\n'
        '\tapp-log\n'
        '\tlogin\n'
        '\tlogout\n'
    )), ['tsuru login', 'tsuru logout', 'tsuru app-log']),
    (Command('tsuru app-l', (
        'tsuru: ""app-l"" is not a tsuru command. See ""tsuru help"".\n'
        '\nDid you mean?\n'
        '\tapp-list\n'
        '\tapp-log\n'
    )), ['tsuru app-log', 'tsuru app-list']),
    (Command('tsuru user-list', (
        'tsuru: ""user-list"" is not a tsuru command. See ""tsuru help"".\n'
        '\nDid you mean?\n'
        '\tteam-user-list\n'
    )), ['tsuru team-user-list']),
    (Command('tsuru targetlist', (
        'tsuru: ""targetlist"" is not a tsuru command. See ""tsuru help"".\n'
        '\nDid you mean?\n'
        '\ttarget-list\n'
    )), ['tsuru target-list']),
])
def test_get_new_command(command, new_commands):
    assert get_new_command(command) == new_commands<EOS>"
"<BOS>import pytest
from thefuck.rules.yarn_help import match, get_new_command
from thefuck.types import Command
from thefuck.system import open_command


output_clean = '''

  Usage: yarn [command] [flags]

  Options:

    -h, --help                      output usage information
    -V, --version                   output the version number
    --verbose                       output verbose messages on internal operations
    --offline                       trigger an error if any required dependencies are not available in local cache
    --prefer-offline                use network only if dependencies are not available in local cache
    --strict-semver                 
    --json                          
    --ignore-scripts                don't run lifecycle scripts
    --har                           save HAR output of network traffic
    --ignore-platform               ignore platform checks
    --ignore-engines                ignore engines check
    --ignore-optional               ignore optional dependencies
    --force                         ignore all caches
    --no-bin-links                  don't generate bin links when setting up packages
    --flat                          only allow one version of a package
    --prod, --production [prod]     
    --no-lockfile                   don't read or generate a lockfile
    --pure-lockfile                 don't generate a lockfile
    --frozen-lockfile               don't generate a lockfile and fail if an update is needed
    --link-duplicates               create hardlinks to the repeated modules in node_modules
    --global-folder <path>          
    --modules-folder <path>         rather than installing modules into the node_modules folder relative to the cwd, output them here
    --cache-folder <path>           specify a custom folder to store the yarn cache
    --mutex <type>[:specifier]      use a mutex to ensure only one yarn instance is executing
    --no-emoji                      disable emoji in output
    --proxy <host>                  
    --https-proxy <host>            
    --no-progress                   disable progress bar
    --network-concurrency <number>  maximum number of concurrent network requests

  Visit https://yarnpkg.com/en/docs/cli/clean for documentation about this command.
'''  # noqa


@pytest.mark.parametrize('command', [
    Command('yarn help clean', output_clean)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, url', [
    (Command('yarn help clean', output_clean),
     'https://yarnpkg.com/en/docs/cli/clean')])
def test_get_new_command(command, url):
    assert get_new_command(command) == open_command(url)<EOS>"
"<BOS>import pytest
from thefuck.rules.brew_unknown_command import match, get_new_command
from thefuck.rules.brew_unknown_command import _brew_commands
from thefuck.types import Command


@pytest.fixture
def brew_unknown_cmd():
    return '''Error: Unknown command: inst'''


@pytest.fixture
def brew_unknown_cmd2():
    return '''Error: Unknown command: instaa'''


def test_match(brew_unknown_cmd):
    assert match(Command('brew inst', brew_unknown_cmd))
    for command in _brew_commands():
        assert not match(Command('brew ' + command, ''))


def test_get_new_command(brew_unknown_cmd, brew_unknown_cmd2):
    assert (get_new_command(Command('brew inst', brew_unknown_cmd))
            == ['brew list', 'brew install', 'brew uninstall'])

    cmds = get_new_command(Command('brew instaa', brew_unknown_cmd2))
    assert 'brew install' in cmds
    assert 'brew uninstall' in cmds<EOS>"
"<BOS>import pytest
from thefuck.rules.fab_command_not_found import match, get_new_command
from thefuck.types import Command

output = '''
Warning: Command(s) not found:
    extenson
    deloyp

Available commands:

    update_config
    prepare_extension
    Template               A string class for supporting $-substitutions.
    deploy
    glob                   Return a list of paths matching a pathname pattern.
    install_web
    set_version
'''


@pytest.mark.parametrize('command', [
    Command('fab extenson', output),
    Command('fab deloyp', output),
    Command('fab extenson deloyp', output)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('gulp extenson', output),
    Command('fab deloyp', '')])
def test_not_match(command):
    assert not match(command)


@pytest.mark.parametrize('script, result', [
    ('fab extenson', 'fab prepare_extension'),
    ('fab extenson:version=2016',
     'fab prepare_extension:version=2016'),
    ('fab extenson:version=2016 install_web set_version:val=0.5.0',
     'fab prepare_extension:version=2016 install_web set_version:val=0.5.0'),
    ('fab extenson:version=2016 deloyp:beta=true -H the.fuck',
     'fab prepare_extension:version=2016 deploy:beta=true -H the.fuck'),
])
def test_get_new_command(script, result):
    command = Command(script, output)
    assert get_new_command(command) == result<EOS>"
"<BOS>import pytest
from thefuck.rules.git_pull_clone import match, get_new_command
from thefuck.types import Command


git_err = '''
fatal: Not a git repository (or any parent up to mount point /home)
Stopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set).
'''


@pytest.mark.parametrize('command', [
    Command('git pull git@github.com:mcarton/thefuck.git', git_err)])
def test_match(command):
    assert match(command)


@pytest.mark.parametrize('command, output', [
    (Command('git pull git@github.com:mcarton/thefuck.git', git_err), 'git clone git@github.com:mcarton/thefuck.git')])
def test_get_new_command(command, output):
    assert get_new_command(command) == output<EOS>"
"<BOS>import pytest
from thefuck.rules.git_rm_recursive import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def output(target):
    return ""fatal: not removing '{}' recursively without -r"".format(target)


@pytest.mark.parametrize('script, target', [
    ('git rm foo', 'foo'),
    ('git rm foo bar', 'foo bar')])
def test_match(output, script, target):
    assert match(Command(script, output))


@pytest.mark.parametrize('script', ['git rm foo', 'git rm foo bar'])
def test_not_match(script):
    assert not match(Command(script, ''))


@pytest.mark.parametrize('script, target, new_command', [
    ('git rm foo', 'foo', 'git rm -r foo'),
    ('git rm foo bar', 'foo bar', 'git rm -r foo bar')])
def test_get_new_command(output, script, target, new_command):
    assert get_new_command(Command(script, output)) == new_command<EOS>"
"<BOS>import pytest
from io import BytesIO
from thefuck.rules.go_unknown_command import match, get_new_command
from thefuck.types import Command


@pytest.fixture
def build_misspelled_output():
    return '''go bulid: unknown command
Run 'go help' for usage.'''


@pytest.fixture
def go_stderr(mocker):
    stderr = b'''Go is a tool for managing Go source code.

Usage:

\tgo <command> [arguments]

The commands are:

\tbug         start a bug report
\tbuild       compile packages and dependencies
\tclean       remove object files and cached files
\tdoc         show documentation for package or symbol
\tenv         print Go environment information
\tfix         update packages to use new APIs
\tfmt         gofmt (reformat) package sources
\tgenerate    generate Go files by processing source
\tget         add dependencies to current module and install them
\tinstall     compile and install packages and dependencies
\tlist        list packages or modules
\tmod         module maintenance
\trun         compile and run Go program
\ttest        test packages
\ttool        run specified go tool
\tversion     print Go version
\tvet         report likely mistakes in packages

Use ""go help <command>"" for more information about a command.

Additional help topics:

\tbuildconstraint build constraints
\tbuildmode       build modes
\tc               calling between Go and C
\tcache           build and test caching
\tenvironment     environment variables
\tfiletype        file types
\tgo.mod          the go.mod file
\tgopath          GOPATH environment variable
\tgopath-get      legacy GOPATH go get
\tgoproxy         module proxy protocol
\timportpath      import path syntax
\tmodules         modules, module versions, and more
\tmodule-get      module-aware go get
\tmodule-auth     module authentication using go.sum
\tmodule-private  module configuration for non-public modules
\tpackages        package lists and patterns
\ttestflag        testing flags
\ttestfunc        testing functions

Use ""go help <topic>"" for more information about that topic.

'''
    mock = mocker.patch('subprocess.Popen')
    mock.return_value.stderr = BytesIO(stderr)
    return mock


def test_match(build_misspelled_output):
    assert match(Command('go bulid', build_misspelled_output))


def test_not_match():
    assert not match(Command('go run', 'go run: no go files listed'))


@pytest.mark.usefixtures('no_memoize', 'go_stderr')
def test_get_new_command(build_misspelled_output):
    assert get_new_command(Command('go bulid', build_misspelled_output)) == 'go build'<EOS>"
"<BOS>import pytest
from thefuck.rules.nixos_cmd_not_found import match, get_new_command
from thefuck.types import Command


@pytest.mark.parametrize('command', [
    Command('vim', 'nix-env -iA nixos.vim')])
def test_match(mocker, command):
    mocker.patch('thefuck.rules.nixos_cmd_not_found', return_value=None)
    assert match(command)


@pytest.mark.parametrize('command', [
    Command('vim', ''),
    Command('', '')])
def test_not_match(mocker, command):
    mocker.patch('thefuck.rules.nixos_cmd_not_found', return_value=None)
    assert not match(command)


@pytest.mark.parametrize('command, new_command', [
    (Command('vim', 'nix-env -iA nixos.vim'), 'nix-env -iA nixos.vim && vim'),
    (Command('pacman', 'nix-env -iA nixos.pacman'), 'nix-env -iA nixos.pacman && pacman')])
def test_get_new_command(mocker, command, new_command):
    assert get_new_command(command) == new_command<EOS>"
"<BOS>from io import BytesIO

import pytest
from thefuck.rules.port_already_in_use import match, get_new_command
from thefuck.types import Command

outputs = [
    '''

DE 70% 1/1 build modulesevents.js:141
      throw er; // Unhandled 'error' event
      ^

Error: listen EADDRINUSE 127.0.0.1:8080
    at Object.exports._errnoException (util.js:873:11)
    at exports._exceptionWithHostPort (util.js:896:20)
    at Server._listen2 (net.js:1250:14)
    at listen (net.js:1286:10)
    at net.js:1395:9
    at GetAddrInfoReqWrap.asyncCallback [as callback] (dns.js:64:16)
    at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:83:10)

    ''',
    '''
[6:40:01 AM] <START> Building Dependency Graph
[6:40:01 AM] <START> Crawling File System
 ERROR  Packager can't listen on port 8080
Most likely another process is already using this port
Run the following command to find out which process:

   lsof -n -i4TCP:8080

You can either shut down the other process:

   kill -9 <PID>

or run packager on different port.

    ''',
    '''
Traceback (most recent call last):
  File ""/usr/lib/python3.5/runpy.py"", line 184, in _run_module_as_main
    ""__main__"", mod_spec)
  File ""/usr/lib/python3.5/runpy.py"", line 85, in _run_code
    exec(code, run_globals)
  File ""/home/nvbn/exp/code_view/server/code_view/main.py"", line 14, in <module>
    web.run_app(app)
  File ""/home/nvbn/.virtualenvs/code_view/lib/python3.5/site-packages/aiohttp/web.py"", line 310, in run_app
    backlog=backlog))
  File ""/usr/lib/python3.5/asyncio/base_events.py"", line 373, in run_until_complete
    return future.result()
  File ""/usr/lib/python3.5/asyncio/futures.py"", line 274, in result
    raise self._exception
  File ""/usr/lib/python3.5/asyncio/tasks.py"", line 240, in _step
    result = coro.send(None)
  File ""/usr/lib/python3.5/asyncio/base_events.py"", line 953, in create_server
    % (sa, err.strerror.lower()))
OSError: [Errno 98] error while attempting to bind on address ('0.0.0.0', 8080): address already in use
Task was destroyed but it is pending!
task: <Task pending coro=<RedisProtocol._reader_coroutine() running at /home/nvbn/.virtualenvs/code_view/lib/python3.5/site-packages/asyncio_redis/protocol.py:921> wait_for=<Future pending cb=[Task._wakeup()]>>
    '''
]

lsof_stdout = b'''COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
node    18233 nvbn   16u  IPv4 557134      0t0  TCP localhost:http-alt (LISTEN)
'''


@pytest.fixture(autouse=True)
def lsof(mocker):
    patch = mocker.patch('thefuck.rules.port_already_in_use.Popen')
    patch.return_value.stdout = BytesIO(lsof_stdout)
    return patch


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize(
    'command',
    [Command('./app', output) for output in outputs]
    + [Command('./app', output) for output in outputs])
def test_match(command):
    assert match(command)


@pytest.mark.usefixtures('no_memoize')
@pytest.mark.parametrize('command, lsof_output', [
    (Command('./app', ''), lsof_stdout),
    (Command('./app', outputs[1]), b''),
    (Command('./app', outputs[2]), b'')])
def test_not_match(lsof, command, lsof_output):
    lsof.return_value.stdout = BytesIO(lsof_output)

    assert not match(command)


@pytest.mark.parametrize(
    'command',
    [Command('./app', output) for output in outputs]
    + [Command('./app', output) for output in outputs])
def test_get_new_command(command):
    assert get_new_command(command) == 'kill 18233 && ./app'<EOS>"
"<BOS>import pytest
import json
from six import StringIO
from mock import MagicMock
from thefuck.shells.generic import ShellConfiguration
from thefuck.entrypoints.not_configured import main


@pytest.fixture(autouse=True)
def usage_tracker(mocker):
    return mocker.patch(
        'thefuck.entrypoints.not_configured._get_not_configured_usage_tracker_path',
        new_callable=MagicMock)


@pytest.fixture(autouse=True)
def usage_tracker_io(usage_tracker):
    io = StringIO()
    usage_tracker.return_value \
                 .open.return_value \
                 .__enter__.return_value = io
    return io


@pytest.fixture(autouse=True)
def usage_tracker_exists(usage_tracker):
    usage_tracker.return_value \
                 .exists.return_value = True
    return usage_tracker.return_value.exists


def _assert_tracker_updated(usage_tracker_io, pid):
    usage_tracker_io.seek(0)
    info = json.load(usage_tracker_io)
    assert info['pid'] == pid


def _change_tracker(usage_tracker_io, pid):
    usage_tracker_io.truncate(0)
    info = {'pid': pid, 'time': 0}
    json.dump(info, usage_tracker_io)
    usage_tracker_io.seek(0)


@pytest.fixture(autouse=True)
def shell_pid(mocker):
    return mocker.patch('thefuck.entrypoints.not_configured._get_shell_pid',
                        new_callable=MagicMock)


@pytest.fixture(autouse=True)
def shell(mocker):
    shell = mocker.patch('thefuck.entrypoints.not_configured.shell',
                         new_callable=MagicMock)
    shell.get_history.return_value = []
    shell.how_to_configure.return_value = ShellConfiguration(
        content='eval $(thefuck --alias)',
        path='/tmp/.bashrc',
        reload='bash',
        can_configure_automatically=True)
    return shell


@pytest.fixture(autouse=True)
def shell_config(mocker):
    path_mock = mocker.patch('thefuck.entrypoints.not_configured.Path',
                             new_callable=MagicMock)
    return path_mock.return_value \
        .expanduser.return_value \
        .open.return_value \
        .__enter__.return_value


@pytest.fixture(autouse=True)
def logs(mocker):
    return mocker.patch('thefuck.entrypoints.not_configured.logs',
                        new_callable=MagicMock)


def test_for_generic_shell(shell, logs):
    shell.how_to_configure.return_value = None
    main()
    logs.how_to_configure_alias.assert_called_once()


def test_on_first_run(usage_tracker_io, usage_tracker_exists, shell_pid, logs):
    shell_pid.return_value = 12
    main()
    usage_tracker_exists.return_value = False
    _assert_tracker_updated(usage_tracker_io, 12)
    logs.how_to_configure_alias.assert_called_once()


def test_on_run_after_other_commands(usage_tracker_io, shell_pid, shell, logs):
    shell_pid.return_value = 12
    shell.get_history.return_value = ['fuck', 'ls']
    _change_tracker(usage_tracker_io, 12)
    main()
    logs.how_to_configure_alias.assert_called_once()


def test_on_first_run_from_current_shell(usage_tracker_io, shell_pid,
                                         shell, logs):
    shell.get_history.return_value = ['fuck']
    shell_pid.return_value = 12
    main()
    _assert_tracker_updated(usage_tracker_io, 12)
    logs.how_to_configure_alias.assert_called_once()


def test_when_cant_configure_automatically(shell_pid, shell, logs):
    shell_pid.return_value = 12
    shell.how_to_configure.return_value = ShellConfiguration(
        content='eval $(thefuck --alias)',
        path='/tmp/.bashrc',
        reload='bash',
        can_configure_automatically=False)
    main()
    logs.how_to_configure_alias.assert_called_once()


def test_when_already_configured(usage_tracker_io, shell_pid,
                                 shell, shell_config, logs):
    shell.get_history.return_value = ['fuck']
    shell_pid.return_value = 12
    _change_tracker(usage_tracker_io, 12)
    shell_config.read.return_value = 'eval $(thefuck --alias)'
    main()
    logs.already_configured.assert_called_once()


def test_when_successfully_configured(usage_tracker_io, shell_pid,
                                      shell, shell_config, logs):
    shell.get_history.return_value = ['fuck']
    shell_pid.return_value = 12
    _change_tracker(usage_tracker_io, 12)
    shell_config.read.return_value = ''
    main()
    shell_config.write.assert_any_call('eval $(thefuck --alias)')
    logs.configured_successfully.assert_called_once()<EOS>"
"<BOS>import pytest
from mock import Mock
from thefuck.entrypoints.fix_command import _get_raw_command


class TestGetRawCommand(object):
    def test_from_force_command_argument(self):
        known_args = Mock(force_command='git brunch')
        assert _get_raw_command(known_args) == ['git brunch']

    def test_from_command_argument(self, os_environ):
        os_environ['TF_HISTORY'] = None
        known_args = Mock(force_command=None,
                          command=['sl'])
        assert _get_raw_command(known_args) == ['sl']

    @pytest.mark.parametrize('history, result', [
        ('git br', 'git br'),
        ('git br\nfcuk', 'git br'),
        ('git br\nfcuk\nls', 'ls'),
        ('git br\nfcuk\nls\nfuk', 'ls')])
    def test_from_history(self, os_environ, history, result):
        os_environ['TF_HISTORY'] = history
        known_args = Mock(force_command=None,
                          command=None)
        assert _get_raw_command(known_args) == [result]<EOS>"
"<BOS>from mock import Mock
import pytest
from thefuck.entrypoints.alias import _get_alias, print_alias


@pytest.mark.parametrize(
    'py2, enable_experimental_instant_mode, which, is_instant', [
        (False, True, True, True),
        (False, False, True, False),
        (False, True, False, False),
        (True, True, True, False),
        (True, True, False, False),
        (True, False, True, False)])
def test_get_alias(monkeypatch, mocker, py2,
                   enable_experimental_instant_mode,
                   which, is_instant):
    monkeypatch.setattr('six.PY2', py2)
    args = Mock(
        enable_experimental_instant_mode=enable_experimental_instant_mode,
        alias='fuck', )
    mocker.patch('thefuck.entrypoints.alias.which', return_value=which)
    shell = Mock(app_alias=lambda _: 'app_alias',
                 instant_mode_alias=lambda _: 'instant_mode_alias')
    monkeypatch.setattr('thefuck.entrypoints.alias.shell', shell)

    alias = _get_alias(args)
    if is_instant:
        assert alias == 'instant_mode_alias'
    else:
        assert alias == 'app_alias'


def test_print_alias(mocker):
    settings_mock = mocker.patch('thefuck.entrypoints.alias.settings')
    _get_alias_mock = mocker.patch('thefuck.entrypoints.alias._get_alias')
    known_args = Mock()
    print_alias(known_args)
    settings_mock.init.assert_called_once_with(known_args)
    _get_alias_mock.assert_called_once_with(known_args)<EOS>"
"<BOS>from django.utils.version import get_version

VERSION = (4, 1, 0, ""alpha"", 0)

__version__ = get_version(VERSION)


def setup(set_prefix=True):
    """"""
    Configure the settings (this happens as a side effect of accessing the
    first setting), configure logging and populate the app registry.
    Set the thread-local urlresolvers script prefix if `set_prefix` is True.
    """"""
    from django.apps import apps
    from django.conf import settings
    from django.urls import set_script_prefix
    from django.utils.log import configure_logging

    configure_logging(settings.LOGGING_CONFIG, settings.LOGGING)
    if set_prefix:
        set_script_prefix(
            ""/"" if settings.FORCE_SCRIPT_NAME is None else settings.FORCE_SCRIPT_NAME
        )
    apps.populate(settings.INSTALLED_APPS)<EOS>"
"<BOS>""""""
Invokes django-admin when the django module is run as a script.

Example: python -m django check
""""""
from django.core import management

if __name__ == ""__main__"":
    management.execute_from_command_line()<EOS>"
"<BOS>""""""
Default Django settings. Override these with settings in the module pointed to
by the DJANGO_SETTINGS_MODULE environment variable.
""""""


# This is defined here as a do-nothing function because we can't import
# django.utils.translation -- that module depends on the settings.
def gettext_noop(s):
    return s


####################
# CORE             #
####################

DEBUG = False

# Whether the framework should propagate raw exceptions rather than catching
# them. This is useful under some testing situations and should never be used
# on a live site.
DEBUG_PROPAGATE_EXCEPTIONS = False

# People who get code error notifications. In the format
# [('Full Name', 'email@example.com'), ('Full Name', 'anotheremail@example.com')]
ADMINS = []

# List of IP addresses, as strings, that:
#   * See debug comments, when DEBUG is true
#   * Receive x-headers
INTERNAL_IPS = []

# Hosts/domain names that are valid for this site.
# ""*"" matches anything, "".example.com"" matches example.com and all subdomains
ALLOWED_HOSTS = []

# Local time zone for this installation. All choices can be found here:
# https://en.wikipedia.org/wiki/List_of_tz_zones_by_name (although not all
# systems may support all possibilities). When USE_TZ is True, this is
# interpreted as the default user time zone.
TIME_ZONE = ""America/Chicago""

# If you set this to True, Django will use timezone-aware datetimes.
USE_TZ = False

# RemovedInDjango50Warning: It's a transitional setting helpful in migrating
# from pytz tzinfo to ZoneInfo(). Set True to continue using pytz tzinfo
# objects during the Django 4.x release cycle.
USE_DEPRECATED_PYTZ = False

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = ""en-us""

# Languages we provide translations for, out of the box.
LANGUAGES = [
    (""af"", gettext_noop(""Afrikaans"")),
    (""ar"", gettext_noop(""Arabic"")),
    (""ar-dz"", gettext_noop(""Algerian Arabic"")),
    (""ast"", gettext_noop(""Asturian"")),
    (""az"", gettext_noop(""Azerbaijani"")),
    (""bg"", gettext_noop(""Bulgarian"")),
    (""be"", gettext_noop(""Belarusian"")),
    (""bn"", gettext_noop(""Bengali"")),
    (""br"", gettext_noop(""Breton"")),
    (""bs"", gettext_noop(""Bosnian"")),
    (""ca"", gettext_noop(""Catalan"")),
    (""cs"", gettext_noop(""Czech"")),
    (""cy"", gettext_noop(""Welsh"")),
    (""da"", gettext_noop(""Danish"")),
    (""de"", gettext_noop(""German"")),
    (""dsb"", gettext_noop(""Lower Sorbian"")),
    (""el"", gettext_noop(""Greek"")),
    (""en"", gettext_noop(""English"")),
    (""en-au"", gettext_noop(""Australian English"")),
    (""en-gb"", gettext_noop(""British English"")),
    (""eo"", gettext_noop(""Esperanto"")),
    (""es"", gettext_noop(""Spanish"")),
    (""es-ar"", gettext_noop(""Argentinian Spanish"")),
    (""es-co"", gettext_noop(""Colombian Spanish"")),
    (""es-mx"", gettext_noop(""Mexican Spanish"")),
    (""es-ni"", gettext_noop(""Nicaraguan Spanish"")),
    (""es-ve"", gettext_noop(""Venezuelan Spanish"")),
    (""et"", gettext_noop(""Estonian"")),
    (""eu"", gettext_noop(""Basque"")),
    (""fa"", gettext_noop(""Persian"")),
    (""fi"", gettext_noop(""Finnish"")),
    (""fr"", gettext_noop(""French"")),
    (""fy"", gettext_noop(""Frisian"")),
    (""ga"", gettext_noop(""Irish"")),
    (""gd"", gettext_noop(""Scottish Gaelic"")),
    (""gl"", gettext_noop(""Galician"")),
    (""he"", gettext_noop(""Hebrew"")),
    (""hi"", gettext_noop(""Hindi"")),
    (""hr"", gettext_noop(""Croatian"")),
    (""hsb"", gettext_noop(""Upper Sorbian"")),
    (""hu"", gettext_noop(""Hungarian"")),
    (""hy"", gettext_noop(""Armenian"")),
    (""ia"", gettext_noop(""Interlingua"")),
    (""id"", gettext_noop(""Indonesian"")),
    (""ig"", gettext_noop(""Igbo"")),
    (""io"", gettext_noop(""Ido"")),
    (""is"", gettext_noop(""Icelandic"")),
    (""it"", gettext_noop(""Italian"")),
    (""ja"", gettext_noop(""Japanese"")),
    (""ka"", gettext_noop(""Georgian"")),
    (""kab"", gettext_noop(""Kabyle"")),
    (""kk"", gettext_noop(""Kazakh"")),
    (""km"", gettext_noop(""Khmer"")),
    (""kn"", gettext_noop(""Kannada"")),
    (""ko"", gettext_noop(""Korean"")),
    (""ky"", gettext_noop(""Kyrgyz"")),
    (""lb"", gettext_noop(""Luxembourgish"")),
    (""lt"", gettext_noop(""Lithuanian"")),
    (""lv"", gettext_noop(""Latvian"")),
    (""mk"", gettext_noop(""Macedonian"")),
    (""ml"", gettext_noop(""Malayalam"")),
    (""mn"", gettext_noop(""Mongolian"")),
    (""mr"", gettext_noop(""Marathi"")),
    (""ms"", gettext_noop(""Malay"")),
    (""my"", gettext_noop(""Burmese"")),
    (""nb"", gettext_noop(""Norwegian Bokmål"")),
    (""ne"", gettext_noop(""Nepali"")),
    (""nl"", gettext_noop(""Dutch"")),
    (""nn"", gettext_noop(""Norwegian Nynorsk"")),
    (""os"", gettext_noop(""Ossetic"")),
    (""pa"", gettext_noop(""Punjabi"")),
    (""pl"", gettext_noop(""Polish"")),
    (""pt"", gettext_noop(""Portuguese"")),
    (""pt-br"", gettext_noop(""Brazilian Portuguese"")),
    (""ro"", gettext_noop(""Romanian"")),
    (""ru"", gettext_noop(""Russian"")),
    (""sk"", gettext_noop(""Slovak"")),
    (""sl"", gettext_noop(""Slovenian"")),
    (""sq"", gettext_noop(""Albanian"")),
    (""sr"", gettext_noop(""Serbian"")),
    (""sr-latn"", gettext_noop(""Serbian Latin"")),
    (""sv"", gettext_noop(""Swedish"")),
    (""sw"", gettext_noop(""Swahili"")),
    (""ta"", gettext_noop(""Tamil"")),
    (""te"", gettext_noop(""Telugu"")),
    (""tg"", gettext_noop(""Tajik"")),
    (""th"", gettext_noop(""Thai"")),
    (""tk"", gettext_noop(""Turkmen"")),
    (""tr"", gettext_noop(""Turkish"")),
    (""tt"", gettext_noop(""Tatar"")),
    (""udm"", gettext_noop(""Udmurt"")),
    (""uk"", gettext_noop(""Ukrainian"")),
    (""ur"", gettext_noop(""Urdu"")),
    (""uz"", gettext_noop(""Uzbek"")),
    (""vi"", gettext_noop(""Vietnamese"")),
    (""zh-hans"", gettext_noop(""Simplified Chinese"")),
    (""zh-hant"", gettext_noop(""Traditional Chinese"")),
]

# Languages using BiDi (right-to-left) layout
LANGUAGES_BIDI = [""he"", ""ar"", ""ar-dz"", ""fa"", ""ur""]

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True
LOCALE_PATHS = []

# Settings for language cookie
LANGUAGE_COOKIE_NAME = ""django_language""
LANGUAGE_COOKIE_AGE = None
LANGUAGE_COOKIE_DOMAIN = None
LANGUAGE_COOKIE_PATH = ""/""
LANGUAGE_COOKIE_SECURE = False
LANGUAGE_COOKIE_HTTPONLY = False
LANGUAGE_COOKIE_SAMESITE = None


# If you set this to True, Django will format dates, numbers and calendars
# according to user current locale.
USE_L10N = True

# Not-necessarily-technical managers of the site. They get broken link
# notifications and other various emails.
MANAGERS = ADMINS

# Default charset to use for all HttpResponse objects, if a MIME type isn't
# manually specified. It's used to construct the Content-Type header.
DEFAULT_CHARSET = ""utf-8""

# Email address that error messages come from.
SERVER_EMAIL = ""root@localhost""

# Database connection info. If left empty, will default to the dummy backend.
DATABASES = {}

# Classes used to implement DB routing behavior.
DATABASE_ROUTERS = []

# The email backend to use. For possible shortcuts see django.core.mail.
# The default is to use the SMTP backend.
# Third-party backends can be specified by providing a Python path
# to a module that defines an EmailBackend class.
EMAIL_BACKEND = ""django.core.mail.backends.smtp.EmailBackend""

# Host for sending email.
EMAIL_HOST = ""localhost""

# Port for sending email.
EMAIL_PORT = 25

# Whether to send SMTP 'Date' header in the local time zone or in UTC.
EMAIL_USE_LOCALTIME = False

# Optional SMTP authentication information for EMAIL_HOST.
EMAIL_HOST_USER = """"
EMAIL_HOST_PASSWORD = """"
EMAIL_USE_TLS = False
EMAIL_USE_SSL = False
EMAIL_SSL_CERTFILE = None
EMAIL_SSL_KEYFILE = None
EMAIL_TIMEOUT = None

# List of strings representing installed apps.
INSTALLED_APPS = []

TEMPLATES = []

# Default form rendering class.
FORM_RENDERER = ""django.forms.renderers.DjangoTemplates""

# Default email address to use for various automated correspondence from
# the site managers.
DEFAULT_FROM_EMAIL = ""webmaster@localhost""

# Subject-line prefix for email messages send with django.core.mail.mail_admins
# or ...mail_managers.  Make sure to include the trailing space.
EMAIL_SUBJECT_PREFIX = ""[Django] ""

# Whether to append trailing slashes to URLs.
APPEND_SLASH = True

# Whether to prepend the ""www."" subdomain to URLs that don't have it.
PREPEND_WWW = False

# Override the server-derived value of SCRIPT_NAME
FORCE_SCRIPT_NAME = None

# List of compiled regular expression objects representing User-Agent strings
# that are not allowed to visit any page, systemwide. Use this for bad
# robots/crawlers. Here are a few examples:
#     import re
#     DISALLOWED_USER_AGENTS = [
#         re.compile(r'^NaverBot.*'),
#         re.compile(r'^EmailSiphon.*'),
#         re.compile(r'^SiteSucker.*'),
#         re.compile(r'^sohu-search'),
#     ]
DISALLOWED_USER_AGENTS = []

ABSOLUTE_URL_OVERRIDES = {}

# List of compiled regular expression objects representing URLs that need not
# be reported by BrokenLinkEmailsMiddleware. Here are a few examples:
#    import re
#    IGNORABLE_404_URLS = [
#        re.compile(r'^/apple-touch-icon.*\.png$'),
#        re.compile(r'^/favicon.ico$'),
#        re.compile(r'^/robots.txt$'),
#        re.compile(r'^/phpmyadmin/'),
#        re.compile(r'\.(cgi|php|pl)$'),
#    ]
IGNORABLE_404_URLS = []

# A secret key for this particular Django installation. Used in secret-key
# hashing algorithms. Set this in your settings, or Django will complain
# loudly.
SECRET_KEY = """"

# List of secret keys used to verify the validity of signatures. This allows
# secret key rotation.
SECRET_KEY_FALLBACKS = []

# Default file storage mechanism that holds media.
DEFAULT_FILE_STORAGE = ""django.core.files.storage.FileSystemStorage""

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: ""/var/www/example.com/media/""
MEDIA_ROOT = """"

# URL that handles the media served from MEDIA_ROOT.
# Examples: ""http://example.com/media/"", ""http://media.example.com/""
MEDIA_URL = """"

# Absolute path to the directory static files should be collected to.
# Example: ""/var/www/example.com/static/""
STATIC_ROOT = None

# URL that handles the static files served from STATIC_ROOT.
# Example: ""http://example.com/static/"", ""http://static.example.com/""
STATIC_URL = None

# List of upload handler classes to be applied in order.
FILE_UPLOAD_HANDLERS = [
    ""django.core.files.uploadhandler.MemoryFileUploadHandler"",
    ""django.core.files.uploadhandler.TemporaryFileUploadHandler"",
]

# Maximum size, in bytes, of a request before it will be streamed to the
# file system instead of into memory.
FILE_UPLOAD_MAX_MEMORY_SIZE = 2621440  # i.e. 2.5 MB

# Maximum size in bytes of request data (excluding file uploads) that will be
# read before a SuspiciousOperation (RequestDataTooBig) is raised.
DATA_UPLOAD_MAX_MEMORY_SIZE = 2621440  # i.e. 2.5 MB

# Maximum number of GET/POST parameters that will be read before a
# SuspiciousOperation (TooManyFieldsSent) is raised.
DATA_UPLOAD_MAX_NUMBER_FIELDS = 1000

# Directory in which upload streamed files will be temporarily saved. A value of
# `None` will make Django use the operating system's default temporary directory
# (i.e. ""/tmp"" on *nix systems).
FILE_UPLOAD_TEMP_DIR = None

# The numeric mode to set newly-uploaded files to. The value should be a mode
# you'd pass directly to os.chmod; see
# https://docs.python.org/library/os.html#files-and-directories.
FILE_UPLOAD_PERMISSIONS = 0o644

# The numeric mode to assign to newly-created directories, when uploading files.
# The value should be a mode as you'd pass to os.chmod;
# see https://docs.python.org/library/os.html#files-and-directories.
FILE_UPLOAD_DIRECTORY_PERMISSIONS = None

# Python module path where user will place custom format definition.
# The directory where this setting is pointing should contain subdirectories
# named as the locales, containing a formats.py file
# (i.e. ""myproject.locale"" for myproject/locale/en/formats.py etc. use)
FORMAT_MODULE_PATH = None

# Default formatting for date objects. See all available format strings here:
# https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""N j, Y""

# Default formatting for datetime objects. See all available format strings here:
# https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATETIME_FORMAT = ""N j, Y, P""

# Default formatting for time objects. See all available format strings here:
# https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
TIME_FORMAT = ""P""

# Default formatting for date objects when only the year and month are relevant.
# See all available format strings here:
# https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
YEAR_MONTH_FORMAT = ""F Y""

# Default formatting for date objects when only the month and day are relevant.
# See all available format strings here:
# https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
MONTH_DAY_FORMAT = ""F j""

# Default short formatting for date objects. See all available format strings here:
# https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
SHORT_DATE_FORMAT = ""m/d/Y""

# Default short formatting for datetime objects.
# See all available format strings here:
# https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
SHORT_DATETIME_FORMAT = ""m/d/Y P""

# Default formats to be used when parsing dates from input boxes, in order
# See all available format string here:
# https://docs.python.org/library/datetime.html#strftime-behavior
# * Note that these format strings are different from the ones to display dates
DATE_INPUT_FORMATS = [
    ""%Y-%m-%d"",  # '2006-10-25'
    ""%m/%d/%Y"",  # '10/25/2006'
    ""%m/%d/%y"",  # '10/25/06'
    ""%b %d %Y"",  # 'Oct 25 2006'
    ""%b %d, %Y"",  # 'Oct 25, 2006'
    ""%d %b %Y"",  # '25 Oct 2006'
    ""%d %b, %Y"",  # '25 Oct, 2006'
    ""%B %d %Y"",  # 'October 25 2006'
    ""%B %d, %Y"",  # 'October 25, 2006'
    ""%d %B %Y"",  # '25 October 2006'
    ""%d %B, %Y"",  # '25 October, 2006'
]

# Default formats to be used when parsing times from input boxes, in order
# See all available format string here:
# https://docs.python.org/library/datetime.html#strftime-behavior
# * Note that these format strings are different from the ones to display dates
TIME_INPUT_FORMATS = [
    ""%H:%M:%S"",  # '14:30:59'
    ""%H:%M:%S.%f"",  # '14:30:59.000200'
    ""%H:%M"",  # '14:30'
]

# Default formats to be used when parsing dates and times from input boxes,
# in order
# See all available format string here:
# https://docs.python.org/library/datetime.html#strftime-behavior
# * Note that these format strings are different from the ones to display dates
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%m/%d/%Y %H:%M:%S"",  # '10/25/2006 14:30:59'
    ""%m/%d/%Y %H:%M:%S.%f"",  # '10/25/2006 14:30:59.000200'
    ""%m/%d/%Y %H:%M"",  # '10/25/2006 14:30'
    ""%m/%d/%y %H:%M:%S"",  # '10/25/06 14:30:59'
    ""%m/%d/%y %H:%M:%S.%f"",  # '10/25/06 14:30:59.000200'
    ""%m/%d/%y %H:%M"",  # '10/25/06 14:30'
]

# First day of week, to be used on calendars
# 0 means Sunday, 1 means Monday...
FIRST_DAY_OF_WEEK = 0

# Decimal separator symbol
DECIMAL_SEPARATOR = "".""

# Boolean that sets whether to add thousand separator when formatting numbers
USE_THOUSAND_SEPARATOR = False

# Number of digits that will be together, when splitting them by
# THOUSAND_SEPARATOR. 0 means no grouping, 3 means splitting by thousands...
NUMBER_GROUPING = 0

# Thousand separator symbol
THOUSAND_SEPARATOR = "",""

# The tablespaces to use for each model when not specified otherwise.
DEFAULT_TABLESPACE = """"
DEFAULT_INDEX_TABLESPACE = """"

# Default primary key field type.
DEFAULT_AUTO_FIELD = ""django.db.models.AutoField""

# Default X-Frame-Options header value
X_FRAME_OPTIONS = ""DENY""

USE_X_FORWARDED_HOST = False
USE_X_FORWARDED_PORT = False

# The Python dotted path to the WSGI application that Django's internal server
# (runserver) will use. If `None`, the return value of
# 'django.core.wsgi.get_wsgi_application' is used, thus preserving the same
# behavior as previous versions of Django. Otherwise this should point to an
# actual WSGI application object.
WSGI_APPLICATION = None

# If your Django app is behind a proxy that sets a header to specify secure
# connections, AND that proxy ensures that user-submitted headers with the
# same name are ignored (so that people can't spoof it), set this value to
# a tuple of (header_name, header_value). For any requests that come in with
# that header/value, request.is_secure() will return True.
# WARNING! Only set this if you fully understand what you're doing. Otherwise,
# you may be opening yourself up to a security risk.
SECURE_PROXY_SSL_HEADER = None

##############
# MIDDLEWARE #
##############

# List of middleware to use. Order is important; in the request phase, these
# middleware will be applied in the order given, and in the response
# phase the middleware will be applied in reverse order.
MIDDLEWARE = []

############
# SESSIONS #
############

# Cache to store session data if using the cache session backend.
SESSION_CACHE_ALIAS = ""default""
# Cookie name. This can be whatever you want.
SESSION_COOKIE_NAME = ""sessionid""
# Age of cookie, in seconds (default: 2 weeks).
SESSION_COOKIE_AGE = 60 * 60 * 24 * 7 * 2
# A string like ""example.com"", or None for standard domain cookie.
SESSION_COOKIE_DOMAIN = None
# Whether the session cookie should be secure (https:// only).
SESSION_COOKIE_SECURE = False
# The path of the session cookie.
SESSION_COOKIE_PATH = ""/""
# Whether to use the HttpOnly flag.
SESSION_COOKIE_HTTPONLY = True
# Whether to set the flag restricting cookie leaks on cross-site requests.
# This can be 'Lax', 'Strict', 'None', or False to disable the flag.
SESSION_COOKIE_SAMESITE = ""Lax""
# Whether to save the session data on every request.
SESSION_SAVE_EVERY_REQUEST = False
# Whether a user's session cookie expires when the web browser is closed.
SESSION_EXPIRE_AT_BROWSER_CLOSE = False
# The module to store session data
SESSION_ENGINE = ""django.contrib.sessions.backends.db""
# Directory to store session files if using the file session module. If None,
# the backend will use a sensible default.
SESSION_FILE_PATH = None
# class to serialize session data
SESSION_SERIALIZER = ""django.contrib.sessions.serializers.JSONSerializer""

#########
# CACHE #
#########

# The cache backends to use.
CACHES = {
    ""default"": {
        ""BACKEND"": ""django.core.cache.backends.locmem.LocMemCache"",
    }
}
CACHE_MIDDLEWARE_KEY_PREFIX = """"
CACHE_MIDDLEWARE_SECONDS = 600
CACHE_MIDDLEWARE_ALIAS = ""default""

##################
# AUTHENTICATION #
##################

AUTH_USER_MODEL = ""auth.User""

AUTHENTICATION_BACKENDS = [""django.contrib.auth.backends.ModelBackend""]

LOGIN_URL = ""/accounts/login/""

LOGIN_REDIRECT_URL = ""/accounts/profile/""

LOGOUT_REDIRECT_URL = None

# The number of seconds a password reset link is valid for (default: 3 days).
PASSWORD_RESET_TIMEOUT = 60 * 60 * 24 * 3

# the first hasher in this list is the preferred algorithm.  any
# password using different algorithms will be converted automatically
# upon login
PASSWORD_HASHERS = [
    ""django.contrib.auth.hashers.PBKDF2PasswordHasher"",
    ""django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher"",
    ""django.contrib.auth.hashers.Argon2PasswordHasher"",
    ""django.contrib.auth.hashers.BCryptSHA256PasswordHasher"",
    ""django.contrib.auth.hashers.ScryptPasswordHasher"",
]

AUTH_PASSWORD_VALIDATORS = []

###########
# SIGNING #
###########

SIGNING_BACKEND = ""django.core.signing.TimestampSigner""

########
# CSRF #
########

# Dotted path to callable to be used as view when a request is
# rejected by the CSRF middleware.
CSRF_FAILURE_VIEW = ""django.views.csrf.csrf_failure""

# Settings for CSRF cookie.
CSRF_COOKIE_NAME = ""csrftoken""
CSRF_COOKIE_AGE = 60 * 60 * 24 * 7 * 52
CSRF_COOKIE_DOMAIN = None
CSRF_COOKIE_PATH = ""/""
CSRF_COOKIE_SECURE = False
CSRF_COOKIE_HTTPONLY = False
CSRF_COOKIE_SAMESITE = ""Lax""
CSRF_HEADER_NAME = ""HTTP_X_CSRFTOKEN""
CSRF_TRUSTED_ORIGINS = []
CSRF_USE_SESSIONS = False

# Whether to mask CSRF cookie value. It's a transitional setting helpful in
# migrating multiple instance of the same project to Django 4.1+.
CSRF_COOKIE_MASKED = False

############
# MESSAGES #
############

# Class to use as messages backend
MESSAGE_STORAGE = ""django.contrib.messages.storage.fallback.FallbackStorage""

# Default values of MESSAGE_LEVEL and MESSAGE_TAGS are defined within
# django.contrib.messages to avoid imports in this settings file.

###########
# LOGGING #
###########

# The callable to use to configure logging
LOGGING_CONFIG = ""logging.config.dictConfig""

# Custom logging configuration.
LOGGING = {}

# Default exception reporter class used in case none has been
# specifically assigned to the HttpRequest instance.
DEFAULT_EXCEPTION_REPORTER = ""django.views.debug.ExceptionReporter""

# Default exception reporter filter class used in case none has been
# specifically assigned to the HttpRequest instance.
DEFAULT_EXCEPTION_REPORTER_FILTER = ""django.views.debug.SafeExceptionReporterFilter""

###########
# TESTING #
###########

# The name of the class to use to run the test suite
TEST_RUNNER = ""django.test.runner.DiscoverRunner""

# Apps that don't need to be serialized at test database creation time
# (only apps with migrations are to start with)
TEST_NON_SERIALIZED_APPS = []

############
# FIXTURES #
############

# The list of directories to search for fixtures
FIXTURE_DIRS = []

###############
# STATICFILES #
###############

# A list of locations of additional static files
STATICFILES_DIRS = []

# The default file storage backend used during the build process
STATICFILES_STORAGE = ""django.contrib.staticfiles.storage.StaticFilesStorage""

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = [
    ""django.contrib.staticfiles.finders.FileSystemFinder"",
    ""django.contrib.staticfiles.finders.AppDirectoriesFinder"",
    # 'django.contrib.staticfiles.finders.DefaultStorageFinder',
]

##############
# MIGRATIONS #
##############

# Migration module overrides for apps, by app label.
MIGRATION_MODULES = {}

#################
# SYSTEM CHECKS #
#################

# List of all issues generated by system checks that should be silenced. Light
# issues like warnings, infos or debugs will not generate a message. Silencing
# serious issues like errors and criticals does not result in hiding the
# message, but Django will not stop you from e.g. running server.
SILENCED_SYSTEM_CHECKS = []

#######################
# SECURITY MIDDLEWARE #
#######################
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_CROSS_ORIGIN_OPENER_POLICY = ""same-origin""
SECURE_HSTS_INCLUDE_SUBDOMAINS = False
SECURE_HSTS_PRELOAD = False
SECURE_HSTS_SECONDS = 0
SECURE_REDIRECT_EXEMPT = []
SECURE_REFERRER_POLICY = ""same-origin""
SECURE_SSL_HOST = None
SECURE_SSL_REDIRECT = False<EOS>"
"<BOS>""""""
Settings and configuration for Django.

Read values from the module specified by the DJANGO_SETTINGS_MODULE environment
variable, and then from django.conf.global_settings; see the global_settings.py
for a list of all possible variables.
""""""

import importlib
import os
import time
import traceback
import warnings
from pathlib import Path

import django
from django.conf import global_settings
from django.core.exceptions import ImproperlyConfigured
from django.utils.deprecation import RemovedInDjango50Warning
from django.utils.functional import LazyObject, empty

ENVIRONMENT_VARIABLE = ""DJANGO_SETTINGS_MODULE""

# RemovedInDjango50Warning
USE_DEPRECATED_PYTZ_DEPRECATED_MSG = (
    ""The USE_DEPRECATED_PYTZ setting, and support for pytz timezones is ""
    ""deprecated in favor of the stdlib zoneinfo module. Please update your ""
    ""code to use zoneinfo and remove the USE_DEPRECATED_PYTZ setting.""
)

USE_L10N_DEPRECATED_MSG = (
    ""The USE_L10N setting is deprecated. Starting with Django 5.0, localized ""
    ""formatting of data will always be enabled. For example Django will ""
    ""display numbers and dates using the format of the current locale.""
)

CSRF_COOKIE_MASKED_DEPRECATED_MSG = (
    ""The CSRF_COOKIE_MASKED transitional setting is deprecated. Support for ""
    ""it will be removed in Django 5.0.""
)


class SettingsReference(str):
    """"""
    String subclass which references a current settings value. It's treated as
    the value in memory but serializes to a settings.NAME attribute reference.
    """"""

    def __new__(self, value, setting_name):
        return str.__new__(self, value)

    def __init__(self, value, setting_name):
        self.setting_name = setting_name


class LazySettings(LazyObject):
    """"""
    A lazy proxy for either global Django settings or a custom settings object.
    The user can manually configure settings prior to using them. Otherwise,
    Django uses the settings module pointed to by DJANGO_SETTINGS_MODULE.
    """"""

    def _setup(self, name=None):
        """"""
        Load the settings module pointed to by the environment variable. This
        is used the first time settings are needed, if the user hasn't
        configured settings manually.
        """"""
        settings_module = os.environ.get(ENVIRONMENT_VARIABLE)
        if not settings_module:
            desc = (""setting %s"" % name) if name else ""settings""
            raise ImproperlyConfigured(
                ""Requested %s, but settings are not configured. ""
                ""You must either define the environment variable %s ""
                ""or call settings.configure() before accessing settings.""
                % (desc, ENVIRONMENT_VARIABLE)
            )

        self._wrapped = Settings(settings_module)

    def __repr__(self):
        # Hardcode the class name as otherwise it yields 'Settings'.
        if self._wrapped is empty:
            return ""<LazySettings [Unevaluated]>""
        return '<LazySettings ""%(settings_module)s"">' % {
            ""settings_module"": self._wrapped.SETTINGS_MODULE,
        }

    def __getattr__(self, name):
        """"""Return the value of a setting and cache it in self.__dict__.""""""
        if (_wrapped := self._wrapped) is empty:
            self._setup(name)
            _wrapped = self._wrapped
        val = getattr(_wrapped, name)

        # Special case some settings which require further modification.
        # This is done here for performance reasons so the modified value is cached.
        if name in {""MEDIA_URL"", ""STATIC_URL""} and val is not None:
            val = self._add_script_prefix(val)
        elif name == ""SECRET_KEY"" and not val:
            raise ImproperlyConfigured(""The SECRET_KEY setting must not be empty."")

        self.__dict__[name] = val
        return val

    def __setattr__(self, name, value):
        """"""
        Set the value of setting. Clear all cached values if _wrapped changes
        (@override_settings does this) or clear single values when set.
        """"""
        if name == ""_wrapped"":
            self.__dict__.clear()
        else:
            self.__dict__.pop(name, None)
        super().__setattr__(name, value)

    def __delattr__(self, name):
        """"""Delete a setting and clear it from cache if needed.""""""
        super().__delattr__(name)
        self.__dict__.pop(name, None)

    def configure(self, default_settings=global_settings, **options):
        """"""
        Called to manually configure the settings. The 'default_settings'
        parameter sets where to retrieve any unspecified values from (its
        argument must support attribute access (__getattr__)).
        """"""
        if self._wrapped is not empty:
            raise RuntimeError(""Settings already configured."")
        holder = UserSettingsHolder(default_settings)
        for name, value in options.items():
            if not name.isupper():
                raise TypeError(""Setting %r must be uppercase."" % name)
            setattr(holder, name, value)
        self._wrapped = holder

    @staticmethod
    def _add_script_prefix(value):
        """"""
        Add SCRIPT_NAME prefix to relative paths.

        Useful when the app is being served at a subpath and manually prefixing
        subpath to STATIC_URL and MEDIA_URL in settings is inconvenient.
        """"""
        # Don't apply prefix to absolute paths and URLs.
        if value.startswith((""http://"", ""https://"", ""/"")):
            return value
        from django.urls import get_script_prefix

        return ""%s%s"" % (get_script_prefix(), value)

    @property
    def configured(self):
        """"""Return True if the settings have already been configured.""""""
        return self._wrapped is not empty

    @property
    def USE_L10N(self):
        stack = traceback.extract_stack()
        # Show a warning if the setting is used outside of Django.
        # Stack index: -1 this line, -2 the LazyObject __getattribute__(),
        # -3 the caller.
        filename, _, _, _ = stack[-3]
        if not filename.startswith(os.path.dirname(django.__file__)):
            warnings.warn(
                USE_L10N_DEPRECATED_MSG,
                RemovedInDjango50Warning,
                stacklevel=2,
            )
        return self.__getattr__(""USE_L10N"")

    # RemovedInDjango50Warning.
    @property
    def _USE_L10N_INTERNAL(self):
        # Special hook to avoid checking a traceback in internal use on hot
        # paths.
        return self.__getattr__(""USE_L10N"")


class Settings:
    def __init__(self, settings_module):
        # update this dict from global settings (but only for ALL_CAPS settings)
        for setting in dir(global_settings):
            if setting.isupper():
                setattr(self, setting, getattr(global_settings, setting))

        # store the settings module in case someone later cares
        self.SETTINGS_MODULE = settings_module

        mod = importlib.import_module(self.SETTINGS_MODULE)

        tuple_settings = (
            ""ALLOWED_HOSTS"",
            ""INSTALLED_APPS"",
            ""TEMPLATE_DIRS"",
            ""LOCALE_PATHS"",
            ""SECRET_KEY_FALLBACKS"",
        )
        self._explicit_settings = set()
        for setting in dir(mod):
            if setting.isupper():
                setting_value = getattr(mod, setting)

                if setting in tuple_settings and not isinstance(
                    setting_value, (list, tuple)
                ):
                    raise ImproperlyConfigured(
                        ""The %s setting must be a list or a tuple."" % setting
                    )
                setattr(self, setting, setting_value)
                self._explicit_settings.add(setting)

        if self.USE_TZ is False and not self.is_overridden(""USE_TZ""):
            warnings.warn(
                ""The default value of USE_TZ will change from False to True ""
                ""in Django 5.0. Set USE_TZ to False in your project settings ""
                ""if you want to keep the current default behavior."",
                category=RemovedInDjango50Warning,
            )

        if self.is_overridden(""USE_DEPRECATED_PYTZ""):
            warnings.warn(USE_DEPRECATED_PYTZ_DEPRECATED_MSG, RemovedInDjango50Warning)

        if self.is_overridden(""CSRF_COOKIE_MASKED""):
            warnings.warn(CSRF_COOKIE_MASKED_DEPRECATED_MSG, RemovedInDjango50Warning)

        if hasattr(time, ""tzset"") and self.TIME_ZONE:
            # When we can, attempt to validate the timezone. If we can't find
            # this file, no check happens and it's harmless.
            zoneinfo_root = Path(""/usr/share/zoneinfo"")
            zone_info_file = zoneinfo_root.joinpath(*self.TIME_ZONE.split(""/""))
            if zoneinfo_root.exists() and not zone_info_file.exists():
                raise ValueError(""Incorrect timezone setting: %s"" % self.TIME_ZONE)
            # Move the time zone info into os.environ. See ticket #2315 for why
            # we don't do this unconditionally (breaks Windows).
            os.environ[""TZ""] = self.TIME_ZONE
            time.tzset()

        if self.is_overridden(""USE_L10N""):
            warnings.warn(USE_L10N_DEPRECATED_MSG, RemovedInDjango50Warning)

    def is_overridden(self, setting):
        return setting in self._explicit_settings

    def __repr__(self):
        return '<%(cls)s ""%(settings_module)s"">' % {
            ""cls"": self.__class__.__name__,
            ""settings_module"": self.SETTINGS_MODULE,
        }


class UserSettingsHolder:
    """"""Holder for user configured settings.""""""

    # SETTINGS_MODULE doesn't make much sense in the manually configured
    # (standalone) case.
    SETTINGS_MODULE = None

    def __init__(self, default_settings):
        """"""
        Requests for configuration variables not in this class are satisfied
        from the module specified in default_settings (if possible).
        """"""
        self.__dict__[""_deleted""] = set()
        self.default_settings = default_settings

    def __getattr__(self, name):
        if not name.isupper() or name in self._deleted:
            raise AttributeError
        return getattr(self.default_settings, name)

    def __setattr__(self, name, value):
        self._deleted.discard(name)
        if name == ""USE_L10N"":
            warnings.warn(USE_L10N_DEPRECATED_MSG, RemovedInDjango50Warning)
        if name == ""CSRF_COOKIE_MASKED"":
            warnings.warn(CSRF_COOKIE_MASKED_DEPRECATED_MSG, RemovedInDjango50Warning)
        super().__setattr__(name, value)
        if name == ""USE_DEPRECATED_PYTZ"":
            warnings.warn(USE_DEPRECATED_PYTZ_DEPRECATED_MSG, RemovedInDjango50Warning)

    def __delattr__(self, name):
        self._deleted.add(name)
        if hasattr(self, name):
            super().__delattr__(name)

    def __dir__(self):
        return sorted(
            s
            for s in [*self.__dict__, *dir(self.default_settings)]
            if s not in self._deleted
        )

    def is_overridden(self, setting):
        deleted = setting in self._deleted
        set_locally = setting in self.__dict__
        set_on_default = getattr(
            self.default_settings, ""is_overridden"", lambda s: False
        )(setting)
        return deleted or set_locally or set_on_default

    def __repr__(self):
        return ""<%(cls)s>"" % {
            ""cls"": self.__class__.__name__,
        }


settings = LazySettings()<EOS>"
"<BOS>import re
from urllib.parse import urlsplit

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.urls import re_path
from django.views.static import serve


def static(prefix, view=serve, **kwargs):
    """"""
    Return a URL pattern for serving files in debug mode.

    from django.conf import settings
    from django.conf.urls.static import static

    urlpatterns = [
        # ... the rest of your URLconf goes here ...
    ] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    """"""
    if not prefix:
        raise ImproperlyConfigured(""Empty static prefix not permitted"")
    elif not settings.DEBUG or urlsplit(prefix).netloc:
        # No-op if not in debug mode or a non-local prefix.
        return []
    return [
        re_path(
            r""^%s(?P<path>.*)$"" % re.escape(prefix.lstrip(""/"")), view, kwargs=kwargs
        ),
    ]<EOS>"
"<BOS>from django.urls import include
from django.views import defaults

__all__ = [""handler400"", ""handler403"", ""handler404"", ""handler500"", ""include""]

handler400 = defaults.bad_request
handler403 = defaults.permission_denied
handler404 = defaults.page_not_found
handler500 = defaults.server_error<EOS>"
"<BOS>import functools

from django.conf import settings
from django.urls import LocalePrefixPattern, URLResolver, get_resolver, path
from django.views.i18n import set_language


def i18n_patterns(*urls, prefix_default_language=True):
    """"""
    Add the language code prefix to every URL pattern within this function.
    This may only be used in the root URLconf, not in an included URLconf.
    """"""
    if not settings.USE_I18N:
        return list(urls)
    return [
        URLResolver(
            LocalePrefixPattern(prefix_default_language=prefix_default_language),
            list(urls),
        )
    ]


@functools.lru_cache(maxsize=None)
def is_language_prefix_patterns_used(urlconf):
    """"""
    Return a tuple of two booleans: (
        `True` if i18n_patterns() (LocalePrefixPattern) is used in the URLconf,
        `True` if the default language should be prefixed
    )
    """"""
    for url_pattern in get_resolver(urlconf).url_patterns:
        if isinstance(url_pattern.pattern, LocalePrefixPattern):
            return True, url_pattern.pattern.prefix_default_language
    return False, False


urlpatterns = [
    path(""setlang/"", set_language, name=""set_language""),
]<EOS>"
"<BOS>""""""
LANG_INFO is a dictionary structure to provide meta information about languages.

About name_local: capitalize it as if your language name was appearing
inside a sentence in your language.
The 'fallback' key can be used to specify a special fallback logic which doesn't
follow the traditional 'fr-ca' -> 'fr' fallback logic.
""""""

LANG_INFO = {
    ""af"": {
        ""bidi"": False,
        ""code"": ""af"",
        ""name"": ""Afrikaans"",
        ""name_local"": ""Afrikaans"",
    },
    ""ar"": {
        ""bidi"": True,
        ""code"": ""ar"",
        ""name"": ""Arabic"",
        ""name_local"": ""العربيّة"",
    },
    ""ar-dz"": {
        ""bidi"": True,
        ""code"": ""ar-dz"",
        ""name"": ""Algerian Arabic"",
        ""name_local"": ""العربية الجزائرية"",
    },
    ""ast"": {
        ""bidi"": False,
        ""code"": ""ast"",
        ""name"": ""Asturian"",
        ""name_local"": ""asturianu"",
    },
    ""az"": {
        ""bidi"": True,
        ""code"": ""az"",
        ""name"": ""Azerbaijani"",
        ""name_local"": ""Azərbaycanca"",
    },
    ""be"": {
        ""bidi"": False,
        ""code"": ""be"",
        ""name"": ""Belarusian"",
        ""name_local"": ""беларуская"",
    },
    ""bg"": {
        ""bidi"": False,
        ""code"": ""bg"",
        ""name"": ""Bulgarian"",
        ""name_local"": ""български"",
    },
    ""bn"": {
        ""bidi"": False,
        ""code"": ""bn"",
        ""name"": ""Bengali"",
        ""name_local"": ""বাংলা"",
    },
    ""br"": {
        ""bidi"": False,
        ""code"": ""br"",
        ""name"": ""Breton"",
        ""name_local"": ""brezhoneg"",
    },
    ""bs"": {
        ""bidi"": False,
        ""code"": ""bs"",
        ""name"": ""Bosnian"",
        ""name_local"": ""bosanski"",
    },
    ""ca"": {
        ""bidi"": False,
        ""code"": ""ca"",
        ""name"": ""Catalan"",
        ""name_local"": ""català"",
    },
    ""cs"": {
        ""bidi"": False,
        ""code"": ""cs"",
        ""name"": ""Czech"",
        ""name_local"": ""česky"",
    },
    ""cy"": {
        ""bidi"": False,
        ""code"": ""cy"",
        ""name"": ""Welsh"",
        ""name_local"": ""Cymraeg"",
    },
    ""da"": {
        ""bidi"": False,
        ""code"": ""da"",
        ""name"": ""Danish"",
        ""name_local"": ""dansk"",
    },
    ""de"": {
        ""bidi"": False,
        ""code"": ""de"",
        ""name"": ""German"",
        ""name_local"": ""Deutsch"",
    },
    ""dsb"": {
        ""bidi"": False,
        ""code"": ""dsb"",
        ""name"": ""Lower Sorbian"",
        ""name_local"": ""dolnoserbski"",
    },
    ""el"": {
        ""bidi"": False,
        ""code"": ""el"",
        ""name"": ""Greek"",
        ""name_local"": ""Ελληνικά"",
    },
    ""en"": {
        ""bidi"": False,
        ""code"": ""en"",
        ""name"": ""English"",
        ""name_local"": ""English"",
    },
    ""en-au"": {
        ""bidi"": False,
        ""code"": ""en-au"",
        ""name"": ""Australian English"",
        ""name_local"": ""Australian English"",
    },
    ""en-gb"": {
        ""bidi"": False,
        ""code"": ""en-gb"",
        ""name"": ""British English"",
        ""name_local"": ""British English"",
    },
    ""eo"": {
        ""bidi"": False,
        ""code"": ""eo"",
        ""name"": ""Esperanto"",
        ""name_local"": ""Esperanto"",
    },
    ""es"": {
        ""bidi"": False,
        ""code"": ""es"",
        ""name"": ""Spanish"",
        ""name_local"": ""español"",
    },
    ""es-ar"": {
        ""bidi"": False,
        ""code"": ""es-ar"",
        ""name"": ""Argentinian Spanish"",
        ""name_local"": ""español de Argentina"",
    },
    ""es-co"": {
        ""bidi"": False,
        ""code"": ""es-co"",
        ""name"": ""Colombian Spanish"",
        ""name_local"": ""español de Colombia"",
    },
    ""es-mx"": {
        ""bidi"": False,
        ""code"": ""es-mx"",
        ""name"": ""Mexican Spanish"",
        ""name_local"": ""español de Mexico"",
    },
    ""es-ni"": {
        ""bidi"": False,
        ""code"": ""es-ni"",
        ""name"": ""Nicaraguan Spanish"",
        ""name_local"": ""español de Nicaragua"",
    },
    ""es-ve"": {
        ""bidi"": False,
        ""code"": ""es-ve"",
        ""name"": ""Venezuelan Spanish"",
        ""name_local"": ""español de Venezuela"",
    },
    ""et"": {
        ""bidi"": False,
        ""code"": ""et"",
        ""name"": ""Estonian"",
        ""name_local"": ""eesti"",
    },
    ""eu"": {
        ""bidi"": False,
        ""code"": ""eu"",
        ""name"": ""Basque"",
        ""name_local"": ""Basque"",
    },
    ""fa"": {
        ""bidi"": True,
        ""code"": ""fa"",
        ""name"": ""Persian"",
        ""name_local"": ""فارسی"",
    },
    ""fi"": {
        ""bidi"": False,
        ""code"": ""fi"",
        ""name"": ""Finnish"",
        ""name_local"": ""suomi"",
    },
    ""fr"": {
        ""bidi"": False,
        ""code"": ""fr"",
        ""name"": ""French"",
        ""name_local"": ""français"",
    },
    ""fy"": {
        ""bidi"": False,
        ""code"": ""fy"",
        ""name"": ""Frisian"",
        ""name_local"": ""frysk"",
    },
    ""ga"": {
        ""bidi"": False,
        ""code"": ""ga"",
        ""name"": ""Irish"",
        ""name_local"": ""Gaeilge"",
    },
    ""gd"": {
        ""bidi"": False,
        ""code"": ""gd"",
        ""name"": ""Scottish Gaelic"",
        ""name_local"": ""Gàidhlig"",
    },
    ""gl"": {
        ""bidi"": False,
        ""code"": ""gl"",
        ""name"": ""Galician"",
        ""name_local"": ""galego"",
    },
    ""he"": {
        ""bidi"": True,
        ""code"": ""he"",
        ""name"": ""Hebrew"",
        ""name_local"": ""עברית"",
    },
    ""hi"": {
        ""bidi"": False,
        ""code"": ""hi"",
        ""name"": ""Hindi"",
        ""name_local"": ""हिंदी"",
    },
    ""hr"": {
        ""bidi"": False,
        ""code"": ""hr"",
        ""name"": ""Croatian"",
        ""name_local"": ""Hrvatski"",
    },
    ""hsb"": {
        ""bidi"": False,
        ""code"": ""hsb"",
        ""name"": ""Upper Sorbian"",
        ""name_local"": ""hornjoserbsce"",
    },
    ""hu"": {
        ""bidi"": False,
        ""code"": ""hu"",
        ""name"": ""Hungarian"",
        ""name_local"": ""Magyar"",
    },
    ""hy"": {
        ""bidi"": False,
        ""code"": ""hy"",
        ""name"": ""Armenian"",
        ""name_local"": ""հայերեն"",
    },
    ""ia"": {
        ""bidi"": False,
        ""code"": ""ia"",
        ""name"": ""Interlingua"",
        ""name_local"": ""Interlingua"",
    },
    ""io"": {
        ""bidi"": False,
        ""code"": ""io"",
        ""name"": ""Ido"",
        ""name_local"": ""ido"",
    },
    ""id"": {
        ""bidi"": False,
        ""code"": ""id"",
        ""name"": ""Indonesian"",
        ""name_local"": ""Bahasa Indonesia"",
    },
    ""ig"": {
        ""bidi"": False,
        ""code"": ""ig"",
        ""name"": ""Igbo"",
        ""name_local"": ""Asụsụ Ìgbò"",
    },
    ""is"": {
        ""bidi"": False,
        ""code"": ""is"",
        ""name"": ""Icelandic"",
        ""name_local"": ""Íslenska"",
    },
    ""it"": {
        ""bidi"": False,
        ""code"": ""it"",
        ""name"": ""Italian"",
        ""name_local"": ""italiano"",
    },
    ""ja"": {
        ""bidi"": False,
        ""code"": ""ja"",
        ""name"": ""Japanese"",
        ""name_local"": ""日本語"",
    },
    ""ka"": {
        ""bidi"": False,
        ""code"": ""ka"",
        ""name"": ""Georgian"",
        ""name_local"": ""ქართული"",
    },
    ""kab"": {
        ""bidi"": False,
        ""code"": ""kab"",
        ""name"": ""Kabyle"",
        ""name_local"": ""taqbaylit"",
    },
    ""kk"": {
        ""bidi"": False,
        ""code"": ""kk"",
        ""name"": ""Kazakh"",
        ""name_local"": ""Қазақ"",
    },
    ""km"": {
        ""bidi"": False,
        ""code"": ""km"",
        ""name"": ""Khmer"",
        ""name_local"": ""Khmer"",
    },
    ""kn"": {
        ""bidi"": False,
        ""code"": ""kn"",
        ""name"": ""Kannada"",
        ""name_local"": ""Kannada"",
    },
    ""ko"": {
        ""bidi"": False,
        ""code"": ""ko"",
        ""name"": ""Korean"",
        ""name_local"": ""한국어"",
    },
    ""ky"": {
        ""bidi"": False,
        ""code"": ""ky"",
        ""name"": ""Kyrgyz"",
        ""name_local"": ""Кыргызча"",
    },
    ""lb"": {
        ""bidi"": False,
        ""code"": ""lb"",
        ""name"": ""Luxembourgish"",
        ""name_local"": ""Lëtzebuergesch"",
    },
    ""lt"": {
        ""bidi"": False,
        ""code"": ""lt"",
        ""name"": ""Lithuanian"",
        ""name_local"": ""Lietuviškai"",
    },
    ""lv"": {
        ""bidi"": False,
        ""code"": ""lv"",
        ""name"": ""Latvian"",
        ""name_local"": ""latviešu"",
    },
    ""mk"": {
        ""bidi"": False,
        ""code"": ""mk"",
        ""name"": ""Macedonian"",
        ""name_local"": ""Македонски"",
    },
    ""ml"": {
        ""bidi"": False,
        ""code"": ""ml"",
        ""name"": ""Malayalam"",
        ""name_local"": ""മലയാളം"",
    },
    ""mn"": {
        ""bidi"": False,
        ""code"": ""mn"",
        ""name"": ""Mongolian"",
        ""name_local"": ""Mongolian"",
    },
    ""mr"": {
        ""bidi"": False,
        ""code"": ""mr"",
        ""name"": ""Marathi"",
        ""name_local"": ""मराठी"",
    },
    ""ms"": {
        ""bidi"": False,
        ""code"": ""ms"",
        ""name"": ""Malay"",
        ""name_local"": ""Bahasa Melayu"",
    },
    ""my"": {
        ""bidi"": False,
        ""code"": ""my"",
        ""name"": ""Burmese"",
        ""name_local"": ""မြန်မာဘာသာ"",
    },
    ""nb"": {
        ""bidi"": False,
        ""code"": ""nb"",
        ""name"": ""Norwegian Bokmal"",
        ""name_local"": ""norsk (bokmål)"",
    },
    ""ne"": {
        ""bidi"": False,
        ""code"": ""ne"",
        ""name"": ""Nepali"",
        ""name_local"": ""नेपाली"",
    },
    ""nl"": {
        ""bidi"": False,
        ""code"": ""nl"",
        ""name"": ""Dutch"",
        ""name_local"": ""Nederlands"",
    },
    ""nn"": {
        ""bidi"": False,
        ""code"": ""nn"",
        ""name"": ""Norwegian Nynorsk"",
        ""name_local"": ""norsk (nynorsk)"",
    },
    ""no"": {
        ""bidi"": False,
        ""code"": ""no"",
        ""name"": ""Norwegian"",
        ""name_local"": ""norsk"",
    },
    ""os"": {
        ""bidi"": False,
        ""code"": ""os"",
        ""name"": ""Ossetic"",
        ""name_local"": ""Ирон"",
    },
    ""pa"": {
        ""bidi"": False,
        ""code"": ""pa"",
        ""name"": ""Punjabi"",
        ""name_local"": ""Punjabi"",
    },
    ""pl"": {
        ""bidi"": False,
        ""code"": ""pl"",
        ""name"": ""Polish"",
        ""name_local"": ""polski"",
    },
    ""pt"": {
        ""bidi"": False,
        ""code"": ""pt"",
        ""name"": ""Portuguese"",
        ""name_local"": ""Português"",
    },
    ""pt-br"": {
        ""bidi"": False,
        ""code"": ""pt-br"",
        ""name"": ""Brazilian Portuguese"",
        ""name_local"": ""Português Brasileiro"",
    },
    ""ro"": {
        ""bidi"": False,
        ""code"": ""ro"",
        ""name"": ""Romanian"",
        ""name_local"": ""Română"",
    },
    ""ru"": {
        ""bidi"": False,
        ""code"": ""ru"",
        ""name"": ""Russian"",
        ""name_local"": ""Русский"",
    },
    ""sk"": {
        ""bidi"": False,
        ""code"": ""sk"",
        ""name"": ""Slovak"",
        ""name_local"": ""Slovensky"",
    },
    ""sl"": {
        ""bidi"": False,
        ""code"": ""sl"",
        ""name"": ""Slovenian"",
        ""name_local"": ""Slovenščina"",
    },
    ""sq"": {
        ""bidi"": False,
        ""code"": ""sq"",
        ""name"": ""Albanian"",
        ""name_local"": ""shqip"",
    },
    ""sr"": {
        ""bidi"": False,
        ""code"": ""sr"",
        ""name"": ""Serbian"",
        ""name_local"": ""српски"",
    },
    ""sr-latn"": {
        ""bidi"": False,
        ""code"": ""sr-latn"",
        ""name"": ""Serbian Latin"",
        ""name_local"": ""srpski (latinica)"",
    },
    ""sv"": {
        ""bidi"": False,
        ""code"": ""sv"",
        ""name"": ""Swedish"",
        ""name_local"": ""svenska"",
    },
    ""sw"": {
        ""bidi"": False,
        ""code"": ""sw"",
        ""name"": ""Swahili"",
        ""name_local"": ""Kiswahili"",
    },
    ""ta"": {
        ""bidi"": False,
        ""code"": ""ta"",
        ""name"": ""Tamil"",
        ""name_local"": ""தமிழ்"",
    },
    ""te"": {
        ""bidi"": False,
        ""code"": ""te"",
        ""name"": ""Telugu"",
        ""name_local"": ""తెలుగు"",
    },
    ""tg"": {
        ""bidi"": False,
        ""code"": ""tg"",
        ""name"": ""Tajik"",
        ""name_local"": ""тоҷикӣ"",
    },
    ""th"": {
        ""bidi"": False,
        ""code"": ""th"",
        ""name"": ""Thai"",
        ""name_local"": ""ภาษาไทย"",
    },
    ""tk"": {
        ""bidi"": False,
        ""code"": ""tk"",
        ""name"": ""Turkmen"",
        ""name_local"": ""Türkmençe"",
    },
    ""tr"": {
        ""bidi"": False,
        ""code"": ""tr"",
        ""name"": ""Turkish"",
        ""name_local"": ""Türkçe"",
    },
    ""tt"": {
        ""bidi"": False,
        ""code"": ""tt"",
        ""name"": ""Tatar"",
        ""name_local"": ""Татарча"",
    },
    ""udm"": {
        ""bidi"": False,
        ""code"": ""udm"",
        ""name"": ""Udmurt"",
        ""name_local"": ""Удмурт"",
    },
    ""uk"": {
        ""bidi"": False,
        ""code"": ""uk"",
        ""name"": ""Ukrainian"",
        ""name_local"": ""Українська"",
    },
    ""ur"": {
        ""bidi"": True,
        ""code"": ""ur"",
        ""name"": ""Urdu"",
        ""name_local"": ""اردو"",
    },
    ""uz"": {
        ""bidi"": False,
        ""code"": ""uz"",
        ""name"": ""Uzbek"",
        ""name_local"": ""oʻzbek tili"",
    },
    ""vi"": {
        ""bidi"": False,
        ""code"": ""vi"",
        ""name"": ""Vietnamese"",
        ""name_local"": ""Tiếng Việt"",
    },
    ""zh-cn"": {
        ""fallback"": [""zh-hans""],
    },
    ""zh-hans"": {
        ""bidi"": False,
        ""code"": ""zh-hans"",
        ""name"": ""Simplified Chinese"",
        ""name_local"": ""简体中文"",
    },
    ""zh-hant"": {
        ""bidi"": False,
        ""code"": ""zh-hant"",
        ""name"": ""Traditional Chinese"",
        ""name_local"": ""繁體中文"",
    },
    ""zh-hk"": {
        ""fallback"": [""zh-hant""],
    },
    ""zh-mo"": {
        ""fallback"": [""zh-hant""],
    },
    ""zh-my"": {
        ""fallback"": [""zh-hans""],
    },
    ""zh-sg"": {
        ""fallback"": [""zh-hans""],
    },
    ""zh-tw"": {
        ""fallback"": [""zh-hant""],
    },
}<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""d F Y""  # 25 Ottobre 2006
TIME_FORMAT = ""H:i""  # 14:30
DATETIME_FORMAT = ""l d F Y H:i""  # Mercoledì 25 Ottobre 2006 14:30
YEAR_MONTH_FORMAT = ""F Y""  # Ottobre 2006
MONTH_DAY_FORMAT = ""j F""  # 25 Ottobre
SHORT_DATE_FORMAT = ""d/m/Y""  # 25/12/2009
SHORT_DATETIME_FORMAT = ""d/m/Y H:i""  # 25/10/2009 14:30
FIRST_DAY_OF_WEEK = 1  # Lunedì

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '25/10/2006'
    ""%Y/%m/%d"",  # '2006/10/25'
    ""%d-%m-%Y"",  # '25-10-2006'
    ""%Y-%m-%d"",  # '2006-10-25'
    ""%d-%m-%y"",  # '25-10-06'
    ""%d/%m/%y"",  # '25/10/06'
]
DATETIME_INPUT_FORMATS = [
    ""%d/%m/%Y %H:%M:%S"",  # '25/10/2006 14:30:59'
    ""%d/%m/%Y %H:%M:%S.%f"",  # '25/10/2006 14:30:59.000200'
    ""%d/%m/%Y %H:%M"",  # '25/10/2006 14:30'
    ""%d/%m/%y %H:%M:%S"",  # '25/10/06 14:30:59'
    ""%d/%m/%y %H:%M:%S.%f"",  # '25/10/06 14:30:59.000200'
    ""%d/%m/%y %H:%M"",  # '25/10/06 14:30'
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%d-%m-%Y %H:%M:%S"",  # '25-10-2006 14:30:59'
    ""%d-%m-%Y %H:%M:%S.%f"",  # '25-10-2006 14:30:59.000200'
    ""%d-%m-%Y %H:%M"",  # '25-10-2006 14:30'
    ""%d-%m-%y %H:%M:%S"",  # '25-10-06 14:30:59'
    ""%d-%m-%y %H:%M:%S.%f"",  # '25-10-06 14:30:59.000200'
    ""%d-%m-%y %H:%M"",  # '25-10-06 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = r""j \d\e F \d\e Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = r""j \d\e F \d\e Y à\s H:i""
YEAR_MONTH_FORMAT = r""F \d\e Y""
MONTH_DAY_FORMAT = r""j \d\e F""
SHORT_DATE_FORMAT = ""d/m/Y""
SHORT_DATETIME_FORMAT = ""d/m/Y H:i""
FIRST_DAY_OF_WEEK = 0  # Sunday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# Kept ISO formats as they are in first position
DATE_INPUT_FORMATS = [
    ""%Y-%m-%d"",  # '2006-10-25'
    ""%d/%m/%Y"",  # '25/10/2006'
    ""%d/%m/%y"",  # '25/10/06'
    # ""%d de %b de %Y"",  # '25 de Out de 2006'
    # ""%d de %b, %Y"",  # '25 Out, 2006'
    # ""%d de %B de %Y"",  # '25 de Outubro de 2006'
    # ""%d de %B, %Y"",  # '25 de Outubro, 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%d/%m/%Y %H:%M:%S"",  # '25/10/2006 14:30:59'
    ""%d/%m/%Y %H:%M:%S.%f"",  # '25/10/2006 14:30:59.000200'
    ""%d/%m/%Y %H:%M"",  # '25/10/2006 14:30'
    ""%d/%m/%y %H:%M:%S"",  # '25/10/06 14:30:59'
    ""%d/%m/%y %H:%M:%S.%f"",  # '25/10/06 14:30:59.000200'
    ""%d/%m/%y %H:%M"",  # '25/10/06 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""d. F Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j. F Y. H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""j. M. Y""
SHORT_DATETIME_FORMAT = ""j.n.Y. H:i""
FIRST_DAY_OF_WEEK = 0

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
    ""%d-%m-%Y"",  # '25-10-2006'
    ""%d. %m. %Y"",  # '25. 10. 2006'
    ""%d. %m. %y"",  # '25. 10. 06'
]

DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d.%m.%y %H:%M:%S"",  # '25.10.06 14:30:59'
    ""%d.%m.%y %H:%M:%S.%f"",  # '25.10.06 14:30:59.000200'
    ""%d.%m.%y %H:%M"",  # '25.10.06 14:30'
    ""%d-%m-%Y %H:%M:%S"",  # '25-10-2006 14:30:59'
    ""%d-%m-%Y %H:%M:%S.%f"",  # '25-10-2006 14:30:59.000200'
    ""%d-%m-%Y %H:%M"",  # '25-10-2006 14:30'
    ""%d. %m. %Y %H:%M:%S"",  # '25. 10. 2006 14:30:59'
    ""%d. %m. %Y %H:%M:%S.%f"",  # '25. 10. 2006 14:30:59.000200'
    ""%d. %m. %Y %H:%M"",  # '25. 10. 2006 14:30'
    ""%d. %m. %y %H:%M:%S"",  # '25. 10. 06 14:30:59'
    ""%d. %m. %y %H:%M:%S.%f"",  # '25. 10. 06 14:30:59.000200'
    ""%d. %m. %y %H:%M"",  # '25. 10. 06 14:30'
]

DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = r""Y \m. E j \d.""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = r""Y \m. E j \d., H:i""
YEAR_MONTH_FORMAT = r""Y \m. F""
MONTH_DAY_FORMAT = r""E j \d.""
SHORT_DATE_FORMAT = ""Y-m-d""
SHORT_DATETIME_FORMAT = ""Y-m-d H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%Y-%m-%d"",  # '2006-10-25'
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
]
TIME_INPUT_FORMATS = [
    ""%H:%M:%S"",  # '14:30:59'
    ""%H:%M:%S.%f"",  # '14:30:59.000200'
    ""%H:%M"",  # '14:30'
    ""%H.%M.%S"",  # '14.30.59'
    ""%H.%M.%S.%f"",  # '14.30.59.000200'
    ""%H.%M"",  # '14.30'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d.%m.%y %H:%M:%S"",  # '25.10.06 14:30:59'
    ""%d.%m.%y %H:%M:%S.%f"",  # '25.10.06 14:30:59.000200'
    ""%d.%m.%y %H:%M"",  # '25.10.06 14:30'
    ""%d.%m.%y %H.%M.%S"",  # '25.10.06 14.30.59'
    ""%d.%m.%y %H.%M.%S.%f"",  # '25.10.06 14.30.59.000200'
    ""%d.%m.%y %H.%M"",  # '25.10.06 14.30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j E Y г.""
TIME_FORMAT = ""G:i""
DATETIME_FORMAT = ""j E Y г. G:i""
YEAR_MONTH_FORMAT = ""F Y г.""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d.%m.%y %H:%M:%S"",  # '25.10.06 14:30:59'
    ""%d.%m.%y %H:%M:%S.%f"",  # '25.10.06 14:30:59.000200'
    ""%d.%m.%y %H:%M"",  # '25.10.06 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F Y""
TIME_FORMAT = ""G:i""
DATETIME_FORMAT = ""j F Y, G:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""j M Y""
SHORT_DATETIME_FORMAT = ""j M Y, G:i""
FIRST_DAY_OF_WEEK = 0  # Sunday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # 25/10/2006
    ""%d %b %Y"",  # 25 ต.ค. 2006
    ""%d %B %Y"",  # 25 ตุลาคม 2006
]
TIME_INPUT_FORMATS = [
    ""%H:%M:%S"",  # 14:30:59
    ""%H:%M:%S.%f"",  # 14:30:59.000200
    ""%H:%M"",  # 14:30
]
DATETIME_INPUT_FORMATS = [
    ""%d/%m/%Y %H:%M:%S"",  # 25/10/2006 14:30:59
    ""%d/%m/%Y %H:%M:%S.%f"",  # 25/10/2006 14:30:59.000200
    ""%d/%m/%Y %H:%M"",  # 25/10/2006 14:30
]
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
DATE_FORMAT = r""j \d\e F \d\e Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = r""j \d\e F \d\e Y \a \l\a\s H:i""
YEAR_MONTH_FORMAT = r""F \d\e Y""
MONTH_DAY_FORMAT = r""j \d\e F""
SHORT_DATE_FORMAT = ""d/m/Y""
SHORT_DATETIME_FORMAT = ""d/m/Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday: ISO 8601
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '25/10/2006'
    ""%d/%m/%y"",  # '25/10/06'
    ""%Y%m%d"",  # '20061025'
]
DATETIME_INPUT_FORMATS = [
    ""%d/%m/%Y %H:%M:%S"",
    ""%d/%m/%Y %H:%M:%S.%f"",
    ""%d/%m/%Y %H:%M"",
    ""%d/%m/%y %H:%M:%S"",
    ""%d/%m/%y %H:%M:%S.%f"",
    ""%d/%m/%y %H:%M"",
]
DECIMAL_SEPARATOR = "".""  # ',' is also official (less common): NOM-008-SCFI-2002
THOUSAND_SEPARATOR = "",""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j. E Y""
TIME_FORMAT = ""G.i""
DATETIME_FORMAT = r""j. E Y \k\e\l\l\o G.i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""j.n.Y""
SHORT_DATETIME_FORMAT = ""j.n.Y G.i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '20.3.2014'
    ""%d.%m.%y"",  # '20.3.14'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H.%M.%S"",  # '20.3.2014 14.30.59'
    ""%d.%m.%Y %H.%M.%S.%f"",  # '20.3.2014 14.30.59.000200'
    ""%d.%m.%Y %H.%M"",  # '20.3.2014 14.30'
    ""%d.%m.%y %H.%M.%S"",  # '20.3.14 14.30.59'
    ""%d.%m.%y %H.%M.%S.%f"",  # '20.3.14 14.30.59.000200'
    ""%d.%m.%y %H.%M"",  # '20.3.14 14.30'
]
TIME_INPUT_FORMATS = [
    ""%H.%M.%S"",  # '14.30.59'
    ""%H.%M.%S.%f"",  # '14.30.59.000200'
    ""%H.%M"",  # '14.30'
]

DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # Non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j N Y""
DATETIME_FORMAT = ""j N Y, G.i""
TIME_FORMAT = ""G.i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""d-m-Y""
SHORT_DATETIME_FORMAT = ""d-m-Y G.i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d-%m-%Y"",  # '25-10-2009'
    ""%d/%m/%Y"",  # '25/10/2009'
    ""%d-%m-%y"",  # '25-10-09'
    ""%d/%m/%y"",  # '25/10/09'
    ""%d %b %Y"",  # '25 Oct 2006',
    ""%d %B %Y"",  # '25 October 2006'
    ""%m/%d/%y"",  # '10/25/06'
    ""%m/%d/%Y"",  # '10/25/2009'
]

TIME_INPUT_FORMATS = [
    ""%H.%M.%S"",  # '14.30.59'
    ""%H.%M"",  # '14.30'
]

DATETIME_INPUT_FORMATS = [
    ""%d-%m-%Y %H.%M.%S"",  # '25-10-2009 14.30.59'
    ""%d-%m-%Y %H.%M.%S.%f"",  # '25-10-2009 14.30.59.000200'
    ""%d-%m-%Y %H.%M"",  # '25-10-2009 14.30'
    ""%d-%m-%y %H.%M.%S"",  # '25-10-09' 14.30.59'
    ""%d-%m-%y %H.%M.%S.%f"",  # '25-10-09' 14.30.59.000200'
    ""%d-%m-%y %H.%M"",  # '25-10-09' 14.30'
    ""%m/%d/%y %H.%M.%S"",  # '10/25/06 14.30.59'
    ""%m/%d/%y %H.%M.%S.%f"",  # '10/25/06 14.30.59.000200'
    ""%m/%d/%y %H.%M"",  # '10/25/06 14.30'
    ""%m/%d/%Y %H.%M.%S"",  # '25/10/2009 14.30.59'
    ""%m/%d/%Y %H.%M.%S.%f"",  # '25/10/2009 14.30.59.000200'
    ""%m/%d/%Y %H.%M"",  # '25/10/2009 14.30'
]

DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F Y""
TIME_FORMAT = ""P""
DATETIME_FORMAT = ""j F Y P""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y %H:%M:%S"",  # '25.10.06 14:30:59'
    ""%d.%m.%y %H:%M:%S.%f"",  # '25.10.06 14:30:59.000200'
    ""%d.%m.%y %H:%M"",  # '25.10.06 14:30'
    ""%d.%m.%y"",  # '25.10.06'
]
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j M Y""  # '25 Oct 2006'
TIME_FORMAT = ""P""  # '2:30 p.m.'
DATETIME_FORMAT = ""j M Y, P""  # '25 Oct 2006, 2:30 p.m.'
YEAR_MONTH_FORMAT = ""F Y""  # 'October 2006'
MONTH_DAY_FORMAT = ""j F""  # '25 October'
SHORT_DATE_FORMAT = ""d/m/Y""  # '25/10/2006'
SHORT_DATETIME_FORMAT = ""d/m/Y P""  # '25/10/2006 2:30 p.m.'
FIRST_DAY_OF_WEEK = 0  # Sunday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%Y-%m-%d"",  # '2006-10-25'
    ""%d/%m/%Y"",  # '25/10/2006'
    ""%d/%m/%y"",  # '25/10/06'
    ""%d %b %Y"",  # '25 Oct 2006'
    ""%d %b, %Y"",  # '25 Oct, 2006'
    ""%d %B %Y"",  # '25 October 2006'
    ""%d %B, %Y"",  # '25 October, 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%d/%m/%Y %H:%M:%S"",  # '25/10/2006 14:30:59'
    ""%d/%m/%Y %H:%M:%S.%f"",  # '25/10/2006 14:30:59.000200'
    ""%d/%m/%Y %H:%M"",  # '25/10/2006 14:30'
    ""%d/%m/%y %H:%M:%S"",  # '25/10/06 14:30:59'
    ""%d/%m/%y %H:%M:%S.%f"",  # '25/10/06 14:30:59.000200'
    ""%d/%m/%y %H:%M"",  # '25/10/06 14:30'
]
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j. E Y""
TIME_FORMAT = ""G:i""
DATETIME_FORMAT = ""j. E Y G:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y G:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '05.01.2006'
    ""%d.%m.%y"",  # '05.01.06'
    ""%d. %m. %Y"",  # '5. 1. 2006'
    ""%d. %m. %y"",  # '5. 1. 06'
    # ""%d. %B %Y"",  # '25. October 2006'
    # ""%d. %b. %Y"",  # '25. Oct. 2006'
]
# Kept ISO formats as one is in first position
TIME_INPUT_FORMATS = [
    ""%H:%M:%S"",  # '04:30:59'
    ""%H.%M"",  # '04.30'
    ""%H:%M"",  # '04:30'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '05.01.2006 04:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '05.01.2006 04:30:59.000200'
    ""%d.%m.%Y %H.%M"",  # '05.01.2006 04.30'
    ""%d.%m.%Y %H:%M"",  # '05.01.2006 04:30'
    ""%d. %m. %Y %H:%M:%S"",  # '05. 01. 2006 04:30:59'
    ""%d. %m. %Y %H:%M:%S.%f"",  # '05. 01. 2006 04:30:59.000200'
    ""%d. %m. %Y %H.%M"",  # '05. 01. 2006 04.30'
    ""%d. %m. %Y %H:%M"",  # '05. 01. 2006 04:30'
    ""%Y-%m-%d %H.%M"",  # '2006-01-05 04.30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j. F Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j. F Y H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
    # ""%d. %B %Y"",  # '25. October 2006'
    # ""%d. %b. %Y"",  # '25. Oct. 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
]

# these are the separators for non-monetary numbers. For monetary numbers,
# the DECIMAL_SEPARATOR is a . (decimal point) and the THOUSAND_SEPARATOR is a
# ' (single quote).
# For details, please refer to the documentation and the following link:
# https://www.bk.admin.ch/bk/de/home/dokumentation/sprachen/hilfsmittel-textredaktion/schreibweisungen.html
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j M Y""  # '25 Oct 2006'
TIME_FORMAT = ""P""  # '2:30 p.m.'
DATETIME_FORMAT = ""j M Y, P""  # '25 Oct 2006, 2:30 p.m.'
YEAR_MONTH_FORMAT = ""F Y""  # 'October 2006'
MONTH_DAY_FORMAT = ""j F""  # '25 October'
SHORT_DATE_FORMAT = ""d/m/Y""  # '25/10/2006'
SHORT_DATETIME_FORMAT = ""d/m/Y P""  # '25/10/2006 2:30 p.m.'
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '25/10/2006'
    ""%d/%m/%y"",  # '25/10/06'
    # ""%b %d %Y"",  # 'Oct 25 2006'
    # ""%b %d, %Y"",  # 'Oct 25, 2006'
    # ""%d %b %Y"",  # '25 Oct 2006'
    # ""%d %b, %Y"",  # '25 Oct, 2006'
    # ""%B %d %Y"",  # 'October 25 2006'
    # ""%B %d, %Y"",  # 'October 25, 2006'
    # ""%d %B %Y"",  # '25 October 2006'
    # ""%d %B, %Y"",  # '25 October, 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%d/%m/%Y %H:%M:%S"",  # '25/10/2006 14:30:59'
    ""%d/%m/%Y %H:%M:%S.%f"",  # '25/10/2006 14:30:59.000200'
    ""%d/%m/%Y %H:%M"",  # '25/10/2006 14:30'
    ""%d/%m/%y %H:%M:%S"",  # '25/10/06 14:30:59'
    ""%d/%m/%y %H:%M:%S.%f"",  # '25/10/06 14:30:59.000200'
    ""%d/%m/%y %H:%M"",  # '25/10/06 14:30'
]
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j. F Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j. F Y H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# Kept ISO formats as they are in first position
DATE_INPUT_FORMATS = [
    ""%Y-%m-%d"",  # '2006-10-25'
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
    # ""%d. %b %Y"",  # '25. okt 2006'
    # ""%d %b %Y"",  # '25 okt 2006'
    # ""%d. %b. %Y"",  # '25. okt. 2006'
    # ""%d %b. %Y"",  # '25 okt. 2006'
    # ""%d. %B %Y"",  # '25. oktober 2006'
    # ""%d %B %Y"",  # '25 oktober 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d.%m.%y %H:%M:%S"",  # '25.10.06 14:30:59'
    ""%d.%m.%y %H:%M:%S.%f"",  # '25.10.06 14:30:59.000200'
    ""%d.%m.%y %H:%M"",  # '25.10.06 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j. F Y.""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j. F Y. H:i""
YEAR_MONTH_FORMAT = ""F Y.""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""j.m.Y.""
SHORT_DATETIME_FORMAT = ""j.m.Y. H:i""
FIRST_DAY_OF_WEEK = 1

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y."",  # '25.10.2006.'
    ""%d.%m.%y."",  # '25.10.06.'
    ""%d. %m. %Y."",  # '25. 10. 2006.'
    ""%d. %m. %y."",  # '25. 10. 06.'
    # ""%d. %b %y."",  # '25. Oct 06.'
    # ""%d. %B %y."",  # '25. October 06.'
    # ""%d. %b '%y."",  # '25. Oct '06.'
    # ""%d. %B '%y."",  #'25. October '06.'
    # ""%d. %b %Y."",  # '25. Oct 2006.'
    # ""%d. %B %Y."",  # '25. October 2006.'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y. %H:%M:%S"",  # '25.10.2006. 14:30:59'
    ""%d.%m.%Y. %H:%M:%S.%f"",  # '25.10.2006. 14:30:59.000200'
    ""%d.%m.%Y. %H:%M"",  # '25.10.2006. 14:30'
    ""%d.%m.%y. %H:%M:%S"",  # '25.10.06. 14:30:59'
    ""%d.%m.%y. %H:%M:%S.%f"",  # '25.10.06. 14:30:59.000200'
    ""%d.%m.%y. %H:%M"",  # '25.10.06. 14:30'
    ""%d. %m. %Y. %H:%M:%S"",  # '25. 10. 2006. 14:30:59'
    ""%d. %m. %Y. %H:%M:%S.%f"",  # '25. 10. 2006. 14:30:59.000200'
    ""%d. %m. %Y. %H:%M"",  # '25. 10. 2006. 14:30'
    ""%d. %m. %y. %H:%M:%S"",  # '25. 10. 06. 14:30:59'
    ""%d. %m. %y. %H:%M:%S.%f"",  # '25. 10. 06. 14:30:59.000200'
    ""%d. %m. %y. %H:%M"",  # '25. 10. 06. 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = r""Y\k\o N j\a""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = r""Y\k\o N j\a, H:i""
YEAR_MONTH_FORMAT = r""Y\k\o F""
MONTH_DAY_FORMAT = r""F\r\e\n j\a""
SHORT_DATE_FORMAT = ""Y-m-d""
SHORT_DATETIME_FORMAT = ""Y-m-d H:i""
FIRST_DAY_OF_WEEK = 1  # Astelehena

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""Y年n月j日""
TIME_FORMAT = ""G:i""
DATETIME_FORMAT = ""Y年n月j日G:i""
YEAR_MONTH_FORMAT = ""Y年n月""
MONTH_DAY_FORMAT = ""n月j日""
SHORT_DATE_FORMAT = ""Y/m/d""
SHORT_DATETIME_FORMAT = ""Y/m/d G:i""
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F Y""
TIME_FORMAT = ""h:i A""
# DATETIME_FORMAT =
# YEAR_MONTH_FORMAT =
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""j M Y""
# SHORT_DATETIME_FORMAT =
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
# DECIMAL_SEPARATOR =
# THOUSAND_SEPARATOR =
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F, Y""
TIME_FORMAT = ""g:i A""
# DATETIME_FORMAT =
# YEAR_MONTH_FORMAT =
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""j M, Y""
# SHORT_DATETIME_FORMAT =
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
# DECIMAL_SEPARATOR =
# THOUSAND_SEPARATOR =
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = r""j \d\e F \d\e Y""
TIME_FORMAT = ""G:i""
DATETIME_FORMAT = r""j \d\e F \d\e Y \a \l\e\s G:i""
YEAR_MONTH_FORMAT = r""F \d\e\l Y""
MONTH_DAY_FORMAT = r""j \d\e F""
SHORT_DATE_FORMAT = ""d/m/Y""
SHORT_DATETIME_FORMAT = ""d/m/Y G:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '31/12/2009'
    ""%d/%m/%y"",  # '31/12/09'
]
DATETIME_INPUT_FORMATS = [
    ""%d/%m/%Y %H:%M:%S"",
    ""%d/%m/%Y %H:%M:%S.%f"",
    ""%d/%m/%Y %H:%M"",
    ""%d/%m/%y %H:%M:%S"",
    ""%d/%m/%y %H:%M:%S.%f"",
    ""%d/%m/%y %H:%M"",
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""Y. F j.""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""Y. F j. H:i""
YEAR_MONTH_FORMAT = ""Y. F""
MONTH_DAY_FORMAT = ""F j.""
SHORT_DATE_FORMAT = ""Y.m.d.""
SHORT_DATETIME_FORMAT = ""Y.m.d. H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%Y.%m.%d."",  # '2006.10.25.'
]
TIME_INPUT_FORMATS = [
    ""%H:%M:%S"",  # '14:30:59'
    ""%H:%M"",  # '14:30'
]
DATETIME_INPUT_FORMATS = [
    ""%Y.%m.%d. %H:%M:%S"",  # '2006.10.25. 14:30:59'
    ""%Y.%m.%d. %H:%M:%S.%f"",  # '2006.10.25. 14:30:59.000200'
    ""%Y.%m.%d. %H:%M"",  # '2006.10.25. 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "" ""  # Non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""l, j F, Y""
TIME_FORMAT = ""h:i a""
DATETIME_FORMAT = ""j F, Y h:i a""
YEAR_MONTH_FORMAT = ""F, Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""j.M.Y""
SHORT_DATETIME_FORMAT = ""j.M.Y H:i""
FIRST_DAY_OF_WEEK = 1  # (Monday)

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# Kept ISO formats as they are in first position
DATE_INPUT_FORMATS = [
    ""%Y-%m-%d"",  # '2006-10-25'
    ""%m/%d/%Y"",  # '10/25/2006'
    ""%m/%d/%y"",  # '10/25/06'
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
    # ""%d %b %Y"",  # '25 Oct 2006'
    # ""%d %b, %Y"",  # '25 Oct, 2006'
    # ""%d %b. %Y"",  # '25 Oct. 2006'
    # ""%d %B %Y"",  # '25 October 2006'
    # ""%d %B, %Y"",  # '25 October, 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d.%m.%y %H:%M:%S"",  # '25.10.06 14:30:59'
    ""%d.%m.%y %H:%M:%S.%f"",  # '25.10.06 14:30:59.000200'
    ""%d.%m.%y %H:%M"",  # '25.10.06 14:30'
    ""%m/%d/%Y %H:%M:%S"",  # '10/25/2006 14:30:59'
    ""%m/%d/%Y %H:%M:%S.%f"",  # '10/25/2006 14:30:59.000200'
    ""%m/%d/%Y %H:%M"",  # '10/25/2006 14:30'
    ""%m/%d/%y %H:%M:%S"",  # '10/25/06 14:30:59'
    ""%m/%d/%y %H:%M:%S.%f"",  # '10/25/06 14:30:59.000200'
    ""%m/%d/%y %H:%M"",  # '10/25/06 14:30'
]
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "" ""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""d F Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""d F Y H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""d F""
SHORT_DATE_FORMAT = ""d M Y""
SHORT_DATETIME_FORMAT = ""d M Y H:i""
FIRST_DAY_OF_WEEK = 1  # Pazartesi

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '25/10/2006'
    ""%d/%m/%y"",  # '25/10/06'
    ""%y-%m-%d"",  # '06-10-25'
    # ""%d %B %Y"",  # '25 Ekim 2006'
    # ""%d %b. %Y"",  # '25 Eki. 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%d/%m/%Y %H:%M:%S"",  # '25/10/2006 14:30:59'
    ""%d/%m/%Y %H:%M:%S.%f"",  # '25/10/2006 14:30:59.000200'
    ""%d/%m/%Y %H:%M"",  # '25/10/2006 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F Y""  # '25 Hydref 2006'
TIME_FORMAT = ""P""  # '2:30 y.b.'
DATETIME_FORMAT = ""j F Y, P""  # '25 Hydref 2006, 2:30 y.b.'
YEAR_MONTH_FORMAT = ""F Y""  # 'Hydref 2006'
MONTH_DAY_FORMAT = ""j F""  # '25 Hydref'
SHORT_DATE_FORMAT = ""d/m/Y""  # '25/10/2006'
SHORT_DATETIME_FORMAT = ""d/m/Y P""  # '25/10/2006 2:30 y.b.'
FIRST_DAY_OF_WEEK = 1  # 'Dydd Llun'

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '25/10/2006'
    ""%d/%m/%y"",  # '25/10/06'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%d/%m/%Y %H:%M:%S"",  # '25/10/2006 14:30:59'
    ""%d/%m/%Y %H:%M:%S.%f"",  # '25/10/2006 14:30:59.000200'
    ""%d/%m/%Y %H:%M"",  # '25/10/2006 14:30'
    ""%d/%m/%y %H:%M:%S"",  # '25/10/06 14:30:59'
    ""%d/%m/%y %H:%M:%S.%f"",  # '25/10/06 14:30:59.000200'
    ""%d/%m/%y %H:%M"",  # '25/10/06 14:30'
]
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
DATE_FORMAT = r""j \d\e F \d\e Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = r""j \d\e F \d\e Y \a \l\a\s H:i""
YEAR_MONTH_FORMAT = r""F \d\e Y""
MONTH_DAY_FORMAT = r""j \d\e F""
SHORT_DATE_FORMAT = ""d/m/Y""
SHORT_DATETIME_FORMAT = ""d/m/Y H:i""
FIRST_DAY_OF_WEEK = 1
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '25/10/2006'
    ""%d/%m/%y"",  # '25/10/06'
    ""%Y%m%d"",  # '20061025'
]
DATETIME_INPUT_FORMATS = [
    ""%d/%m/%Y %H:%M:%S"",
    ""%d/%m/%Y %H:%M:%S.%f"",
    ""%d/%m/%Y %H:%M"",
    ""%d/%m/%y %H:%M:%S"",
    ""%d/%m/%y %H:%M:%S.%f"",
    ""%d/%m/%y %H:%M"",
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j. F Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j. F Y H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# Kept ISO formats as they are in first position
DATE_INPUT_FORMATS = [
    ""%Y-%m-%d"",  # '2006-10-25'
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
    # ""%d. %b %Y"",  # '25. okt 2006'
    # ""%d %b %Y"",  # '25 okt 2006'
    # ""%d. %b. %Y"",  # '25. okt. 2006'
    # ""%d %b. %Y"",  # '25 okt. 2006'
    # ""%d. %B %Y"",  # '25. oktober 2006'
    # ""%d %B %Y"",  # '25 oktober 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d.%m.%y %H:%M:%S"",  # '25.10.06 14:30:59'
    ""%d.%m.%y %H:%M:%S.%f"",  # '25.10.06 14:30:59.000200'
    ""%d.%m.%y %H:%M"",  # '25.10.06 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = r""j-E, Y-\y\i\l""
TIME_FORMAT = ""G:i""
DATETIME_FORMAT = r""j-E, Y-\y\i\l G:i""
YEAR_MONTH_FORMAT = r""F Y-\y\i\l""
MONTH_DAY_FORMAT = ""j-E""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d-%B, %Y-yil"",  # '25-Oktabr, 2006-yil'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d-%B, %Y-yil %H:%M:%S"",  # '25-Oktabr, 2006-yil 14:30:59'
    ""%d-%B, %Y-yil %H:%M:%S.%f"",  # '25-Oktabr, 2006-yil 14:30:59.000200'
    ""%d-%B, %Y-yil %H:%M"",  # '25-Oktabr, 2006-yil 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""d F Y""
TIME_FORMAT = ""H:i""
# DATETIME_FORMAT =
# YEAR_MONTH_FORMAT =
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""d.m.Y""
# SHORT_DATETIME_FORMAT =
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "" ""  # Non-breaking space
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date

# Formatting for date objects.
DATE_FORMAT = ""N j, Y""
# Formatting for time objects.
TIME_FORMAT = ""P""
# Formatting for datetime objects.
DATETIME_FORMAT = ""N j, Y, P""
# Formatting for date objects when only the year and month are relevant.
YEAR_MONTH_FORMAT = ""F Y""
# Formatting for date objects when only the month and day are relevant.
MONTH_DAY_FORMAT = ""F j""
# Short formatting for date objects.
SHORT_DATE_FORMAT = ""m/d/Y""
# Short formatting for datetime objects.
SHORT_DATETIME_FORMAT = ""m/d/Y P""
# First day of week, to be used on calendars.
# 0 means Sunday, 1 means Monday...
FIRST_DAY_OF_WEEK = 0

# Formats to be used when parsing dates from input boxes, in order.
# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# Note that these format strings are different from the ones to display dates.
# Kept ISO formats as they are in first position
DATE_INPUT_FORMATS = [
    ""%Y-%m-%d"",  # '2006-10-25'
    ""%m/%d/%Y"",  # '10/25/2006'
    ""%m/%d/%y"",  # '10/25/06'
    ""%b %d %Y"",  # 'Oct 25 2006'
    ""%b %d, %Y"",  # 'Oct 25, 2006'
    ""%d %b %Y"",  # '25 Oct 2006'
    ""%d %b, %Y"",  # '25 Oct, 2006'
    ""%B %d %Y"",  # 'October 25 2006'
    ""%B %d, %Y"",  # 'October 25, 2006'
    ""%d %B %Y"",  # '25 October 2006'
    ""%d %B, %Y"",  # '25 October, 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%m/%d/%Y %H:%M:%S"",  # '10/25/2006 14:30:59'
    ""%m/%d/%Y %H:%M:%S.%f"",  # '10/25/2006 14:30:59.000200'
    ""%m/%d/%Y %H:%M"",  # '10/25/2006 14:30'
    ""%m/%d/%y %H:%M:%S"",  # '10/25/06 14:30:59'
    ""%m/%d/%y %H:%M:%S.%f"",  # '10/25/06 14:30:59.000200'
    ""%m/%d/%y %H:%M"",  # '10/25/06 14:30'
]
TIME_INPUT_FORMATS = [
    ""%H:%M:%S"",  # '14:30:59'
    ""%H:%M:%S.%f"",  # '14:30:59.000200'
    ""%H:%M"",  # '14:30'
]

# Decimal separator symbol.
DECIMAL_SEPARATOR = "".""
# Thousand separator symbol.
THOUSAND_SEPARATOR = "",""
# Number of digits that will be together, when splitting them by
# THOUSAND_SEPARATOR. 0 means no grouping, 3 means splitting by thousands.
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""Y년 n월 j일""
TIME_FORMAT = ""A g:i""
DATETIME_FORMAT = ""Y년 n월 j일 g:i A""
YEAR_MONTH_FORMAT = ""Y년 n월""
MONTH_DAY_FORMAT = ""n월 j일""
SHORT_DATE_FORMAT = ""Y-n-j.""
SHORT_DATETIME_FORMAT = ""Y-n-j H:i""
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# Kept ISO formats as they are in first position
DATE_INPUT_FORMATS = [
    ""%Y-%m-%d"",  # '2006-10-25'
    ""%m/%d/%Y"",  # '10/25/2006'
    ""%m/%d/%y"",  # '10/25/06'
    # ""%b %d %Y"",  # 'Oct 25 2006'
    # ""%b %d, %Y"",  # 'Oct 25, 2006'
    # ""%d %b %Y"",  # '25 Oct 2006'
    # ""%d %b, %Y"",  #'25 Oct, 2006'
    # ""%B %d %Y"",  # 'October 25 2006'
    # ""%B %d, %Y"",  #'October 25, 2006'
    # ""%d %B %Y"",  # '25 October 2006'
    # ""%d %B, %Y"",  # '25 October, 2006'
    ""%Y년 %m월 %d일"",  # '2006년 10월 25일', with localized suffix.
]
TIME_INPUT_FORMATS = [
    ""%H:%M:%S"",  # '14:30:59'
    ""%H:%M:%S.%f"",  # '14:30:59.000200'
    ""%H:%M"",  # '14:30'
    ""%H시 %M분 %S초"",  # '14시 30분 59초'
    ""%H시 %M분"",  # '14시 30분'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%m/%d/%Y %H:%M:%S"",  # '10/25/2006 14:30:59'
    ""%m/%d/%Y %H:%M:%S.%f"",  # '10/25/2006 14:30:59.000200'
    ""%m/%d/%Y %H:%M"",  # '10/25/2006 14:30'
    ""%m/%d/%y %H:%M:%S"",  # '10/25/06 14:30:59'
    ""%m/%d/%y %H:%M:%S.%f"",  # '10/25/06 14:30:59.000200'
    ""%m/%d/%y %H:%M"",  # '10/25/06 14:30'
    ""%Y년 %m월 %d일 %H시 %M분 %S초"",  # '2006년 10월 25일 14시 30분 59초'
    ""%Y년 %m월 %d일 %H시 %M분"",  # '2006년 10월 25일 14시 30분'
]

DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F Y""  # '20 januari 2009'
TIME_FORMAT = ""H:i""  # '15:23'
DATETIME_FORMAT = ""j F Y H:i""  # '20 januari 2009 15:23'
YEAR_MONTH_FORMAT = ""F Y""  # 'januari 2009'
MONTH_DAY_FORMAT = ""j F""  # '20 januari'
SHORT_DATE_FORMAT = ""j-n-Y""  # '20-1-2009'
SHORT_DATETIME_FORMAT = ""j-n-Y H:i""  # '20-1-2009 15:23'
FIRST_DAY_OF_WEEK = 1  # Monday (in Dutch 'maandag')

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d-%m-%Y"",  # '20-01-2009'
    ""%d-%m-%y"",  # '20-01-09'
    ""%d/%m/%Y"",  # '20/01/2009'
    ""%d/%m/%y"",  # '20/01/09'
    ""%Y/%m/%d"",  # '2009/01/20'
    # ""%d %b %Y"",  # '20 jan 2009'
    # ""%d %b %y"",  # '20 jan 09'
    # ""%d %B %Y"",  # '20 januari 2009'
    # ""%d %B %y"",  # '20 januari 09'
]
# Kept ISO formats as one is in first position
TIME_INPUT_FORMATS = [
    ""%H:%M:%S"",  # '15:23:35'
    ""%H:%M:%S.%f"",  # '15:23:35.000200'
    ""%H.%M:%S"",  # '15.23:35'
    ""%H.%M:%S.%f"",  # '15.23:35.000200'
    ""%H.%M"",  # '15.23'
    ""%H:%M"",  # '15:23'
]
DATETIME_INPUT_FORMATS = [
    # With time in %H:%M:%S :
    ""%d-%m-%Y %H:%M:%S"",  # '20-01-2009 15:23:35'
    ""%d-%m-%y %H:%M:%S"",  # '20-01-09 15:23:35'
    ""%Y-%m-%d %H:%M:%S"",  # '2009-01-20 15:23:35'
    ""%d/%m/%Y %H:%M:%S"",  # '20/01/2009 15:23:35'
    ""%d/%m/%y %H:%M:%S"",  # '20/01/09 15:23:35'
    ""%Y/%m/%d %H:%M:%S"",  # '2009/01/20 15:23:35'
    # ""%d %b %Y %H:%M:%S"",  # '20 jan 2009 15:23:35'
    # ""%d %b %y %H:%M:%S"",  # '20 jan 09 15:23:35'
    # ""%d %B %Y %H:%M:%S"",  # '20 januari 2009 15:23:35'
    # ""%d %B %y %H:%M:%S"",  # '20 januari 2009 15:23:35'
    # With time in %H:%M:%S.%f :
    ""%d-%m-%Y %H:%M:%S.%f"",  # '20-01-2009 15:23:35.000200'
    ""%d-%m-%y %H:%M:%S.%f"",  # '20-01-09 15:23:35.000200'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2009-01-20 15:23:35.000200'
    ""%d/%m/%Y %H:%M:%S.%f"",  # '20/01/2009 15:23:35.000200'
    ""%d/%m/%y %H:%M:%S.%f"",  # '20/01/09 15:23:35.000200'
    ""%Y/%m/%d %H:%M:%S.%f"",  # '2009/01/20 15:23:35.000200'
    # With time in %H.%M:%S :
    ""%d-%m-%Y %H.%M:%S"",  # '20-01-2009 15.23:35'
    ""%d-%m-%y %H.%M:%S"",  # '20-01-09 15.23:35'
    ""%d/%m/%Y %H.%M:%S"",  # '20/01/2009 15.23:35'
    ""%d/%m/%y %H.%M:%S"",  # '20/01/09 15.23:35'
    # ""%d %b %Y %H.%M:%S"",  # '20 jan 2009 15.23:35'
    # ""%d %b %y %H.%M:%S"",  # '20 jan 09 15.23:35'
    # ""%d %B %Y %H.%M:%S"",  # '20 januari 2009 15.23:35'
    # ""%d %B %y %H.%M:%S"",  # '20 januari 2009 15.23:35'
    # With time in %H.%M:%S.%f :
    ""%d-%m-%Y %H.%M:%S.%f"",  # '20-01-2009 15.23:35.000200'
    ""%d-%m-%y %H.%M:%S.%f"",  # '20-01-09 15.23:35.000200'
    ""%d/%m/%Y %H.%M:%S.%f"",  # '20/01/2009 15.23:35.000200'
    ""%d/%m/%y %H.%M:%S.%f"",  # '20/01/09 15.23:35.000200'
    # With time in %H:%M :
    ""%d-%m-%Y %H:%M"",  # '20-01-2009 15:23'
    ""%d-%m-%y %H:%M"",  # '20-01-09 15:23'
    ""%Y-%m-%d %H:%M"",  # '2009-01-20 15:23'
    ""%d/%m/%Y %H:%M"",  # '20/01/2009 15:23'
    ""%d/%m/%y %H:%M"",  # '20/01/09 15:23'
    ""%Y/%m/%d %H:%M"",  # '2009/01/20 15:23'
    # ""%d %b %Y %H:%M"",  # '20 jan 2009 15:23'
    # ""%d %b %y %H:%M"",  # '20 jan 09 15:23'
    # ""%d %B %Y %H:%M"",  # '20 januari 2009 15:23'
    # ""%d %B %y %H:%M"",  # '20 januari 2009 15:23'
    # With time in %H.%M :
    ""%d-%m-%Y %H.%M"",  # '20-01-2009 15.23'
    ""%d-%m-%y %H.%M"",  # '20-01-09 15.23'
    ""%d/%m/%Y %H.%M"",  # '20/01/2009 15.23'
    ""%d/%m/%y %H.%M"",  # '20/01/09 15.23'
    # ""%d %b %Y %H.%M"",  # '20 jan 2009 15.23'
    # ""%d %b %y %H.%M"",  # '20 jan 09 15.23'
    # ""%d %B %Y %H.%M"",  # '20 januari 2009 15.23'
    # ""%d %B %y %H.%M"",  # '20 januari 2009 15.23'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F, Y""
TIME_FORMAT = ""g:i A""
# DATETIME_FORMAT =
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""j M, Y""
# SHORT_DATETIME_FORMAT =
FIRST_DAY_OF_WEEK = 6  # Saturday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # 25/10/2016
    ""%d/%m/%y"",  # 25/10/16
    ""%d-%m-%Y"",  # 25-10-2016
    ""%d-%m-%y"",  # 25-10-16
]
TIME_INPUT_FORMATS = [
    ""%H:%M:%S"",  # 14:30:59
    ""%H:%M"",  # 14:30
]
DATETIME_INPUT_FORMATS = [
    ""%d/%m/%Y %H:%M:%S"",  # 25/10/2006 14:30:59
    ""%d/%m/%Y %H:%M"",  # 25/10/2006 14:30
]
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j M Y""  # '25 Oct 2006'
TIME_FORMAT = ""P""  # '2:30 p.m.'
DATETIME_FORMAT = ""j M Y, P""  # '25 Oct 2006, 2:30 p.m.'
YEAR_MONTH_FORMAT = ""F Y""  # 'October 2006'
MONTH_DAY_FORMAT = ""j F""  # '25 October'
SHORT_DATE_FORMAT = ""d/m/Y""  # '25/10/2006'
SHORT_DATETIME_FORMAT = ""d/m/Y P""  # '25/10/2006 2:30 p.m.'
FIRST_DAY_OF_WEEK = 0  # Sunday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '25/10/2006'
    ""%d/%m/%y"",  # '25/10/06'
    # ""%b %d %Y"",  # 'Oct 25 2006'
    # ""%b %d, %Y"",  # 'Oct 25, 2006'
    # ""%d %b %Y"",  # '25 Oct 2006'
    # ""%d %b, %Y"",  # '25 Oct, 2006'
    # ""%B %d %Y"",  # 'October 25 2006'
    # ""%B %d, %Y"",  # 'October 25, 2006'
    # ""%d %B %Y"",  # '25 October 2006'
    # ""%d %B, %Y"",  # '25 October, 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%d/%m/%Y %H:%M:%S"",  # '25/10/2006 14:30:59'
    ""%d/%m/%Y %H:%M:%S.%f"",  # '25/10/2006 14:30:59.000200'
    ""%d/%m/%Y %H:%M"",  # '25/10/2006 14:30'
    ""%d/%m/%y %H:%M:%S"",  # '25/10/06 14:30:59'
    ""%d/%m/%y %H:%M:%S.%f"",  # '25/10/06 14:30:59.000200'
    ""%d/%m/%y %H:%M"",  # '25/10/06 14:30'
]
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = r""Y. \g\a\d\a j. F""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = r""Y. \g\a\d\a j. F, H:i""
YEAR_MONTH_FORMAT = r""Y. \g. F""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = r""j.m.Y""
SHORT_DATETIME_FORMAT = ""j.m.Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# Kept ISO formats as they are in first position
DATE_INPUT_FORMATS = [
    ""%Y-%m-%d"",  # '2006-10-25'
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
]
TIME_INPUT_FORMATS = [
    ""%H:%M:%S"",  # '14:30:59'
    ""%H:%M:%S.%f"",  # '14:30:59.000200'
    ""%H:%M"",  # '14:30'
    ""%H.%M.%S"",  # '14.30.59'
    ""%H.%M.%S.%f"",  # '14.30.59.000200'
    ""%H.%M"",  # '14.30'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d.%m.%y %H:%M:%S"",  # '25.10.06 14:30:59'
    ""%d.%m.%y %H:%M:%S.%f"",  # '25.10.06 14:30:59.000200'
    ""%d.%m.%y %H:%M"",  # '25.10.06 14:30'
    ""%d.%m.%y %H.%M.%S"",  # '25.10.06 14.30.59'
    ""%d.%m.%y %H.%M.%S.%f"",  # '25.10.06 14.30.59.000200'
    ""%d.%m.%y %H.%M"",  # '25.10.06 14.30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "" ""  # Non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j E Y г.""
TIME_FORMAT = ""G:i""
DATETIME_FORMAT = ""j E Y г. G:i""
YEAR_MONTH_FORMAT = ""F Y г.""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y %H:%M:%S"",  # '25.10.06 14:30:59'
    ""%d.%m.%y %H:%M:%S.%f"",  # '25.10.06 14:30:59.000200'
    ""%d.%m.%y %H:%M"",  # '25.10.06 14:30'
    ""%d.%m.%y"",  # '25.10.06'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j E Y г.""
TIME_FORMAT = ""G:i""
DATETIME_FORMAT = ""j E Y г. G:i""
YEAR_MONTH_FORMAT = ""F Y г.""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y %H:%M:%S"",  # '25.10.06 14:30:59'
    ""%d.%m.%y %H:%M:%S.%f"",  # '25.10.06 14:30:59.000200'
    ""%d.%m.%y %H:%M"",  # '25.10.06 14:30'
    ""%d.%m.%y"",  # '25.10.06'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""Y年n月j日""  # 2016年9月5日
TIME_FORMAT = ""H:i""  # 20:45
DATETIME_FORMAT = ""Y年n月j日 H:i""  # 2016年9月5日 20:45
YEAR_MONTH_FORMAT = ""Y年n月""  # 2016年9月
MONTH_DAY_FORMAT = ""m月j日""  # 9月5日
SHORT_DATE_FORMAT = ""Y年n月j日""  # 2016年9月5日
SHORT_DATETIME_FORMAT = ""Y年n月j日 H:i""  # 2016年9月5日 20:45
FIRST_DAY_OF_WEEK = 1  # 星期一 (Monday)

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%Y/%m/%d"",  # '2016/09/05'
    ""%Y-%m-%d"",  # '2016-09-05'
    ""%Y年%n月%j日"",  # '2016年9月5日'
]

TIME_INPUT_FORMATS = [
    ""%H:%M"",  # '20:45'
    ""%H:%M:%S"",  # '20:45:29'
    ""%H:%M:%S.%f"",  # '20:45:29.000200'
]

DATETIME_INPUT_FORMATS = [
    ""%Y/%m/%d %H:%M"",  # '2016/09/05 20:45'
    ""%Y-%m-%d %H:%M"",  # '2016-09-05 20:45'
    ""%Y年%n月%j日 %H:%M"",  # '2016年9月5日 14:45'
    ""%Y/%m/%d %H:%M:%S"",  # '2016/09/05 20:45:29'
    ""%Y-%m-%d %H:%M:%S"",  # '2016-09-05 20:45:29'
    ""%Y年%n月%j日 %H:%M:%S"",  # '2016年9月5日 20:45:29'
    ""%Y/%m/%d %H:%M:%S.%f"",  # '2016/09/05 20:45:29.000200'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2016-09-05 20:45:29.000200'
    ""%Y年%n月%j日 %H:%n:%S.%f"",  # '2016年9月5日 20:45:29.000200'
]

DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = """"
NUMBER_GROUPING = 4<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j E Y""
TIME_FORMAT = ""G:i""
DATETIME_FORMAT = ""j E Y, G:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d.%m.%y %H:%M:%S"",  # '25.10.06 14:30:59'
    ""%d.%m.%y %H:%M:%S.%f"",  # '25.10.06 14:30:59.000200'
    ""%d.%m.%y %H:%M"",  # '25.10.06 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j F Y, H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y, H:i""
FIRST_DAY_OF_WEEK = 1

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",
    ""%d.%b.%Y"",
    ""%d %B %Y"",
    ""%A, %d %B %Y"",
]
TIME_INPUT_FORMATS = [
    ""%H:%M"",
    ""%H:%M:%S"",
    ""%H:%M:%S.%f"",
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y, %H:%M"",
    ""%d.%m.%Y, %H:%M:%S"",
    ""%d.%B.%Y, %H:%M"",
    ""%d.%B.%Y, %H:%M:%S"",
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j F Y H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""j F Y""
SHORT_DATETIME_FORMAT = ""j F Y H:i""
FIRST_DAY_OF_WEEK = 0  # Sunday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%Y/%m/%d"",  # '2006/10/25'
]
TIME_INPUT_FORMATS = [
    ""%H:%M"",  # '14:30
    ""%H:%M:%S"",  # '14:30:59'
]
DATETIME_INPUT_FORMATS = [
    ""%Y/%m/%d %H:%M"",  # '2006/10/25 14:30'
    ""%Y/%m/%d %H:%M:%S"",  # '2006/10/25 14:30:59'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""d/m/Y""
TIME_FORMAT = ""P""
DATETIME_FORMAT = ""d/m/Y P""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""d/m/Y""
SHORT_DATETIME_FORMAT = ""d/m/Y P""
FIRST_DAY_OF_WEEK = 0  # Sunday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '25/10/2006'
    ""%d/%m/%y"",  # '25/10/06'
    ""%Y-%m-%d"",  # '2006-10-25'
]
DATETIME_INPUT_FORMATS = [
    ""%d/%m/%Y %H:%M:%S"",  # '25/10/2006 14:30:59'
    ""%d/%m/%Y %H:%M:%S.%f"",  # '25/10/2006 14:30:59.000200'
    ""%d/%m/%Y %H:%M"",  # '25/10/2006 14:30'
    ""%d/%m/%y %H:%M:%S"",  # '25/10/06 14:30:59'
    ""%d/%m/%y %H:%M:%S.%f"",  # '25/10/06 14:30:59.000200'
    ""%d/%m/%y %H:%M"",  # '25/10/06 14:30'
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j F Y H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""j N Y""
SHORT_DATETIME_FORMAT = ""j N Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '25/10/2006'
    ""%d/%m/%y"",  # '25/10/06'
    ""%d.%m.%Y"",  # Swiss [fr_CH] '25.10.2006'
    ""%d.%m.%y"",  # Swiss [fr_CH] '25.10.06'
    # '%d %B %Y', '%d %b %Y', # '25 octobre 2006', '25 oct. 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%d/%m/%Y %H:%M:%S"",  # '25/10/2006 14:30:59'
    ""%d/%m/%Y %H:%M:%S.%f"",  # '25/10/2006 14:30:59.000200'
    ""%d/%m/%Y %H:%M"",  # '25/10/2006 14:30'
    ""%d.%m.%Y %H:%M:%S"",  # Swiss [fr_CH), '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # Swiss (fr_CH), '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # Swiss (fr_CH), '25.10.2006 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j בF Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j בF Y H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j בF""
SHORT_DATE_FORMAT = ""d/m/Y""
SHORT_DATETIME_FORMAT = ""d/m/Y H:i""
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = r""j \d\e F \d\e Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = r""j \d\e F \d\e Y à\s H:i""
YEAR_MONTH_FORMAT = r""F \d\e Y""
MONTH_DAY_FORMAT = r""j \d\e F""
SHORT_DATE_FORMAT = ""d/m/Y""
SHORT_DATETIME_FORMAT = ""d/m/Y H:i""
FIRST_DAY_OF_WEEK = 0  # Sunday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '25/10/2006'
    ""%d/%m/%y"",  # '25/10/06'
    # ""%d de %b de %Y"",  # '24 de Out de 2006'
    # ""%d de %b, %Y"",  # '25 Out, 2006'
    # ""%d de %B de %Y"",  # '25 de Outubro de 2006'
    # ""%d de %B, %Y"",  # '25 de Outubro, 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%d/%m/%Y %H:%M:%S"",  # '25/10/2006 14:30:59'
    ""%d/%m/%Y %H:%M:%S.%f"",  # '25/10/2006 14:30:59.000200'
    ""%d/%m/%Y %H:%M"",  # '25/10/2006 14:30'
    ""%d/%m/%y %H:%M:%S"",  # '25/10/06 14:30:59'
    ""%d/%m/%y %H:%M:%S.%f"",  # '25/10/06 14:30:59.000200'
    ""%d/%m/%y %H:%M"",  # '25/10/06 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""d E Y р.""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""d E Y р. H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""d F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d %B %Y"",  # '25 October 2006'
]
TIME_INPUT_FORMATS = [
    ""%H:%M:%S"",  # '14:30:59'
    ""%H:%M:%S.%f"",  # '14:30:59.000200'
    ""%H:%M"",  # '14:30'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d %B %Y %H:%M:%S"",  # '25 October 2006 14:30:59'
    ""%d %B %Y %H:%M:%S.%f"",  # '25 October 2006 14:30:59.000200'
    ""%d %B %Y %H:%M"",  # '25 October 2006 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = r""\N\gà\y d \t\há\n\g n \nă\m Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = r""H:i \N\gà\y d \t\há\n\g n \nă\m Y""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""d-m-Y""
SHORT_DATETIME_FORMAT = ""H:i d-m-Y""
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j. F Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j. F Y H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
    # ""%d. %B %Y"",  # '25. October 2006'
    # ""%d. %b. %Y"",  # '25. Oct. 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j. N Y.""
TIME_FORMAT = ""G:i""
DATETIME_FORMAT = ""j. N. Y. G:i T""
YEAR_MONTH_FORMAT = ""F Y.""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""Y M j""
# SHORT_DATETIME_FORMAT =
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j ខែ F ឆ្នាំ Y""
TIME_FORMAT = ""G:i""
DATETIME_FORMAT = ""j ខែ F ឆ្នាំ Y, G:i""
# YEAR_MONTH_FORMAT =
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""j M Y""
SHORT_DATETIME_FORMAT = ""j M Y, G:i""
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""d F Y""
TIME_FORMAT = ""g:i A""
# DATETIME_FORMAT =
# YEAR_MONTH_FORMAT =
# MONTH_DAY_FORMAT =
SHORT_DATE_FORMAT = ""j M Y""
# SHORT_DATETIME_FORMAT =
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
# DECIMAL_SEPARATOR =
# THOUSAND_SEPARATOR =
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = r""j N Y""
TIME_FORMAT = r""H:i""
DATETIME_FORMAT = r""j N Y H:i""
YEAR_MONTH_FORMAT = r""F Y""
MONTH_DAY_FORMAT = r""j \d\e F""
SHORT_DATE_FORMAT = r""d/m/Y""
SHORT_DATETIME_FORMAT = r""d/m/Y H:i""
FIRST_DAY_OF_WEEK = 0  # 0: Sunday, 1: Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '31/12/2009'
    ""%d/%m/%y"",  # '31/12/09'
]
DATETIME_INPUT_FORMATS = [
    ""%d/%m/%Y %H:%M:%S"",
    ""%d/%m/%Y %H:%M:%S.%f"",
    ""%d/%m/%Y %H:%M"",
    ""%d/%m/%y %H:%M:%S"",
    ""%d/%m/%y %H:%M:%S.%f"",
    ""%d/%m/%y %H:%M"",
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
DATE_FORMAT = r""j \d\e F \d\e Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = r""j \d\e F \d\e Y \a \l\a\s H:i""
YEAR_MONTH_FORMAT = r""F \d\e Y""
MONTH_DAY_FORMAT = r""j \d\e F""
SHORT_DATE_FORMAT = ""d/m/Y""
SHORT_DATETIME_FORMAT = ""d/m/Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday: ISO 8601
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '25/10/2006'
    ""%d/%m/%y"",  # '25/10/06'
    ""%Y%m%d"",  # '20061025'
]
DATETIME_INPUT_FORMATS = [
    ""%d/%m/%Y %H:%M:%S"",
    ""%d/%m/%Y %H:%M:%S.%f"",
    ""%d/%m/%Y %H:%M"",
    ""%d/%m/%y %H:%M:%S"",
    ""%d/%m/%y %H:%M:%S.%f"",
    ""%d/%m/%y %H:%M"",
]
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j. F Y""
TIME_FORMAT = ""H:i""
# DATETIME_FORMAT =
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""j.n.Y""
# SHORT_DATETIME_FORMAT =
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""Y年n月j日""  # 2016年9月5日
TIME_FORMAT = ""H:i""  # 20:45
DATETIME_FORMAT = ""Y年n月j日 H:i""  # 2016年9月5日 20:45
YEAR_MONTH_FORMAT = ""Y年n月""  # 2016年9月
MONTH_DAY_FORMAT = ""m月j日""  # 9月5日
SHORT_DATE_FORMAT = ""Y年n月j日""  # 2016年9月5日
SHORT_DATETIME_FORMAT = ""Y年n月j日 H:i""  # 2016年9月5日 20:45
FIRST_DAY_OF_WEEK = 1  # 星期一 (Monday)

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%Y/%m/%d"",  # '2016/09/05'
    ""%Y-%m-%d"",  # '2016-09-05'
    ""%Y年%n月%j日"",  # '2016年9月5日'
]

TIME_INPUT_FORMATS = [
    ""%H:%M"",  # '20:45'
    ""%H:%M:%S"",  # '20:45:29'
    ""%H:%M:%S.%f"",  # '20:45:29.000200'
]

DATETIME_INPUT_FORMATS = [
    ""%Y/%m/%d %H:%M"",  # '2016/09/05 20:45'
    ""%Y-%m-%d %H:%M"",  # '2016-09-05 20:45'
    ""%Y年%n月%j日 %H:%M"",  # '2016年9月5日 14:45'
    ""%Y/%m/%d %H:%M:%S"",  # '2016/09/05 20:45:29'
    ""%Y-%m-%d %H:%M:%S"",  # '2016-09-05 20:45:29'
    ""%Y年%n月%j日 %H:%M:%S"",  # '2016年9月5日 20:45:29'
    ""%Y/%m/%d %H:%M:%S.%f"",  # '2016/09/05 20:45:29.000200'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2016-09-05 20:45:29.000200'
    ""%Y年%n月%j日 %H:%n:%S.%f"",  # '2016年9月5日 20:45:29.000200'
]

DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = """"
NUMBER_GROUPING = 4<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = r""j\-\a \d\e F Y""  # '26-a de julio 1887'
TIME_FORMAT = ""H:i""  # '18:59'
DATETIME_FORMAT = r""j\-\a \d\e F Y\, \j\e H:i""  # '26-a de julio 1887, je 18:59'
YEAR_MONTH_FORMAT = r""F \d\e Y""  # 'julio de 1887'
MONTH_DAY_FORMAT = r""j\-\a \d\e F""  # '26-a de julio'
SHORT_DATE_FORMAT = ""Y-m-d""  # '1887-07-26'
SHORT_DATETIME_FORMAT = ""Y-m-d H:i""  # '1887-07-26 18:59'
FIRST_DAY_OF_WEEK = 1  # Monday (lundo)

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%Y-%m-%d"",  # '1887-07-26'
    ""%y-%m-%d"",  # '87-07-26'
    ""%Y %m %d"",  # '1887 07 26'
    ""%Y.%m.%d"",  # '1887.07.26'
    ""%d-a de %b %Y"",  # '26-a de jul 1887'
    ""%d %b %Y"",  # '26 jul 1887'
    ""%d-a de %B %Y"",  # '26-a de julio 1887'
    ""%d %B %Y"",  # '26 julio 1887'
    ""%d %m %Y"",  # '26 07 1887'
    ""%d/%m/%Y"",  # '26/07/1887'
]
TIME_INPUT_FORMATS = [
    ""%H:%M:%S"",  # '18:59:00'
    ""%H:%M"",  # '18:59'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '1887-07-26 18:59:00'
    ""%Y-%m-%d %H:%M"",  # '1887-07-26 18:59'
    ""%Y.%m.%d %H:%M:%S"",  # '1887.07.26 18:59:00'
    ""%Y.%m.%d %H:%M"",  # '1887.07.26 18:59'
    ""%d/%m/%Y %H:%M:%S"",  # '26/07/1887 18:59:00'
    ""%d/%m/%Y %H:%M"",  # '26/07/1887 18:59'
    ""%y-%m-%d %H:%M:%S"",  # '87-07-26 18:59:00'
    ""%y-%m-%d %H:%M"",  # '87-07-26 18:59'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = r""j \d\e F \d\e Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = r""j \d\e F \d\e Y \á\s H:i""
YEAR_MONTH_FORMAT = r""F \d\e Y""
MONTH_DAY_FORMAT = r""j \d\e F""
SHORT_DATE_FORMAT = ""d-m-Y""
SHORT_DATETIME_FORMAT = ""d-m-Y, H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F Y""
TIME_FORMAT = ""g:i A""
# DATETIME_FORMAT =
# YEAR_MONTH_FORMAT =
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""d-m-Y""
# SHORT_DATETIME_FORMAT =
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j E Y ж.""
TIME_FORMAT = ""G:i""
DATETIME_FORMAT = ""j E Y ж. G:i""
YEAR_MONTH_FORMAT = ""F Y ж.""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y H:i""
FIRST_DAY_OF_WEEK = 1  # Дүйшөмбү, Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y %H:%M:%S"",  # '25.10.06 14:30:59'
    ""%d.%m.%y %H:%M:%S.%f"",  # '25.10.06 14:30:59.000200'
    ""%d.%m.%y %H:%M"",  # '25.10.06 14:30'
    ""%d.%m.%y"",  # '25.10.06'
]
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j. F Y.""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j. F Y. H:i""
YEAR_MONTH_FORMAT = ""F Y.""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""j.m.Y.""
SHORT_DATETIME_FORMAT = ""j.m.Y. H:i""
FIRST_DAY_OF_WEEK = 1

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y."",  # '25.10.2006.'
    ""%d.%m.%y."",  # '25.10.06.'
    ""%d. %m. %Y."",  # '25. 10. 2006.'
    ""%d. %m. %y."",  # '25. 10. 06.'
    # ""%d. %b %y."",  # '25. Oct 06.'
    # ""%d. %B %y."",  # '25. October 06.'
    # ""%d. %b '%y."",  # '25. Oct '06.'
    # ""%d. %B '%y."",  # '25. October '06.'
    # ""%d. %b %Y."",  # '25. Oct 2006.'
    # ""%d. %B %Y."",  # '25. October 2006.'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y. %H:%M:%S"",  # '25.10.2006. 14:30:59'
    ""%d.%m.%Y. %H:%M:%S.%f"",  # '25.10.2006. 14:30:59.000200'
    ""%d.%m.%Y. %H:%M"",  # '25.10.2006. 14:30'
    ""%d.%m.%y. %H:%M:%S"",  # '25.10.06. 14:30:59'
    ""%d.%m.%y. %H:%M:%S.%f"",  # '25.10.06. 14:30:59.000200'
    ""%d.%m.%y. %H:%M"",  # '25.10.06. 14:30'
    ""%d. %m. %Y. %H:%M:%S"",  # '25. 10. 2006. 14:30:59'
    ""%d. %m. %Y. %H:%M:%S.%f"",  # '25. 10. 2006. 14:30:59.000200'
    ""%d. %m. %Y. %H:%M"",  # '25. 10. 2006. 14:30'
    ""%d. %m. %y. %H:%M:%S"",  # '25. 10. 06. 14:30:59'
    ""%d. %m. %y. %H:%M:%S.%f"",  # '25. 10. 06. 14:30:59.000200'
    ""%d. %m. %y. %H:%M"",  # '25. 10. 06. 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F Y""
TIME_FORMAT = ""g:i A""
# DATETIME_FORMAT =
# YEAR_MONTH_FORMAT =
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""j M Y""
# SHORT_DATETIME_FORMAT =
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
# DECIMAL_SEPARATOR =
# THOUSAND_SEPARATOR =
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
# DATE_FORMAT =
# TIME_FORMAT =
# DATETIME_FORMAT =
# YEAR_MONTH_FORMAT =
# MONTH_DAY_FORMAT =
# SHORT_DATE_FORMAT =
# SHORT_DATETIME_FORMAT =
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
# DECIMAL_SEPARATOR =
# THOUSAND_SEPARATOR =
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j E Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j E Y H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j E""
SHORT_DATE_FORMAT = ""d-m-Y""
SHORT_DATETIME_FORMAT = ""d-m-Y  H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
    ""%y-%m-%d"",  # '06-10-25'
    # ""%d. %B %Y"",  # '25. października 2006'
    # ""%d. %b. %Y"",  # '25. paź. 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "" ""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = r""j \d\e F \d\e Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = r""j \d\e F \d\e Y \a \l\a\s H:i""
YEAR_MONTH_FORMAT = r""F \d\e Y""
MONTH_DAY_FORMAT = r""j \d\e F""
SHORT_DATE_FORMAT = ""d/m/Y""
SHORT_DATETIME_FORMAT = ""d/m/Y H:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '31/12/2009'
    ""%d/%m/%y"",  # '31/12/09'
]
DATETIME_INPUT_FORMATS = [
    ""%d/%m/%Y %H:%M:%S"",
    ""%d/%m/%Y %H:%M:%S.%f"",
    ""%d/%m/%Y %H:%M"",
    ""%d/%m/%y %H:%M:%S"",
    ""%d/%m/%y %H:%M:%S.%f"",
    ""%d/%m/%y %H:%M"",
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""d F Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j. F Y H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""j.m.Y""
SHORT_DATETIME_FORMAT = ""j.m.Y H:i""
FIRST_DAY_OF_WEEK = 1

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
    ""%d. %m. %Y"",  # '25. 10. 2006'
    ""%d. %m. %y"",  # '25. 10. 06'
]

DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
    ""%d.%m.%y %H:%M:%S"",  # '25.10.06 14:30:59'
    ""%d.%m.%y %H:%M:%S.%f"",  # '25.10.06 14:30:59.000200'
    ""%d.%m.%y %H:%M"",  # '25.10.06 14:30'
    ""%d. %m. %Y %H:%M:%S"",  # '25. 10. 2006 14:30:59'
    ""%d. %m. %Y %H:%M:%S.%f"",  # '25. 10. 2006 14:30:59.000200'
    ""%d. %m. %Y %H:%M"",  # '25. 10. 2006 14:30'
    ""%d. %m. %y %H:%M:%S"",  # '25. 10. 06 14:30:59'
    ""%d. %m. %y %H:%M:%S.%f"",  # '25. 10. 06 14:30:59.000200'
    ""%d. %m. %y %H:%M"",  # '25. 10. 06 14:30'
]

DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j F Y H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""Y-m-d""
SHORT_DATETIME_FORMAT = ""Y-m-d H:i""
FIRST_DAY_OF_WEEK = 1

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# Kept ISO formats as they are in first position
DATE_INPUT_FORMATS = [
    ""%Y-%m-%d"",  # '2006-10-25'
    ""%m/%d/%Y"",  # '10/25/2006'
    ""%m/%d/%y"",  # '10/25/06'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%m/%d/%Y %H:%M:%S"",  # '10/25/2006 14:30:59'
    ""%m/%d/%Y %H:%M:%S.%f"",  # '10/25/2006 14:30:59.000200'
    ""%m/%d/%Y %H:%M"",  # '10/25/2006 14:30'
    ""%m/%d/%y %H:%M:%S"",  # '10/25/06 14:30:59'
    ""%m/%d/%y %H:%M:%S.%f"",  # '10/25/06 14:30:59.000200'
    ""%m/%d/%y %H:%M"",  # '10/25/06 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j. F Y""
TIME_FORMAT = ""G:i""
# DATETIME_FORMAT =
# YEAR_MONTH_FORMAT =
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""d.m.Y""
# SHORT_DATETIME_FORMAT =
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "" ""  # Non-breaking space
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""d F Y""
TIME_FORMAT = ""g.i.A""
# DATETIME_FORMAT =
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""Y-m-d""
# SHORT_DATETIME_FORMAT =
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F، Y""
TIME_FORMAT = ""g:i A""
# DATETIME_FORMAT =
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""d‏/m‏/Y""
# SHORT_DATETIME_FORMAT =
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j. F Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j. F Y H:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y H:i""
FIRST_DAY_OF_WEEK = 1

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F Y""
TIME_FORMAT = ""G:i""
DATETIME_FORMAT = ""j F Y، ساعت G:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""Y/n/j""
SHORT_DATETIME_FORMAT = ""Y/n/j،‏ G:i""
FIRST_DAY_OF_WEEK = 6

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F Y""
TIME_FORMAT = ""H:i""
# DATETIME_FORMAT =
# YEAR_MONTH_FORMAT =
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""j M Y""
# SHORT_DATETIME_FORMAT =
# FIRST_DAY_OF_WEEK =

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j F Y""
TIME_FORMAT = ""h:ia""
DATETIME_FORMAT = ""j F Y h:ia""
# YEAR_MONTH_FORMAT =
MONTH_DAY_FORMAT = ""j F""
SHORT_DATE_FORMAT = ""j M Y""
SHORT_DATETIME_FORMAT = ""j M Y h:ia""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# DATE_INPUT_FORMATS =
# TIME_INPUT_FORMATS =
# DATETIME_INPUT_FORMATS =
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
# NUMBER_GROUPING =<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j. E Y.""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = ""j. E Y. H:i""
YEAR_MONTH_FORMAT = ""F Y.""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""j.m.Y.""
SHORT_DATETIME_FORMAT = ""j.m.Y. H:i""
FIRST_DAY_OF_WEEK = 1

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# Kept ISO formats as they are in first position
DATE_INPUT_FORMATS = [
    ""%Y-%m-%d"",  # '2006-10-25'
    ""%d.%m.%Y."",  # '25.10.2006.'
    ""%d.%m.%y."",  # '25.10.06.'
    ""%d. %m. %Y."",  # '25. 10. 2006.'
    ""%d. %m. %y."",  # '25. 10. 06.'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%d.%m.%Y. %H:%M:%S"",  # '25.10.2006. 14:30:59'
    ""%d.%m.%Y. %H:%M:%S.%f"",  # '25.10.2006. 14:30:59.000200'
    ""%d.%m.%Y. %H:%M"",  # '25.10.2006. 14:30'
    ""%d.%m.%y. %H:%M:%S"",  # '25.10.06. 14:30:59'
    ""%d.%m.%y. %H:%M:%S.%f"",  # '25.10.06. 14:30:59.000200'
    ""%d.%m.%y. %H:%M"",  # '25.10.06. 14:30'
    ""%d. %m. %Y. %H:%M:%S"",  # '25. 10. 2006. 14:30:59'
    ""%d. %m. %Y. %H:%M:%S.%f"",  # '25. 10. 2006. 14:30:59.000200'
    ""%d. %m. %Y. %H:%M"",  # '25. 10. 2006. 14:30'
    ""%d. %m. %y. %H:%M:%S"",  # '25. 10. 06. 14:30:59'
    ""%d. %m. %y. %H:%M:%S.%f"",  # '25. 10. 06. 14:30:59.000200'
    ""%d. %m. %y. %H:%M"",  # '25. 10. 06. 14:30'
]

DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = "".""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""N j, Y""
TIME_FORMAT = ""P""
DATETIME_FORMAT = ""N j, Y, P""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""F j""
SHORT_DATE_FORMAT = ""m/d/Y""
SHORT_DATETIME_FORMAT = ""m/d/Y P""
FIRST_DAY_OF_WEEK = 0  # Sunday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
# Kept ISO formats as they are in first position
DATE_INPUT_FORMATS = [
    ""%Y-%m-%d"",  # '2006-10-25'
    ""%m/%d/%Y"",  # '10/25/2006'
    ""%m/%d/%y"",  # '10/25/06'
    # ""%b %d %Y"",  # 'Oct 25 2006'
    # ""%b %d, %Y"",  # 'Oct 25, 2006'
    # ""%d %b %Y"",  # '25 Oct 2006'
    # ""%d %b, %Y"",  # '25 Oct, 2006'
    # ""%B %d %Y"",  # 'October 25 2006'
    # ""%B %d, %Y"",  # 'October 25, 2006'
    # ""%d %B %Y"",  # '25 October 2006'
    # ""%d %B, %Y"",  # '25 October, 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%Y-%m-%d %H:%M:%S"",  # '2006-10-25 14:30:59'
    ""%Y-%m-%d %H:%M:%S.%f"",  # '2006-10-25 14:30:59.000200'
    ""%Y-%m-%d %H:%M"",  # '2006-10-25 14:30'
    ""%m/%d/%Y %H:%M:%S"",  # '10/25/2006 14:30:59'
    ""%m/%d/%Y %H:%M:%S.%f"",  # '10/25/2006 14:30:59.000200'
    ""%m/%d/%Y %H:%M"",  # '10/25/2006 14:30'
    ""%m/%d/%y %H:%M:%S"",  # '10/25/06 14:30:59'
    ""%m/%d/%y %H:%M:%S.%f"",  # '10/25/06 14:30:59.000200'
    ""%m/%d/%y %H:%M"",  # '10/25/06 14:30'
]
DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
# The *_FORMAT strings use the Django date format syntax,
# see https://docs.djangoproject.com/en/dev/ref/templates/builtins/#date
DATE_FORMAT = ""j. F Y""
TIME_FORMAT = ""G:i""
DATETIME_FORMAT = ""j. F Y G:i""
YEAR_MONTH_FORMAT = ""F Y""
MONTH_DAY_FORMAT = ""j. F""
SHORT_DATE_FORMAT = ""d.m.Y""
SHORT_DATETIME_FORMAT = ""d.m.Y G:i""
FIRST_DAY_OF_WEEK = 1  # Monday

# The *_INPUT_FORMATS strings use the Python strftime format syntax,
# see https://docs.python.org/library/datetime.html#strftime-strptime-behavior
DATE_INPUT_FORMATS = [
    ""%d.%m.%Y"",  # '25.10.2006'
    ""%d.%m.%y"",  # '25.10.06'
    ""%y-%m-%d"",  # '06-10-25'
    # ""%d. %B %Y"",  # '25. October 2006'
    # ""%d. %b. %Y"",  # '25. Oct. 2006'
]
DATETIME_INPUT_FORMATS = [
    ""%d.%m.%Y %H:%M:%S"",  # '25.10.2006 14:30:59'
    ""%d.%m.%Y %H:%M:%S.%f"",  # '25.10.2006 14:30:59.000200'
    ""%d.%m.%Y %H:%M"",  # '25.10.2006 14:30'
]
DECIMAL_SEPARATOR = "",""
THOUSAND_SEPARATOR = ""\xa0""  # non-breaking space
NUMBER_GROUPING = 3<EOS>"
"<BOS># This file is distributed under the same license as the Django package.
#
DATE_FORMAT = r""j \d\e F \d\e Y""
TIME_FORMAT = ""H:i""
DATETIME_FORMAT = r""j \d\e F \d\e Y \a \l\a\s H:i""
YEAR_MONTH_FORMAT = r""F \d\e Y""
MONTH_DAY_FORMAT = r""j \d\e F""
SHORT_DATE_FORMAT = ""d/m/Y""
SHORT_DATETIME_FORMAT = ""d/m/Y H:i""
FIRST_DAY_OF_WEEK = 0  # Sunday

DATE_INPUT_FORMATS = [
    ""%d/%m/%Y"",  # '31/12/2009'
    ""%d/%m/%y"",  # '31/12/09'
]
DATETIME_INPUT_FORMATS = [
    ""%d/%m/%Y %H:%M:%S"",
    ""%d/%m/%Y %H:%M:%S.%f"",
    ""%d/%m/%Y %H:%M"",
    ""%d/%m/%y %H:%M:%S"",
    ""%d/%m/%y %H:%M:%S.%f"",
    ""%d/%m/%y %H:%M"",
]

DECIMAL_SEPARATOR = "".""
THOUSAND_SEPARATOR = "",""
NUMBER_GROUPING = 3<EOS>"
"<BOS>import inspect
import os
from importlib import import_module

from django.core.exceptions import ImproperlyConfigured
from django.utils.functional import cached_property
from django.utils.module_loading import import_string, module_has_submodule

APPS_MODULE_NAME = ""apps""
MODELS_MODULE_NAME = ""models""


class AppConfig:
    """"""Class representing a Django application and its configuration.""""""

    def __init__(self, app_name, app_module):
        # Full Python path to the application e.g. 'django.contrib.admin'.
        self.name = app_name

        # Root module for the application e.g. <module 'django.contrib.admin'
        # from 'django/contrib/admin/__init__.py'>.
        self.module = app_module

        # Reference to the Apps registry that holds this AppConfig. Set by the
        # registry when it registers the AppConfig instance.
        self.apps = None

        # The following attributes could be defined at the class level in a
        # subclass, hence the test-and-set pattern.

        # Last component of the Python path to the application e.g. 'admin'.
        # This value must be unique across a Django project.
        if not hasattr(self, ""label""):
            self.label = app_name.rpartition(""."")[2]
        if not self.label.isidentifier():
            raise ImproperlyConfigured(
                ""The app label '%s' is not a valid Python identifier."" % self.label
            )

        # Human-readable name for the application e.g. ""Admin"".
        if not hasattr(self, ""verbose_name""):
            self.verbose_name = self.label.title()

        # Filesystem path to the application directory e.g.
        # '/path/to/django/contrib/admin'.
        if not hasattr(self, ""path""):
            self.path = self._path_from_module(app_module)

        # Module containing models e.g. <module 'django.contrib.admin.models'
        # from 'django/contrib/admin/models.py'>. Set by import_models().
        # None if the application doesn't have a models module.
        self.models_module = None

        # Mapping of lowercase model names to model classes. Initially set to
        # None to prevent accidental access before import_models() runs.
        self.models = None

    def __repr__(self):
        return ""<%s: %s>"" % (self.__class__.__name__, self.label)

    @cached_property
    def default_auto_field(self):
        from django.conf import settings

        return settings.DEFAULT_AUTO_FIELD

    @property
    def _is_default_auto_field_overridden(self):
        return self.__class__.default_auto_field is not AppConfig.default_auto_field

    def _path_from_module(self, module):
        """"""Attempt to determine app's filesystem path from its module.""""""
        # See #21874 for extended discussion of the behavior of this method in
        # various cases.
        # Convert to list because __path__ may not support indexing.
        paths = list(getattr(module, ""__path__"", []))
        if len(paths) != 1:
            filename = getattr(module, ""__file__"", None)
            if filename is not None:
                paths = [os.path.dirname(filename)]
            else:
                # For unknown reasons, sometimes the list returned by __path__
                # contains duplicates that must be removed (#25246).
                paths = list(set(paths))
        if len(paths) > 1:
            raise ImproperlyConfigured(
                ""The app module %r has multiple filesystem locations (%r); ""
                ""you must configure this app with an AppConfig subclass ""
                ""with a 'path' class attribute."" % (module, paths)
            )
        elif not paths:
            raise ImproperlyConfigured(
                ""The app module %r has no filesystem location, ""
                ""you must configure this app with an AppConfig subclass ""
                ""with a 'path' class attribute."" % module
            )
        return paths[0]

    @classmethod
    def create(cls, entry):
        """"""
        Factory that creates an app config from an entry in INSTALLED_APPS.
        """"""
        # create() eventually returns app_config_class(app_name, app_module).
        app_config_class = None
        app_name = None
        app_module = None

        # If import_module succeeds, entry points to the app module.
        try:
            app_module = import_module(entry)
        except Exception:
            pass
        else:
            # If app_module has an apps submodule that defines a single
            # AppConfig subclass, use it automatically.
            # To prevent this, an AppConfig subclass can declare a class
            # variable default = False.
            # If the apps module defines more than one AppConfig subclass,
            # the default one can declare default = True.
            if module_has_submodule(app_module, APPS_MODULE_NAME):
                mod_path = ""%s.%s"" % (entry, APPS_MODULE_NAME)
                mod = import_module(mod_path)
                # Check if there's exactly one AppConfig candidate,
                # excluding those that explicitly define default = False.
                app_configs = [
                    (name, candidate)
                    for name, candidate in inspect.getmembers(mod, inspect.isclass)
                    if (
                        issubclass(candidate, cls)
                        and candidate is not cls
                        and getattr(candidate, ""default"", True)
                    )
                ]
                if len(app_configs) == 1:
                    app_config_class = app_configs[0][1]
                else:
                    # Check if there's exactly one AppConfig subclass,
                    # among those that explicitly define default = True.
                    app_configs = [
                        (name, candidate)
                        for name, candidate in app_configs
                        if getattr(candidate, ""default"", False)
                    ]
                    if len(app_configs) > 1:
                        candidates = [repr(name) for name, _ in app_configs]
                        raise RuntimeError(
                            ""%r declares more than one default AppConfig: ""
                            ""%s."" % (mod_path, "", "".join(candidates))
                        )
                    elif len(app_configs) == 1:
                        app_config_class = app_configs[0][1]

            # Use the default app config class if we didn't find anything.
            if app_config_class is None:
                app_config_class = cls
                app_name = entry

        # If import_string succeeds, entry is an app config class.
        if app_config_class is None:
            try:
                app_config_class = import_string(entry)
            except Exception:
                pass
        # If both import_module and import_string failed, it means that entry
        # doesn't have a valid value.
        if app_module is None and app_config_class is None:
            # If the last component of entry starts with an uppercase letter,
            # then it was likely intended to be an app config class; if not,
            # an app module. Provide a nice error message in both cases.
            mod_path, _, cls_name = entry.rpartition(""."")
            if mod_path and cls_name[0].isupper():
                # We could simply re-trigger the string import exception, but
                # we're going the extra mile and providing a better error
                # message for typos in INSTALLED_APPS.
                # This may raise ImportError, which is the best exception
                # possible if the module at mod_path cannot be imported.
                mod = import_module(mod_path)
                candidates = [
                    repr(name)
                    for name, candidate in inspect.getmembers(mod, inspect.isclass)
                    if issubclass(candidate, cls) and candidate is not cls
                ]
                msg = ""Module '%s' does not contain a '%s' class."" % (
                    mod_path,
                    cls_name,
                )
                if candidates:
                    msg += "" Choices are: %s."" % "", "".join(candidates)
                raise ImportError(msg)
            else:
                # Re-trigger the module import exception.
                import_module(entry)

        # Check for obvious errors. (This check prevents duck typing, but
        # it could be removed if it became a problem in practice.)
        if not issubclass(app_config_class, AppConfig):
            raise ImproperlyConfigured(""'%s' isn't a subclass of AppConfig."" % entry)

        # Obtain app name here rather than in AppClass.__init__ to keep
        # all error checking for entries in INSTALLED_APPS in one place.
        if app_name is None:
            try:
                app_name = app_config_class.name
            except AttributeError:
                raise ImproperlyConfigured(""'%s' must supply a name attribute."" % entry)

        # Ensure app_name points to a valid module.
        try:
            app_module = import_module(app_name)
        except ImportError:
            raise ImproperlyConfigured(
                ""Cannot import '%s'. Check that '%s.%s.name' is correct.""
                % (
                    app_name,
                    app_config_class.__module__,
                    app_config_class.__qualname__,
                )
            )

        # Entry is a path to an app config class.
        return app_config_class(app_name, app_module)

    def get_model(self, model_name, require_ready=True):
        """"""
        Return the model with the given case-insensitive model_name.

        Raise LookupError if no model exists with this name.
        """"""
        if require_ready:
            self.apps.check_models_ready()
        else:
            self.apps.check_apps_ready()
        try:
            return self.models[model_name.lower()]
        except KeyError:
            raise LookupError(
                ""App '%s' doesn't have a '%s' model."" % (self.label, model_name)
            )

    def get_models(self, include_auto_created=False, include_swapped=False):
        """"""
        Return an iterable of models.

        By default, the following models aren't included:

        - auto-created models for many-to-many relations without
          an explicit intermediate table,
        - models that have been swapped out.

        Set the corresponding keyword argument to True to include such models.
        Keyword arguments aren't documented; they're a private API.
        """"""
        self.apps.check_models_ready()
        for model in self.models.values():
            if model._meta.auto_created and not include_auto_created:
                continue
            if model._meta.swapped and not include_swapped:
                continue
            yield model

    def import_models(self):
        # Dictionary of models for this app, primarily maintained in the
        # 'all_models' attribute of the Apps this AppConfig is attached to.
        self.models = self.apps.all_models[self.label]

        if module_has_submodule(self.module, MODELS_MODULE_NAME):
            models_module_name = ""%s.%s"" % (self.name, MODELS_MODULE_NAME)
            self.models_module = import_module(models_module_name)

    def ready(self):
        """"""
        Override this method in subclasses to run code when Django starts.
        """"""<EOS>"
"<BOS>from .config import AppConfig
from .registry import apps

__all__ = [""AppConfig"", ""apps""]<EOS>"
"<BOS>import functools
import sys
import threading
import warnings
from collections import Counter, defaultdict
from functools import partial

from django.core.exceptions import AppRegistryNotReady, ImproperlyConfigured

from .config import AppConfig


class Apps:
    """"""
    A registry that stores the configuration of installed applications.

    It also keeps track of models, e.g. to provide reverse relations.
    """"""

    def __init__(self, installed_apps=()):
        # installed_apps is set to None when creating the main registry
        # because it cannot be populated at that point. Other registries must
        # provide a list of installed apps and are populated immediately.
        if installed_apps is None and hasattr(sys.modules[__name__], ""apps""):
            raise RuntimeError(""You must supply an installed_apps argument."")

        # Mapping of app labels => model names => model classes. Every time a
        # model is imported, ModelBase.__new__ calls apps.register_model which
        # creates an entry in all_models. All imported models are registered,
        # regardless of whether they're defined in an installed application
        # and whether the registry has been populated. Since it isn't possible
        # to reimport a module safely (it could reexecute initialization code)
        # all_models is never overridden or reset.
        self.all_models = defaultdict(dict)

        # Mapping of labels to AppConfig instances for installed apps.
        self.app_configs = {}

        # Stack of app_configs. Used to store the current state in
        # set_available_apps and set_installed_apps.
        self.stored_app_configs = []

        # Whether the registry is populated.
        self.apps_ready = self.models_ready = self.ready = False
        # For the autoreloader.
        self.ready_event = threading.Event()

        # Lock for thread-safe population.
        self._lock = threading.RLock()
        self.loading = False

        # Maps (""app_label"", ""modelname"") tuples to lists of functions to be
        # called when the corresponding model is ready. Used by this class's
        # `lazy_model_operation()` and `do_pending_operations()` methods.
        self._pending_operations = defaultdict(list)

        # Populate apps and models, unless it's the main registry.
        if installed_apps is not None:
            self.populate(installed_apps)

    def populate(self, installed_apps=None):
        """"""
        Load application configurations and models.

        Import each application module and then each model module.

        It is thread-safe and idempotent, but not reentrant.
        """"""
        if self.ready:
            return

        # populate() might be called by two threads in parallel on servers
        # that create threads before initializing the WSGI callable.
        with self._lock:
            if self.ready:
                return

            # An RLock prevents other threads from entering this section. The
            # compare and set operation below is atomic.
            if self.loading:
                # Prevent reentrant calls to avoid running AppConfig.ready()
                # methods twice.
                raise RuntimeError(""populate() isn't reentrant"")
            self.loading = True

            # Phase 1: initialize app configs and import app modules.
            for entry in installed_apps:
                if isinstance(entry, AppConfig):
                    app_config = entry
                else:
                    app_config = AppConfig.create(entry)
                if app_config.label in self.app_configs:
                    raise ImproperlyConfigured(
                        ""Application labels aren't unique, ""
                        ""duplicates: %s"" % app_config.label
                    )

                self.app_configs[app_config.label] = app_config
                app_config.apps = self

            # Check for duplicate app names.
            counts = Counter(
                app_config.name for app_config in self.app_configs.values()
            )
            duplicates = [name for name, count in counts.most_common() if count > 1]
            if duplicates:
                raise ImproperlyConfigured(
                    ""Application names aren't unique, ""
                    ""duplicates: %s"" % "", "".join(duplicates)
                )

            self.apps_ready = True

            # Phase 2: import models modules.
            for app_config in self.app_configs.values():
                app_config.import_models()

            self.clear_cache()

            self.models_ready = True

            # Phase 3: run ready() methods of app configs.
            for app_config in self.get_app_configs():
                app_config.ready()

            self.ready = True
            self.ready_event.set()

    def check_apps_ready(self):
        """"""Raise an exception if all apps haven't been imported yet.""""""
        if not self.apps_ready:
            from django.conf import settings

            # If ""not ready"" is due to unconfigured settings, accessing
            # INSTALLED_APPS raises a more helpful ImproperlyConfigured
            # exception.
            settings.INSTALLED_APPS
            raise AppRegistryNotReady(""Apps aren't loaded yet."")

    def check_models_ready(self):
        """"""Raise an exception if all models haven't been imported yet.""""""
        if not self.models_ready:
            raise AppRegistryNotReady(""Models aren't loaded yet."")

    def get_app_configs(self):
        """"""Import applications and return an iterable of app configs.""""""
        self.check_apps_ready()
        return self.app_configs.values()

    def get_app_config(self, app_label):
        """"""
        Import applications and returns an app config for the given label.

        Raise LookupError if no application exists with this label.
        """"""
        self.check_apps_ready()
        try:
            return self.app_configs[app_label]
        except KeyError:
            message = ""No installed app with label '%s'."" % app_label
            for app_config in self.get_app_configs():
                if app_config.name == app_label:
                    message += "" Did you mean '%s'?"" % app_config.label
                    break
            raise LookupError(message)

    # This method is performance-critical at least for Django's test suite.
    @functools.lru_cache(maxsize=None)
    def get_models(self, include_auto_created=False, include_swapped=False):
        """"""
        Return a list of all installed models.

        By default, the following models aren't included:

        - auto-created models for many-to-many relations without
          an explicit intermediate table,
        - models that have been swapped out.

        Set the corresponding keyword argument to True to include such models.
        """"""
        self.check_models_ready()

        result = []
        for app_config in self.app_configs.values():
            result.extend(app_config.get_models(include_auto_created, include_swapped))
        return result

    def get_model(self, app_label, model_name=None, require_ready=True):
        """"""
        Return the model matching the given app_label and model_name.

        As a shortcut, app_label may be in the form <app_label>.<model_name>.

        model_name is case-insensitive.

        Raise LookupError if no application exists with this label, or no
        model exists with this name in the application. Raise ValueError if
        called with a single argument that doesn't contain exactly one dot.
        """"""
        if require_ready:
            self.check_models_ready()
        else:
            self.check_apps_ready()

        if model_name is None:
            app_label, model_name = app_label.split(""."")

        app_config = self.get_app_config(app_label)

        if not require_ready and app_config.models is None:
            app_config.import_models()

        return app_config.get_model(model_name, require_ready=require_ready)

    def register_model(self, app_label, model):
        # Since this method is called when models are imported, it cannot
        # perform imports because of the risk of import loops. It mustn't
        # call get_app_config().
        model_name = model._meta.model_name
        app_models = self.all_models[app_label]
        if model_name in app_models:
            if (
                model.__name__ == app_models[model_name].__name__
                and model.__module__ == app_models[model_name].__module__
            ):
                warnings.warn(
                    ""Model '%s.%s' was already registered. Reloading models is not ""
                    ""advised as it can lead to inconsistencies, most notably with ""
                    ""related models."" % (app_label, model_name),
                    RuntimeWarning,
                    stacklevel=2,
                )
            else:
                raise RuntimeError(
                    ""Conflicting '%s' models in application '%s': %s and %s.""
                    % (model_name, app_label, app_models[model_name], model)
                )
        app_models[model_name] = model
        self.do_pending_operations(model)
        self.clear_cache()

    def is_installed(self, app_name):
        """"""
        Check whether an application with this name exists in the registry.

        app_name is the full name of the app e.g. 'django.contrib.admin'.
        """"""
        self.check_apps_ready()
        return any(ac.name == app_name for ac in self.app_configs.values())

    def get_containing_app_config(self, object_name):
        """"""
        Look for an app config containing a given object.

        object_name is the dotted Python path to the object.

        Return the app config for the inner application in case of nesting.
        Return None if the object isn't in any registered app config.
        """"""
        self.check_apps_ready()
        candidates = []
        for app_config in self.app_configs.values():
            if object_name.startswith(app_config.name):
                subpath = object_name[len(app_config.name) :]
                if subpath == """" or subpath[0] == ""."":
                    candidates.append(app_config)
        if candidates:
            return sorted(candidates, key=lambda ac: -len(ac.name))[0]

    def get_registered_model(self, app_label, model_name):
        """"""
        Similar to get_model(), but doesn't require that an app exists with
        the given app_label.

        It's safe to call this method at import time, even while the registry
        is being populated.
        """"""
        model = self.all_models[app_label].get(model_name.lower())
        if model is None:
            raise LookupError(""Model '%s.%s' not registered."" % (app_label, model_name))
        return model

    @functools.lru_cache(maxsize=None)
    def get_swappable_settings_name(self, to_string):
        """"""
        For a given model string (e.g. ""auth.User""), return the name of the
        corresponding settings name if it refers to a swappable model. If the
        referred model is not swappable, return None.

        This method is decorated with lru_cache because it's performance
        critical when it comes to migrations. Since the swappable settings don't
        change after Django has loaded the settings, there is no reason to get
        the respective settings attribute over and over again.
        """"""
        to_string = to_string.lower()
        for model in self.get_models(include_swapped=True):
            swapped = model._meta.swapped
            # Is this model swapped out for the model given by to_string?
            if swapped and swapped.lower() == to_string:
                return model._meta.swappable
            # Is this model swappable and the one given by to_string?
            if model._meta.swappable and model._meta.label_lower == to_string:
                return model._meta.swappable
        return None

    def set_available_apps(self, available):
        """"""
        Restrict the set of installed apps used by get_app_config[s].

        available must be an iterable of application names.

        set_available_apps() must be balanced with unset_available_apps().

        Primarily used for performance optimization in TransactionTestCase.

        This method is safe in the sense that it doesn't trigger any imports.
        """"""
        available = set(available)
        installed = {app_config.name for app_config in self.get_app_configs()}
        if not available.issubset(installed):
            raise ValueError(
                ""Available apps isn't a subset of installed apps, extra apps: %s""
                % "", "".join(available - installed)
            )

        self.stored_app_configs.append(self.app_configs)
        self.app_configs = {
            label: app_config
            for label, app_config in self.app_configs.items()
            if app_config.name in available
        }
        self.clear_cache()

    def unset_available_apps(self):
        """"""Cancel a previous call to set_available_apps().""""""
        self.app_configs = self.stored_app_configs.pop()
        self.clear_cache()

    def set_installed_apps(self, installed):
        """"""
        Enable a different set of installed apps for get_app_config[s].

        installed must be an iterable in the same format as INSTALLED_APPS.

        set_installed_apps() must be balanced with unset_installed_apps(),
        even if it exits with an exception.

        Primarily used as a receiver of the setting_changed signal in tests.

        This method may trigger new imports, which may add new models to the
        registry of all imported models. They will stay in the registry even
        after unset_installed_apps(). Since it isn't possible to replay
        imports safely (e.g. that could lead to registering listeners twice),
        models are registered when they're imported and never removed.
        """"""
        if not self.ready:
            raise AppRegistryNotReady(""App registry isn't ready yet."")
        self.stored_app_configs.append(self.app_configs)
        self.app_configs = {}
        self.apps_ready = self.models_ready = self.loading = self.ready = False
        self.clear_cache()
        self.populate(installed)

    def unset_installed_apps(self):
        """"""Cancel a previous call to set_installed_apps().""""""
        self.app_configs = self.stored_app_configs.pop()
        self.apps_ready = self.models_ready = self.ready = True
        self.clear_cache()

    def clear_cache(self):
        """"""
        Clear all internal caches, for methods that alter the app registry.

        This is mostly used in tests.
        """"""
        # Call expire cache on each model. This will purge
        # the relation tree and the fields cache.
        self.get_models.cache_clear()
        if self.ready:
            # Circumvent self.get_models() to prevent that the cache is refilled.
            # This particularly prevents that an empty value is cached while cloning.
            for app_config in self.app_configs.values():
                for model in app_config.get_models(include_auto_created=True):
                    model._meta._expire_cache()

    def lazy_model_operation(self, function, *model_keys):
        """"""
        Take a function and a number of (""app_label"", ""modelname"") tuples, and
        when all the corresponding models have been imported and registered,
        call the function with the model classes as its arguments.

        The function passed to this method must accept exactly n models as
        arguments, where n=len(model_keys).
        """"""
        # Base case: no arguments, just execute the function.
        if not model_keys:
            function()
        # Recursive case: take the head of model_keys, wait for the
        # corresponding model class to be imported and registered, then apply
        # that argument to the supplied function. Pass the resulting partial
        # to lazy_model_operation() along with the remaining model args and
        # repeat until all models are loaded and all arguments are applied.
        else:
            next_model, *more_models = model_keys

            # This will be executed after the class corresponding to next_model
            # has been imported and registered. The `func` attribute provides
            # duck-type compatibility with partials.
            def apply_next_model(model):
                next_function = partial(apply_next_model.func, model)
                self.lazy_model_operation(next_function, *more_models)

            apply_next_model.func = function

            # If the model has already been imported and registered, partially
            # apply it to the function now. If not, add it to the list of
            # pending operations for the model, where it will be executed with
            # the model class as its sole argument once the model is ready.
            try:
                model_class = self.get_registered_model(*next_model)
            except LookupError:
                self._pending_operations[next_model].append(apply_next_model)
            else:
                apply_next_model(model_class)

    def do_pending_operations(self, model):
        """"""
        Take a newly-prepared model and pass it to each function waiting for
        it. This is called at the very end of Apps.register_model().
        """"""
        key = model._meta.app_label, model._meta.model_name
        for function in self._pending_operations.pop(key, []):
            function(model)


apps = Apps(installed_apps=None)<EOS>"
"<BOS>import inspect
from importlib import import_module
from inspect import cleandoc
from pathlib import Path

from django.apps import apps
from django.contrib import admin
from django.contrib.admin.views.decorators import staff_member_required
from django.contrib.admindocs import utils
from django.contrib.admindocs.utils import (
    remove_non_capturing_groups,
    replace_metacharacters,
    replace_named_groups,
    replace_unnamed_groups,
)
from django.core.exceptions import ImproperlyConfigured, ViewDoesNotExist
from django.db import models
from django.http import Http404
from django.template.engine import Engine
from django.urls import get_mod_func, get_resolver, get_urlconf
from django.utils._os import safe_join
from django.utils.decorators import method_decorator
from django.utils.functional import cached_property
from django.utils.inspect import (
    func_accepts_kwargs,
    func_accepts_var_args,
    get_func_full_args,
    method_has_no_args,
)
from django.utils.translation import gettext as _
from django.views.generic import TemplateView

from .utils import get_view_name

# Exclude methods starting with these strings from documentation
MODEL_METHODS_EXCLUDE = (""_"", ""add_"", ""delete"", ""save"", ""set_"")


class BaseAdminDocsView(TemplateView):
    """"""
    Base view for admindocs views.
    """"""

    @method_decorator(staff_member_required)
    def dispatch(self, request, *args, **kwargs):
        if not utils.docutils_is_available:
            # Display an error message for people without docutils
            self.template_name = ""admin_doc/missing_docutils.html""
            return self.render_to_response(admin.site.each_context(request))
        return super().dispatch(request, *args, **kwargs)

    def get_context_data(self, **kwargs):
        return super().get_context_data(
            **{
                **kwargs,
                **admin.site.each_context(self.request),
            }
        )


class BookmarkletsView(BaseAdminDocsView):
    template_name = ""admin_doc/bookmarklets.html""


class TemplateTagIndexView(BaseAdminDocsView):
    template_name = ""admin_doc/template_tag_index.html""

    def get_context_data(self, **kwargs):
        tags = []
        try:
            engine = Engine.get_default()
        except ImproperlyConfigured:
            # Non-trivial TEMPLATES settings aren't supported (#24125).
            pass
        else:
            app_libs = sorted(engine.template_libraries.items())
            builtin_libs = [("""", lib) for lib in engine.template_builtins]
            for module_name, library in builtin_libs + app_libs:
                for tag_name, tag_func in library.tags.items():
                    title, body, metadata = utils.parse_docstring(tag_func.__doc__)
                    title = title and utils.parse_rst(
                        title, ""tag"", _(""tag:"") + tag_name
                    )
                    body = body and utils.parse_rst(body, ""tag"", _(""tag:"") + tag_name)
                    for key in metadata:
                        metadata[key] = utils.parse_rst(
                            metadata[key], ""tag"", _(""tag:"") + tag_name
                        )
                    tag_library = module_name.split(""."")[-1]
                    tags.append(
                        {
                            ""name"": tag_name,
                            ""title"": title,
                            ""body"": body,
                            ""meta"": metadata,
                            ""library"": tag_library,
                        }
                    )
        return super().get_context_data(**{**kwargs, ""tags"": tags})


class TemplateFilterIndexView(BaseAdminDocsView):
    template_name = ""admin_doc/template_filter_index.html""

    def get_context_data(self, **kwargs):
        filters = []
        try:
            engine = Engine.get_default()
        except ImproperlyConfigured:
            # Non-trivial TEMPLATES settings aren't supported (#24125).
            pass
        else:
            app_libs = sorted(engine.template_libraries.items())
            builtin_libs = [("""", lib) for lib in engine.template_builtins]
            for module_name, library in builtin_libs + app_libs:
                for filter_name, filter_func in library.filters.items():
                    title, body, metadata = utils.parse_docstring(filter_func.__doc__)
                    title = title and utils.parse_rst(
                        title, ""filter"", _(""filter:"") + filter_name
                    )
                    body = body and utils.parse_rst(
                        body, ""filter"", _(""filter:"") + filter_name
                    )
                    for key in metadata:
                        metadata[key] = utils.parse_rst(
                            metadata[key], ""filter"", _(""filter:"") + filter_name
                        )
                    tag_library = module_name.split(""."")[-1]
                    filters.append(
                        {
                            ""name"": filter_name,
                            ""title"": title,
                            ""body"": body,
                            ""meta"": metadata,
                            ""library"": tag_library,
                        }
                    )
        return super().get_context_data(**{**kwargs, ""filters"": filters})


class ViewIndexView(BaseAdminDocsView):
    template_name = ""admin_doc/view_index.html""

    def get_context_data(self, **kwargs):
        views = []
        url_resolver = get_resolver(get_urlconf())
        try:
            view_functions = extract_views_from_urlpatterns(url_resolver.url_patterns)
        except ImproperlyConfigured:
            view_functions = []
        for (func, regex, namespace, name) in view_functions:
            views.append(
                {
                    ""full_name"": get_view_name(func),
                    ""url"": simplify_regex(regex),
                    ""url_name"": "":"".join((namespace or []) + (name and [name] or [])),
                    ""namespace"": "":"".join(namespace or []),
                    ""name"": name,
                }
            )
        return super().get_context_data(**{**kwargs, ""views"": views})


class ViewDetailView(BaseAdminDocsView):
    template_name = ""admin_doc/view_detail.html""

    @staticmethod
    def _get_view_func(view):
        urlconf = get_urlconf()
        if get_resolver(urlconf)._is_callback(view):
            mod, func = get_mod_func(view)
            try:
                # Separate the module and function, e.g.
                # 'mymodule.views.myview' -> 'mymodule.views', 'myview').
                return getattr(import_module(mod), func)
            except ImportError:
                # Import may fail because view contains a class name, e.g.
                # 'mymodule.views.ViewContainer.my_view', so mod takes the form
                # 'mymodule.views.ViewContainer'. Parse it again to separate
                # the module and class.
                mod, klass = get_mod_func(mod)
                return getattr(getattr(import_module(mod), klass), func)

    def get_context_data(self, **kwargs):
        view = self.kwargs[""view""]
        view_func = self._get_view_func(view)
        if view_func is None:
            raise Http404
        title, body, metadata = utils.parse_docstring(view_func.__doc__)
        title = title and utils.parse_rst(title, ""view"", _(""view:"") + view)
        body = body and utils.parse_rst(body, ""view"", _(""view:"") + view)
        for key in metadata:
            metadata[key] = utils.parse_rst(metadata[key], ""model"", _(""view:"") + view)
        return super().get_context_data(
            **{
                **kwargs,
                ""name"": view,
                ""summary"": title,
                ""body"": body,
                ""meta"": metadata,
            }
        )


class ModelIndexView(BaseAdminDocsView):
    template_name = ""admin_doc/model_index.html""

    def get_context_data(self, **kwargs):
        m_list = [m._meta for m in apps.get_models()]
        return super().get_context_data(**{**kwargs, ""models"": m_list})


class ModelDetailView(BaseAdminDocsView):
    template_name = ""admin_doc/model_detail.html""

    def get_context_data(self, **kwargs):
        model_name = self.kwargs[""model_name""]
        # Get the model class.
        try:
            app_config = apps.get_app_config(self.kwargs[""app_label""])
        except LookupError:
            raise Http404(_(""App %(app_label)r not found"") % self.kwargs)
        try:
            model = app_config.get_model(model_name)
        except LookupError:
            raise Http404(
                _(""Model %(model_name)r not found in app %(app_label)r"") % self.kwargs
            )

        opts = model._meta

        title, body, metadata = utils.parse_docstring(model.__doc__)
        title = title and utils.parse_rst(title, ""model"", _(""model:"") + model_name)
        body = body and utils.parse_rst(body, ""model"", _(""model:"") + model_name)

        # Gather fields/field descriptions.
        fields = []
        for field in opts.fields:
            # ForeignKey is a special case since the field will actually be a
            # descriptor that returns the other object
            if isinstance(field, models.ForeignKey):
                data_type = field.remote_field.model.__name__
                app_label = field.remote_field.model._meta.app_label
                verbose = utils.parse_rst(
                    (
                        _(""the related `%(app_label)s.%(data_type)s` object"")
                        % {
                            ""app_label"": app_label,
                            ""data_type"": data_type,
                        }
                    ),
                    ""model"",
                    _(""model:"") + data_type,
                )
            else:
                data_type = get_readable_field_data_type(field)
                verbose = field.verbose_name
            fields.append(
                {
                    ""name"": field.name,
                    ""data_type"": data_type,
                    ""verbose"": verbose or """",
                    ""help_text"": field.help_text,
                }
            )

        # Gather many-to-many fields.
        for field in opts.many_to_many:
            data_type = field.remote_field.model.__name__
            app_label = field.remote_field.model._meta.app_label
            verbose = _(""related `%(app_label)s.%(object_name)s` objects"") % {
                ""app_label"": app_label,
                ""object_name"": data_type,
            }
            fields.append(
                {
                    ""name"": ""%s.all"" % field.name,
                    ""data_type"": ""List"",
                    ""verbose"": utils.parse_rst(
                        _(""all %s"") % verbose, ""model"", _(""model:"") + opts.model_name
                    ),
                }
            )
            fields.append(
                {
                    ""name"": ""%s.count"" % field.name,
                    ""data_type"": ""Integer"",
                    ""verbose"": utils.parse_rst(
                        _(""number of %s"") % verbose,
                        ""model"",
                        _(""model:"") + opts.model_name,
                    ),
                }
            )

        methods = []
        # Gather model methods.
        for func_name, func in model.__dict__.items():
            if inspect.isfunction(func) or isinstance(
                func, (cached_property, property)
            ):
                try:
                    for exclude in MODEL_METHODS_EXCLUDE:
                        if func_name.startswith(exclude):
                            raise StopIteration
                except StopIteration:
                    continue
                verbose = func.__doc__
                verbose = verbose and (
                    utils.parse_rst(
                        cleandoc(verbose), ""model"", _(""model:"") + opts.model_name
                    )
                )
                # Show properties, cached_properties, and methods without
                # arguments as fields. Otherwise, show as a 'method with
                # arguments'.
                if isinstance(func, (cached_property, property)):
                    fields.append(
                        {
                            ""name"": func_name,
                            ""data_type"": get_return_data_type(func_name),
                            ""verbose"": verbose or """",
                        }
                    )
                elif (
                    method_has_no_args(func)
                    and not func_accepts_kwargs(func)
                    and not func_accepts_var_args(func)
                ):
                    fields.append(
                        {
                            ""name"": func_name,
                            ""data_type"": get_return_data_type(func_name),
                            ""verbose"": verbose or """",
                        }
                    )
                else:
                    arguments = get_func_full_args(func)
                    # Join arguments with ', ' and in case of default value,
                    # join it with '='. Use repr() so that strings will be
                    # correctly displayed.
                    print_arguments = "", "".join(
                        [
                            ""="".join([arg_el[0], *map(repr, arg_el[1:])])
                            for arg_el in arguments
                        ]
                    )
                    methods.append(
                        {
                            ""name"": func_name,
                            ""arguments"": print_arguments,
                            ""verbose"": verbose or """",
                        }
                    )

        # Gather related objects
        for rel in opts.related_objects:
            verbose = _(""related `%(app_label)s.%(object_name)s` objects"") % {
                ""app_label"": rel.related_model._meta.app_label,
                ""object_name"": rel.related_model._meta.object_name,
            }
            accessor = rel.get_accessor_name()
            fields.append(
                {
                    ""name"": ""%s.all"" % accessor,
                    ""data_type"": ""List"",
                    ""verbose"": utils.parse_rst(
                        _(""all %s"") % verbose, ""model"", _(""model:"") + opts.model_name
                    ),
                }
            )
            fields.append(
                {
                    ""name"": ""%s.count"" % accessor,
                    ""data_type"": ""Integer"",
                    ""verbose"": utils.parse_rst(
                        _(""number of %s"") % verbose,
                        ""model"",
                        _(""model:"") + opts.model_name,
                    ),
                }
            )
        return super().get_context_data(
            **{
                **kwargs,
                ""name"": opts.label,
                ""summary"": title,
                ""description"": body,
                ""fields"": fields,
                ""methods"": methods,
            }
        )


class TemplateDetailView(BaseAdminDocsView):
    template_name = ""admin_doc/template_detail.html""

    def get_context_data(self, **kwargs):
        template = self.kwargs[""template""]
        templates = []
        try:
            default_engine = Engine.get_default()
        except ImproperlyConfigured:
            # Non-trivial TEMPLATES settings aren't supported (#24125).
            pass
        else:
            # This doesn't account for template loaders (#24128).
            for index, directory in enumerate(default_engine.dirs):
                template_file = Path(safe_join(directory, template))
                if template_file.exists():
                    template_contents = template_file.read_text()
                else:
                    template_contents = """"
                templates.append(
                    {
                        ""file"": template_file,
                        ""exists"": template_file.exists(),
                        ""contents"": template_contents,
                        ""order"": index,
                    }
                )
        return super().get_context_data(
            **{
                **kwargs,
                ""name"": template,
                ""templates"": templates,
            }
        )


####################
# Helper functions #
####################


def get_return_data_type(func_name):
    """"""Return a somewhat-helpful data type given a function name""""""
    if func_name.startswith(""get_""):
        if func_name.endswith(""_list""):
            return ""List""
        elif func_name.endswith(""_count""):
            return ""Integer""
    return """"


def get_readable_field_data_type(field):
    """"""
    Return the description for a given field type, if it exists. Fields'
    descriptions can contain format strings, which will be interpolated with
    the values of field.__dict__ before being output.
    """"""
    return field.description % field.__dict__


def extract_views_from_urlpatterns(urlpatterns, base="""", namespace=None):
    """"""
    Return a list of views from a list of urlpatterns.

    Each object in the returned list is a two-tuple: (view_func, regex)
    """"""
    views = []
    for p in urlpatterns:
        if hasattr(p, ""url_patterns""):
            try:
                patterns = p.url_patterns
            except ImportError:
                continue
            views.extend(
                extract_views_from_urlpatterns(
                    patterns,
                    base + str(p.pattern),
                    (namespace or []) + (p.namespace and [p.namespace] or []),
                )
            )
        elif hasattr(p, ""callback""):
            try:
                views.append((p.callback, base + str(p.pattern), namespace, p.name))
            except ViewDoesNotExist:
                continue
        else:
            raise TypeError(_(""%s does not appear to be a urlpattern object"") % p)
    return views


def simplify_regex(pattern):
    r""""""
    Clean up urlpattern regexes into something more readable by humans. For
    example, turn ""^(?P<sport_slug>\w+)/athletes/(?P<athlete_slug>\w+)/$""
    into ""/<sport_slug>/athletes/<athlete_slug>/"".
    """"""
    pattern = remove_non_capturing_groups(pattern)
    pattern = replace_named_groups(pattern)
    pattern = replace_unnamed_groups(pattern)
    pattern = replace_metacharacters(pattern)
    if not pattern.startswith(""/""):
        pattern = ""/"" + pattern
    return pattern<EOS>"
"<BOS>from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.http import HttpResponse
from django.utils.deprecation import MiddlewareMixin

from .utils import get_view_name


class XViewMiddleware(MiddlewareMixin):
    """"""
    Add an X-View header to internal HEAD requests.
    """"""

    def process_view(self, request, view_func, view_args, view_kwargs):
        """"""
        If the request method is HEAD and either the IP is internal or the
        user is a logged-in staff member, return a response with an x-view
        header indicating the view function. This is used to lookup the view
        function for an arbitrary page.
        """"""
        if not hasattr(request, ""user""):
            raise ImproperlyConfigured(
                ""The XView middleware requires authentication middleware to ""
                ""be installed. Edit your MIDDLEWARE setting to insert ""
                ""'django.contrib.auth.middleware.AuthenticationMiddleware'.""
            )
        if request.method == ""HEAD"" and (
            request.META.get(""REMOTE_ADDR"") in settings.INTERNAL_IPS
            or (request.user.is_active and request.user.is_staff)
        ):
            response = HttpResponse()
            response.headers[""X-View""] = get_view_name(view_func)
            return response<EOS>"
"<BOS>from django.contrib.admindocs import views
from django.urls import path, re_path

urlpatterns = [
    path(
        """",
        views.BaseAdminDocsView.as_view(template_name=""admin_doc/index.html""),
        name=""django-admindocs-docroot"",
    ),
    path(
        ""bookmarklets/"",
        views.BookmarkletsView.as_view(),
        name=""django-admindocs-bookmarklets"",
    ),
    path(
        ""tags/"",
        views.TemplateTagIndexView.as_view(),
        name=""django-admindocs-tags"",
    ),
    path(
        ""filters/"",
        views.TemplateFilterIndexView.as_view(),
        name=""django-admindocs-filters"",
    ),
    path(
        ""views/"",
        views.ViewIndexView.as_view(),
        name=""django-admindocs-views-index"",
    ),
    path(
        ""views/<view>/"",
        views.ViewDetailView.as_view(),
        name=""django-admindocs-views-detail"",
    ),
    path(
        ""models/"",
        views.ModelIndexView.as_view(),
        name=""django-admindocs-models-index"",
    ),
    re_path(
        r""^models/(?P<app_label>[^\.]+)\.(?P<model_name>[^/]+)/$"",
        views.ModelDetailView.as_view(),
        name=""django-admindocs-models-detail"",
    ),
    path(
        ""templates/<path:template>/"",
        views.TemplateDetailView.as_view(),
        name=""django-admindocs-templates"",
    ),
]<EOS>"
"<BOS>""Misc. utility functions/classes for admin documentation generator.""

import re
from email.errors import HeaderParseError
from email.parser import HeaderParser
from inspect import cleandoc

from django.urls import reverse
from django.utils.regex_helper import _lazy_re_compile
from django.utils.safestring import mark_safe

try:
    import docutils.core
    import docutils.nodes
    import docutils.parsers.rst.roles
except ImportError:
    docutils_is_available = False
else:
    docutils_is_available = True


def get_view_name(view_func):
    if hasattr(view_func, ""view_class""):
        klass = view_func.view_class
        return f""{klass.__module__}.{klass.__qualname__}""
    mod_name = view_func.__module__
    view_name = getattr(view_func, ""__qualname__"", view_func.__class__.__name__)
    return mod_name + ""."" + view_name


def parse_docstring(docstring):
    """"""
    Parse out the parts of a docstring.  Return (title, body, metadata).
    """"""
    if not docstring:
        return """", """", {}
    docstring = cleandoc(docstring)
    parts = re.split(r""\n{2,}"", docstring)
    title = parts[0]
    if len(parts) == 1:
        body = """"
        metadata = {}
    else:
        parser = HeaderParser()
        try:
            metadata = parser.parsestr(parts[-1])
        except HeaderParseError:
            metadata = {}
            body = ""\n\n"".join(parts[1:])
        else:
            metadata = dict(metadata.items())
            if metadata:
                body = ""\n\n"".join(parts[1:-1])
            else:
                body = ""\n\n"".join(parts[1:])
    return title, body, metadata


def parse_rst(text, default_reference_context, thing_being_parsed=None):
    """"""
    Convert the string from reST to an XHTML fragment.
    """"""
    overrides = {
        ""doctitle_xform"": True,
        ""initial_header_level"": 3,
        ""default_reference_context"": default_reference_context,
        ""link_base"": reverse(""django-admindocs-docroot"").rstrip(""/""),
        ""raw_enabled"": False,
        ""file_insertion_enabled"": False,
    }
    thing_being_parsed = thing_being_parsed and ""<%s>"" % thing_being_parsed
    # Wrap ``text`` in some reST that sets the default role to ``cmsreference``,
    # then restores it.
    source = """"""
.. default-role:: cmsreference

%s

.. default-role::
""""""
    parts = docutils.core.publish_parts(
        source % text,
        source_path=thing_being_parsed,
        destination_path=None,
        writer_name=""html"",
        settings_overrides=overrides,
    )
    return mark_safe(parts[""fragment""])


#
# reST roles
#
ROLES = {
    ""model"": ""%s/models/%s/"",
    ""view"": ""%s/views/%s/"",
    ""template"": ""%s/templates/%s/"",
    ""filter"": ""%s/filters/#%s"",
    ""tag"": ""%s/tags/#%s"",
}


def create_reference_role(rolename, urlbase):
    def _role(name, rawtext, text, lineno, inliner, options=None, content=None):
        if options is None:
            options = {}
        node = docutils.nodes.reference(
            rawtext,
            text,
            refuri=(
                urlbase
                % (
                    inliner.document.settings.link_base,
                    text.lower(),
                )
            ),
            **options,
        )
        return [node], []

    docutils.parsers.rst.roles.register_canonical_role(rolename, _role)


def default_reference_role(
    name, rawtext, text, lineno, inliner, options=None, content=None
):
    if options is None:
        options = {}
    context = inliner.document.settings.default_reference_context
    node = docutils.nodes.reference(
        rawtext,
        text,
        refuri=(
            ROLES[context]
            % (
                inliner.document.settings.link_base,
                text.lower(),
            )
        ),
        **options,
    )
    return [node], []


if docutils_is_available:
    docutils.parsers.rst.roles.register_canonical_role(
        ""cmsreference"", default_reference_role
    )

    for name, urlbase in ROLES.items():
        create_reference_role(name, urlbase)

# Match the beginning of a named, unnamed, or non-capturing groups.
named_group_matcher = _lazy_re_compile(r""\(\?P(<\w+>)"")
unnamed_group_matcher = _lazy_re_compile(r""\("")
non_capturing_group_matcher = _lazy_re_compile(r""\(\?\:"")


def replace_metacharacters(pattern):
    """"""Remove unescaped metacharacters from the pattern.""""""
    return re.sub(
        r""((?:^|(?<!\\))(?:\\\\)*)(\\?)([?*+^$]|\\[bBAZ])"",
        lambda m: m[1] + m[3] if m[2] else m[1],
        pattern,
    )


def _get_group_start_end(start, end, pattern):
    # Handle nested parentheses, e.g. '^(?P<a>(x|y))/b' or '^b/((x|y)\w+)$'.
    unmatched_open_brackets, prev_char = 1, None
    for idx, val in enumerate(pattern[end:]):
        # Check for unescaped `(` and `)`. They mark the start and end of a
        # nested group.
        if val == ""("" and prev_char != ""\\"":
            unmatched_open_brackets += 1
        elif val == "")"" and prev_char != ""\\"":
            unmatched_open_brackets -= 1
        prev_char = val
        # If brackets are balanced, the end of the string for the current named
        # capture group pattern has been reached.
        if unmatched_open_brackets == 0:
            return start, end + idx + 1


def _find_groups(pattern, group_matcher):
    prev_end = None
    for match in group_matcher.finditer(pattern):
        if indices := _get_group_start_end(match.start(0), match.end(0), pattern):
            start, end = indices
            if prev_end and start > prev_end or not prev_end:
                yield start, end, match
            prev_end = end


def replace_named_groups(pattern):
    r""""""
    Find named groups in `pattern` and replace them with the group name. E.g.,
    1. ^(?P<a>\w+)/b/(\w+)$ ==> ^<a>/b/(\w+)$
    2. ^(?P<a>\w+)/b/(?P<c>\w+)/$ ==> ^<a>/b/<c>/$
    3. ^(?P<a>\w+)/b/(\w+) ==> ^<a>/b/(\w+)
    4. ^(?P<a>\w+)/b/(?P<c>\w+) ==> ^<a>/b/<c>
    """"""
    group_pattern_and_name = [
        (pattern[start:end], match[1])
        for start, end, match in _find_groups(pattern, named_group_matcher)
    ]
    for group_pattern, group_name in group_pattern_and_name:
        pattern = pattern.replace(group_pattern, group_name)
    return pattern


def replace_unnamed_groups(pattern):
    r""""""
    Find unnamed groups in `pattern` and replace them with '<var>'. E.g.,
    1. ^(?P<a>\w+)/b/(\w+)$ ==> ^(?P<a>\w+)/b/<var>$
    2. ^(?P<a>\w+)/b/((x|y)\w+)$ ==> ^(?P<a>\w+)/b/<var>$
    3. ^(?P<a>\w+)/b/(\w+) ==> ^(?P<a>\w+)/b/<var>
    4. ^(?P<a>\w+)/b/((x|y)\w+) ==> ^(?P<a>\w+)/b/<var>
    """"""
    final_pattern, prev_end = """", None
    for start, end, _ in _find_groups(pattern, unnamed_group_matcher):
        if prev_end:
            final_pattern += pattern[prev_end:start]
        final_pattern += pattern[:start] + ""<var>""
        prev_end = end
    return final_pattern + pattern[prev_end:]


def remove_non_capturing_groups(pattern):
    r""""""
    Find non-capturing groups in the given `pattern` and remove them, e.g.
    1. (?P<a>\w+)/b/(?:\w+)c(?:\w+) => (?P<a>\\w+)/b/c
    2. ^(?:\w+(?:\w+))a => ^a
    3. ^a(?:\w+)/b(?:\w+) => ^a/b
    """"""
    group_start_end_indices = _find_groups(pattern, non_capturing_group_matcher)
    final_pattern, prev_end = """", None
    for start, end, _ in group_start_end_indices:
        final_pattern += pattern[prev_end:start]
        prev_end = end
    return final_pattern + pattern[prev_end:]<EOS>"
"<BOS>from django.apps import AppConfig
from django.utils.translation import gettext_lazy as _


class AdminDocsConfig(AppConfig):
    name = ""django.contrib.admindocs""
    verbose_name = _(""Administrative Documentation"")<EOS>"
"<BOS>import base64
import binascii
import functools
import hashlib
import importlib
import math
import warnings

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.core.signals import setting_changed
from django.dispatch import receiver
from django.utils.crypto import (
    RANDOM_STRING_CHARS,
    constant_time_compare,
    get_random_string,
    md5,
    pbkdf2,
)
from django.utils.module_loading import import_string
from django.utils.translation import gettext_noop as _

UNUSABLE_PASSWORD_PREFIX = ""!""  # This will never be a valid encoded hash
UNUSABLE_PASSWORD_SUFFIX_LENGTH = (
    40  # number of random chars to add after UNUSABLE_PASSWORD_PREFIX
)


def is_password_usable(encoded):
    """"""
    Return True if this password wasn't generated by
    User.set_unusable_password(), i.e. make_password(None).
    """"""
    return encoded is None or not encoded.startswith(UNUSABLE_PASSWORD_PREFIX)


def check_password(password, encoded, setter=None, preferred=""default""):
    """"""
    Return a boolean of whether the raw password matches the three
    part encoded digest.

    If setter is specified, it'll be called when you need to
    regenerate the password.
    """"""
    if password is None or not is_password_usable(encoded):
        return False

    preferred = get_hasher(preferred)
    try:
        hasher = identify_hasher(encoded)
    except ValueError:
        # encoded is gibberish or uses a hasher that's no longer installed.
        return False

    hasher_changed = hasher.algorithm != preferred.algorithm
    must_update = hasher_changed or preferred.must_update(encoded)
    is_correct = hasher.verify(password, encoded)

    # If the hasher didn't change (we don't protect against enumeration if it
    # does) and the password should get updated, try to close the timing gap
    # between the work factor of the current encoded password and the default
    # work factor.
    if not is_correct and not hasher_changed and must_update:
        hasher.harden_runtime(password, encoded)

    if setter and is_correct and must_update:
        setter(password)
    return is_correct


def make_password(password, salt=None, hasher=""default""):
    """"""
    Turn a plain-text password into a hash for database storage

    Same as encode() but generate a new random salt. If password is None then
    return a concatenation of UNUSABLE_PASSWORD_PREFIX and a random string,
    which disallows logins. Additional random string reduces chances of gaining
    access to staff or superuser accounts. See ticket #20079 for more info.
    """"""
    if password is None:
        return UNUSABLE_PASSWORD_PREFIX + get_random_string(
            UNUSABLE_PASSWORD_SUFFIX_LENGTH
        )
    if not isinstance(password, (bytes, str)):
        raise TypeError(
            ""Password must be a string or bytes, got %s."" % type(password).__qualname__
        )
    hasher = get_hasher(hasher)
    salt = salt or hasher.salt()
    return hasher.encode(password, salt)


@functools.lru_cache
def get_hashers():
    hashers = []
    for hasher_path in settings.PASSWORD_HASHERS:
        hasher_cls = import_string(hasher_path)
        hasher = hasher_cls()
        if not getattr(hasher, ""algorithm""):
            raise ImproperlyConfigured(
                ""hasher doesn't specify an algorithm name: %s"" % hasher_path
            )
        hashers.append(hasher)
    return hashers


@functools.lru_cache
def get_hashers_by_algorithm():
    return {hasher.algorithm: hasher for hasher in get_hashers()}


@receiver(setting_changed)
def reset_hashers(*, setting, **kwargs):
    if setting == ""PASSWORD_HASHERS"":
        get_hashers.cache_clear()
        get_hashers_by_algorithm.cache_clear()


def get_hasher(algorithm=""default""):
    """"""
    Return an instance of a loaded password hasher.

    If algorithm is 'default', return the default hasher. Lazily import hashers
    specified in the project's settings file if needed.
    """"""
    if hasattr(algorithm, ""algorithm""):
        return algorithm

    elif algorithm == ""default"":
        return get_hashers()[0]

    else:
        hashers = get_hashers_by_algorithm()
        try:
            return hashers[algorithm]
        except KeyError:
            raise ValueError(
                ""Unknown password hashing algorithm '%s'. ""
                ""Did you specify it in the PASSWORD_HASHERS ""
                ""setting?"" % algorithm
            )


def identify_hasher(encoded):
    """"""
    Return an instance of a loaded password hasher.

    Identify hasher algorithm by examining encoded hash, and call
    get_hasher() to return hasher. Raise ValueError if
    algorithm cannot be identified, or if hasher is not loaded.
    """"""
    # Ancient versions of Django created plain MD5 passwords and accepted
    # MD5 passwords with an empty salt.
    if (len(encoded) == 32 and ""$"" not in encoded) or (
        len(encoded) == 37 and encoded.startswith(""md5$$"")
    ):
        algorithm = ""unsalted_md5""
    # Ancient versions of Django accepted SHA1 passwords with an empty salt.
    elif len(encoded) == 46 and encoded.startswith(""sha1$$""):
        algorithm = ""unsalted_sha1""
    else:
        algorithm = encoded.split(""$"", 1)[0]
    return get_hasher(algorithm)


def mask_hash(hash, show=6, char=""*""):
    """"""
    Return the given hash, with only the first ``show`` number shown. The
    rest are masked with ``char`` for security reasons.
    """"""
    masked = hash[:show]
    masked += char * len(hash[show:])
    return masked


def must_update_salt(salt, expected_entropy):
    # Each character in the salt provides log_2(len(alphabet)) bits of entropy.
    return len(salt) * math.log2(len(RANDOM_STRING_CHARS)) < expected_entropy


class BasePasswordHasher:
    """"""
    Abstract base class for password hashers

    When creating your own hasher, you need to override algorithm,
    verify(), encode() and safe_summary().

    PasswordHasher objects are immutable.
    """"""

    algorithm = None
    library = None
    salt_entropy = 128

    def _load_library(self):
        if self.library is not None:
            if isinstance(self.library, (tuple, list)):
                name, mod_path = self.library
            else:
                mod_path = self.library
            try:
                module = importlib.import_module(mod_path)
            except ImportError as e:
                raise ValueError(
                    ""Couldn't load %r algorithm library: %s""
                    % (self.__class__.__name__, e)
                )
            return module
        raise ValueError(
            ""Hasher %r doesn't specify a library attribute"" % self.__class__.__name__
        )

    def salt(self):
        """"""
        Generate a cryptographically secure nonce salt in ASCII with an entropy
        of at least `salt_entropy` bits.
        """"""
        # Each character in the salt provides
        # log_2(len(alphabet)) bits of entropy.
        char_count = math.ceil(self.salt_entropy / math.log2(len(RANDOM_STRING_CHARS)))
        return get_random_string(char_count, allowed_chars=RANDOM_STRING_CHARS)

    def verify(self, password, encoded):
        """"""Check if the given password is correct.""""""
        raise NotImplementedError(
            ""subclasses of BasePasswordHasher must provide a verify() method""
        )

    def _check_encode_args(self, password, salt):
        if password is None:
            raise TypeError(""password must be provided."")
        if not salt or ""$"" in salt:
            raise ValueError(""salt must be provided and cannot contain $."")

    def encode(self, password, salt):
        """"""
        Create an encoded database value.

        The result is normally formatted as ""algorithm$salt$hash"" and
        must be fewer than 128 characters.
        """"""
        raise NotImplementedError(
            ""subclasses of BasePasswordHasher must provide an encode() method""
        )

    def decode(self, encoded):
        """"""
        Return a decoded database value.

        The result is a dictionary and should contain `algorithm`, `hash`, and
        `salt`. Extra keys can be algorithm specific like `iterations` or
        `work_factor`.
        """"""
        raise NotImplementedError(
            ""subclasses of BasePasswordHasher must provide a decode() method.""
        )

    def safe_summary(self, encoded):
        """"""
        Return a summary of safe values.

        The result is a dictionary and will be used where the password field
        must be displayed to construct a safe representation of the password.
        """"""
        raise NotImplementedError(
            ""subclasses of BasePasswordHasher must provide a safe_summary() method""
        )

    def must_update(self, encoded):
        return False

    def harden_runtime(self, password, encoded):
        """"""
        Bridge the runtime gap between the work factor supplied in `encoded`
        and the work factor suggested by this hasher.

        Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
        `self.iterations` is 30000, this method should run password through
        another 10000 iterations of PBKDF2. Similar approaches should exist
        for any hasher that has a work factor. If not, this method should be
        defined as a no-op to silence the warning.
        """"""
        warnings.warn(
            ""subclasses of BasePasswordHasher should provide a harden_runtime() method""
        )


class PBKDF2PasswordHasher(BasePasswordHasher):
    """"""
    Secure password hashing using the PBKDF2 algorithm (recommended)

    Configured to use PBKDF2 + HMAC + SHA256.
    The result is a 64 byte binary string.  Iterations may be changed
    safely but you must rename the algorithm if you change SHA256.
    """"""

    algorithm = ""pbkdf2_sha256""
    iterations = 390000
    digest = hashlib.sha256

    def encode(self, password, salt, iterations=None):
        self._check_encode_args(password, salt)
        iterations = iterations or self.iterations
        hash = pbkdf2(password, salt, iterations, digest=self.digest)
        hash = base64.b64encode(hash).decode(""ascii"").strip()
        return ""%s$%d$%s$%s"" % (self.algorithm, iterations, salt, hash)

    def decode(self, encoded):
        algorithm, iterations, salt, hash = encoded.split(""$"", 3)
        assert algorithm == self.algorithm
        return {
            ""algorithm"": algorithm,
            ""hash"": hash,
            ""iterations"": int(iterations),
            ""salt"": salt,
        }

    def verify(self, password, encoded):
        decoded = self.decode(encoded)
        encoded_2 = self.encode(password, decoded[""salt""], decoded[""iterations""])
        return constant_time_compare(encoded, encoded_2)

    def safe_summary(self, encoded):
        decoded = self.decode(encoded)
        return {
            _(""algorithm""): decoded[""algorithm""],
            _(""iterations""): decoded[""iterations""],
            _(""salt""): mask_hash(decoded[""salt""]),
            _(""hash""): mask_hash(decoded[""hash""]),
        }

    def must_update(self, encoded):
        decoded = self.decode(encoded)
        update_salt = must_update_salt(decoded[""salt""], self.salt_entropy)
        return (decoded[""iterations""] != self.iterations) or update_salt

    def harden_runtime(self, password, encoded):
        decoded = self.decode(encoded)
        extra_iterations = self.iterations - decoded[""iterations""]
        if extra_iterations > 0:
            self.encode(password, decoded[""salt""], extra_iterations)


class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):
    """"""
    Alternate PBKDF2 hasher which uses SHA1, the default PRF
    recommended by PKCS #5. This is compatible with other
    implementations of PBKDF2, such as openssl's
    PKCS5_PBKDF2_HMAC_SHA1().
    """"""

    algorithm = ""pbkdf2_sha1""
    digest = hashlib.sha1


class Argon2PasswordHasher(BasePasswordHasher):
    """"""
    Secure password hashing using the argon2 algorithm.

    This is the winner of the Password Hashing Competition 2013-2015
    (https://password-hashing.net). It requires the argon2-cffi library which
    depends on native C code and might cause portability issues.
    """"""

    algorithm = ""argon2""
    library = ""argon2""

    time_cost = 2
    memory_cost = 102400
    parallelism = 8

    def encode(self, password, salt):
        argon2 = self._load_library()
        params = self.params()
        data = argon2.low_level.hash_secret(
            password.encode(),
            salt.encode(),
            time_cost=params.time_cost,
            memory_cost=params.memory_cost,
            parallelism=params.parallelism,
            hash_len=params.hash_len,
            type=params.type,
        )
        return self.algorithm + data.decode(""ascii"")

    def decode(self, encoded):
        argon2 = self._load_library()
        algorithm, rest = encoded.split(""$"", 1)
        assert algorithm == self.algorithm
        params = argon2.extract_parameters(""$"" + rest)
        variety, *_, b64salt, hash = rest.split(""$"")
        # Add padding.
        b64salt += ""="" * (-len(b64salt) % 4)
        salt = base64.b64decode(b64salt).decode(""latin1"")
        return {
            ""algorithm"": algorithm,
            ""hash"": hash,
            ""memory_cost"": params.memory_cost,
            ""parallelism"": params.parallelism,
            ""salt"": salt,
            ""time_cost"": params.time_cost,
            ""variety"": variety,
            ""version"": params.version,
            ""params"": params,
        }

    def verify(self, password, encoded):
        argon2 = self._load_library()
        algorithm, rest = encoded.split(""$"", 1)
        assert algorithm == self.algorithm
        try:
            return argon2.PasswordHasher().verify(""$"" + rest, password)
        except argon2.exceptions.VerificationError:
            return False

    def safe_summary(self, encoded):
        decoded = self.decode(encoded)
        return {
            _(""algorithm""): decoded[""algorithm""],
            _(""variety""): decoded[""variety""],
            _(""version""): decoded[""version""],
            _(""memory cost""): decoded[""memory_cost""],
            _(""time cost""): decoded[""time_cost""],
            _(""parallelism""): decoded[""parallelism""],
            _(""salt""): mask_hash(decoded[""salt""]),
            _(""hash""): mask_hash(decoded[""hash""]),
        }

    def must_update(self, encoded):
        decoded = self.decode(encoded)
        current_params = decoded[""params""]
        new_params = self.params()
        # Set salt_len to the salt_len of the current parameters because salt
        # is explicitly passed to argon2.
        new_params.salt_len = current_params.salt_len
        update_salt = must_update_salt(decoded[""salt""], self.salt_entropy)
        return (current_params != new_params) or update_salt

    def harden_runtime(self, password, encoded):
        # The runtime for Argon2 is too complicated to implement a sensible
        # hardening algorithm.
        pass

    def params(self):
        argon2 = self._load_library()
        # salt_len is a noop, because we provide our own salt.
        return argon2.Parameters(
            type=argon2.low_level.Type.ID,
            version=argon2.low_level.ARGON2_VERSION,
            salt_len=argon2.DEFAULT_RANDOM_SALT_LENGTH,
            hash_len=argon2.DEFAULT_HASH_LENGTH,
            time_cost=self.time_cost,
            memory_cost=self.memory_cost,
            parallelism=self.parallelism,
        )


class BCryptSHA256PasswordHasher(BasePasswordHasher):
    """"""
    Secure password hashing using the bcrypt algorithm (recommended)

    This is considered by many to be the most secure algorithm but you
    must first install the bcrypt library.  Please be warned that
    this library depends on native C code and might cause portability
    issues.
    """"""

    algorithm = ""bcrypt_sha256""
    digest = hashlib.sha256
    library = (""bcrypt"", ""bcrypt"")
    rounds = 12

    def salt(self):
        bcrypt = self._load_library()
        return bcrypt.gensalt(self.rounds)

    def encode(self, password, salt):
        bcrypt = self._load_library()
        password = password.encode()
        # Hash the password prior to using bcrypt to prevent password
        # truncation as described in #20138.
        if self.digest is not None:
            # Use binascii.hexlify() because a hex encoded bytestring is str.
            password = binascii.hexlify(self.digest(password).digest())

        data = bcrypt.hashpw(password, salt)
        return ""%s$%s"" % (self.algorithm, data.decode(""ascii""))

    def decode(self, encoded):
        algorithm, empty, algostr, work_factor, data = encoded.split(""$"", 4)
        assert algorithm == self.algorithm
        return {
            ""algorithm"": algorithm,
            ""algostr"": algostr,
            ""checksum"": data[22:],
            ""salt"": data[:22],
            ""work_factor"": int(work_factor),
        }

    def verify(self, password, encoded):
        algorithm, data = encoded.split(""$"", 1)
        assert algorithm == self.algorithm
        encoded_2 = self.encode(password, data.encode(""ascii""))
        return constant_time_compare(encoded, encoded_2)

    def safe_summary(self, encoded):
        decoded = self.decode(encoded)
        return {
            _(""algorithm""): decoded[""algorithm""],
            _(""work factor""): decoded[""work_factor""],
            _(""salt""): mask_hash(decoded[""salt""]),
            _(""checksum""): mask_hash(decoded[""checksum""]),
        }

    def must_update(self, encoded):
        decoded = self.decode(encoded)
        return decoded[""work_factor""] != self.rounds

    def harden_runtime(self, password, encoded):
        _, data = encoded.split(""$"", 1)
        salt = data[:29]  # Length of the salt in bcrypt.
        rounds = data.split(""$"")[2]
        # work factor is logarithmic, adding one doubles the load.
        diff = 2 ** (self.rounds - int(rounds)) - 1
        while diff > 0:
            self.encode(password, salt.encode(""ascii""))
            diff -= 1


class BCryptPasswordHasher(BCryptSHA256PasswordHasher):
    """"""
    Secure password hashing using the bcrypt algorithm

    This is considered by many to be the most secure algorithm but you
    must first install the bcrypt library.  Please be warned that
    this library depends on native C code and might cause portability
    issues.

    This hasher does not first hash the password which means it is subject to
    bcrypt's 72 bytes password truncation. Most use cases should prefer the
    BCryptSHA256PasswordHasher.
    """"""

    algorithm = ""bcrypt""
    digest = None


class ScryptPasswordHasher(BasePasswordHasher):
    """"""
    Secure password hashing using the Scrypt algorithm.
    """"""

    algorithm = ""scrypt""
    block_size = 8
    maxmem = 0
    parallelism = 1
    work_factor = 2**14

    def encode(self, password, salt, n=None, r=None, p=None):
        self._check_encode_args(password, salt)
        n = n or self.work_factor
        r = r or self.block_size
        p = p or self.parallelism
        hash_ = hashlib.scrypt(
            password.encode(),
            salt=salt.encode(),
            n=n,
            r=r,
            p=p,
            maxmem=self.maxmem,
            dklen=64,
        )
        hash_ = base64.b64encode(hash_).decode(""ascii"").strip()
        return ""%s$%d$%s$%d$%d$%s"" % (self.algorithm, n, salt, r, p, hash_)

    def decode(self, encoded):
        algorithm, work_factor, salt, block_size, parallelism, hash_ = encoded.split(
            ""$"", 6
        )
        assert algorithm == self.algorithm
        return {
            ""algorithm"": algorithm,
            ""work_factor"": int(work_factor),
            ""salt"": salt,
            ""block_size"": int(block_size),
            ""parallelism"": int(parallelism),
            ""hash"": hash_,
        }

    def verify(self, password, encoded):
        decoded = self.decode(encoded)
        encoded_2 = self.encode(
            password,
            decoded[""salt""],
            decoded[""work_factor""],
            decoded[""block_size""],
            decoded[""parallelism""],
        )
        return constant_time_compare(encoded, encoded_2)

    def safe_summary(self, encoded):
        decoded = self.decode(encoded)
        return {
            _(""algorithm""): decoded[""algorithm""],
            _(""work factor""): decoded[""work_factor""],
            _(""block size""): decoded[""block_size""],
            _(""parallelism""): decoded[""parallelism""],
            _(""salt""): mask_hash(decoded[""salt""]),
            _(""hash""): mask_hash(decoded[""hash""]),
        }

    def must_update(self, encoded):
        decoded = self.decode(encoded)
        return (
            decoded[""work_factor""] != self.work_factor
            or decoded[""block_size""] != self.block_size
            or decoded[""parallelism""] != self.parallelism
        )

    def harden_runtime(self, password, encoded):
        # The runtime for Scrypt is too complicated to implement a sensible
        # hardening algorithm.
        pass


class SHA1PasswordHasher(BasePasswordHasher):
    """"""
    The SHA1 password hashing algorithm (not recommended)
    """"""

    algorithm = ""sha1""

    def encode(self, password, salt):
        self._check_encode_args(password, salt)
        hash = hashlib.sha1((salt + password).encode()).hexdigest()
        return ""%s$%s$%s"" % (self.algorithm, salt, hash)

    def decode(self, encoded):
        algorithm, salt, hash = encoded.split(""$"", 2)
        assert algorithm == self.algorithm
        return {
            ""algorithm"": algorithm,
            ""hash"": hash,
            ""salt"": salt,
        }

    def verify(self, password, encoded):
        decoded = self.decode(encoded)
        encoded_2 = self.encode(password, decoded[""salt""])
        return constant_time_compare(encoded, encoded_2)

    def safe_summary(self, encoded):
        decoded = self.decode(encoded)
        return {
            _(""algorithm""): decoded[""algorithm""],
            _(""salt""): mask_hash(decoded[""salt""], show=2),
            _(""hash""): mask_hash(decoded[""hash""]),
        }

    def must_update(self, encoded):
        decoded = self.decode(encoded)
        return must_update_salt(decoded[""salt""], self.salt_entropy)

    def harden_runtime(self, password, encoded):
        pass


class MD5PasswordHasher(BasePasswordHasher):
    """"""
    The Salted MD5 password hashing algorithm (not recommended)
    """"""

    algorithm = ""md5""

    def encode(self, password, salt):
        self._check_encode_args(password, salt)
        hash = md5((salt + password).encode()).hexdigest()
        return ""%s$%s$%s"" % (self.algorithm, salt, hash)

    def decode(self, encoded):
        algorithm, salt, hash = encoded.split(""$"", 2)
        assert algorithm == self.algorithm
        return {
            ""algorithm"": algorithm,
            ""hash"": hash,
            ""salt"": salt,
        }

    def verify(self, password, encoded):
        decoded = self.decode(encoded)
        encoded_2 = self.encode(password, decoded[""salt""])
        return constant_time_compare(encoded, encoded_2)

    def safe_summary(self, encoded):
        decoded = self.decode(encoded)
        return {
            _(""algorithm""): decoded[""algorithm""],
            _(""salt""): mask_hash(decoded[""salt""], show=2),
            _(""hash""): mask_hash(decoded[""hash""]),
        }

    def must_update(self, encoded):
        decoded = self.decode(encoded)
        return must_update_salt(decoded[""salt""], self.salt_entropy)

    def harden_runtime(self, password, encoded):
        pass


class UnsaltedSHA1PasswordHasher(BasePasswordHasher):
    """"""
    Very insecure algorithm that you should *never* use; store SHA1 hashes
    with an empty salt.

    This class is implemented because Django used to accept such password
    hashes. Some older Django installs still have these values lingering
    around so we need to handle and upgrade them properly.
    """"""

    algorithm = ""unsalted_sha1""

    def salt(self):
        return """"

    def encode(self, password, salt):
        if salt != """":
            raise ValueError(""salt must be empty."")
        hash = hashlib.sha1(password.encode()).hexdigest()
        return ""sha1$$%s"" % hash

    def decode(self, encoded):
        assert encoded.startswith(""sha1$$"")
        return {
            ""algorithm"": self.algorithm,
            ""hash"": encoded[6:],
            ""salt"": None,
        }

    def verify(self, password, encoded):
        encoded_2 = self.encode(password, """")
        return constant_time_compare(encoded, encoded_2)

    def safe_summary(self, encoded):
        decoded = self.decode(encoded)
        return {
            _(""algorithm""): decoded[""algorithm""],
            _(""hash""): mask_hash(decoded[""hash""]),
        }

    def harden_runtime(self, password, encoded):
        pass


class UnsaltedMD5PasswordHasher(BasePasswordHasher):
    """"""
    Incredibly insecure algorithm that you should *never* use; stores unsalted
    MD5 hashes without the algorithm prefix, also accepts MD5 hashes with an
    empty salt.

    This class is implemented because Django used to store passwords this way
    and to accept such password hashes. Some older Django installs still have
    these values lingering around so we need to handle and upgrade them
    properly.
    """"""

    algorithm = ""unsalted_md5""

    def salt(self):
        return """"

    def encode(self, password, salt):
        if salt != """":
            raise ValueError(""salt must be empty."")
        return md5(password.encode()).hexdigest()

    def decode(self, encoded):
        return {
            ""algorithm"": self.algorithm,
            ""hash"": encoded,
            ""salt"": None,
        }

    def verify(self, password, encoded):
        if len(encoded) == 37 and encoded.startswith(""md5$$""):
            encoded = encoded[5:]
        encoded_2 = self.encode(password, """")
        return constant_time_compare(encoded, encoded_2)

    def safe_summary(self, encoded):
        decoded = self.decode(encoded)
        return {
            _(""algorithm""): decoded[""algorithm""],
            _(""hash""): mask_hash(decoded[""hash""], show=3),
        }

    def harden_runtime(self, password, encoded):
        pass


class CryptPasswordHasher(BasePasswordHasher):
    """"""
    Password hashing using UNIX crypt (not recommended)

    The crypt module is not supported on all platforms.
    """"""

    algorithm = ""crypt""
    library = ""crypt""

    def salt(self):
        return get_random_string(2)

    def encode(self, password, salt):
        crypt = self._load_library()
        if len(salt) != 2:
            raise ValueError(""salt must be of length 2."")
        hash = crypt.crypt(password, salt)
        if hash is None:  # A platform like OpenBSD with a dummy crypt module.
            raise TypeError(""hash must be provided."")
        # we don't need to store the salt, but Django used to do this
        return ""%s$%s$%s"" % (self.algorithm, """", hash)

    def decode(self, encoded):
        algorithm, salt, hash = encoded.split(""$"", 2)
        assert algorithm == self.algorithm
        return {
            ""algorithm"": algorithm,
            ""hash"": hash,
            ""salt"": salt,
        }

    def verify(self, password, encoded):
        crypt = self._load_library()
        decoded = self.decode(encoded)
        data = crypt.crypt(password, decoded[""hash""])
        return constant_time_compare(decoded[""hash""], data)

    def safe_summary(self, encoded):
        decoded = self.decode(encoded)
        return {
            _(""algorithm""): decoded[""algorithm""],
            _(""salt""): decoded[""salt""],
            _(""hash""): mask_hash(decoded[""hash""], show=3),
        }

    def harden_runtime(self, password, encoded):
        pass<EOS>"
"<BOS>""""""
This module allows importing AbstractBaseUser even when django.contrib.auth is
not in INSTALLED_APPS.
""""""
import unicodedata

from django.contrib.auth import password_validation
from django.contrib.auth.hashers import (
    check_password,
    is_password_usable,
    make_password,
)
from django.db import models
from django.utils.crypto import get_random_string, salted_hmac
from django.utils.translation import gettext_lazy as _


class BaseUserManager(models.Manager):
    @classmethod
    def normalize_email(cls, email):
        """"""
        Normalize the email address by lowercasing the domain part of it.
        """"""
        email = email or """"
        try:
            email_name, domain_part = email.strip().rsplit(""@"", 1)
        except ValueError:
            pass
        else:
            email = email_name + ""@"" + domain_part.lower()
        return email

    def make_random_password(
        self,
        length=10,
        allowed_chars=""abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789"",
    ):
        """"""
        Generate a random password with the given length and given
        allowed_chars. The default value of allowed_chars does not have ""I"" or
        ""O"" or letters and digits that look similar -- just to avoid confusion.
        """"""
        return get_random_string(length, allowed_chars)

    def get_by_natural_key(self, username):
        return self.get(**{self.model.USERNAME_FIELD: username})


class AbstractBaseUser(models.Model):
    password = models.CharField(_(""password""), max_length=128)
    last_login = models.DateTimeField(_(""last login""), blank=True, null=True)

    is_active = True

    REQUIRED_FIELDS = []

    # Stores the raw password if set_password() is called so that it can
    # be passed to password_changed() after the model is saved.
    _password = None

    class Meta:
        abstract = True

    def __str__(self):
        return self.get_username()

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        if self._password is not None:
            password_validation.password_changed(self._password, self)
            self._password = None

    def get_username(self):
        """"""Return the username for this User.""""""
        return getattr(self, self.USERNAME_FIELD)

    def clean(self):
        setattr(self, self.USERNAME_FIELD, self.normalize_username(self.get_username()))

    def natural_key(self):
        return (self.get_username(),)

    @property
    def is_anonymous(self):
        """"""
        Always return False. This is a way of comparing User objects to
        anonymous users.
        """"""
        return False

    @property
    def is_authenticated(self):
        """"""
        Always return True. This is a way to tell if the user has been
        authenticated in templates.
        """"""
        return True

    def set_password(self, raw_password):
        self.password = make_password(raw_password)
        self._password = raw_password

    def check_password(self, raw_password):
        """"""
        Return a boolean of whether the raw_password was correct. Handles
        hashing formats behind the scenes.
        """"""

        def setter(raw_password):
            self.set_password(raw_password)
            # Password hash upgrades shouldn't be considered password changes.
            self._password = None
            self.save(update_fields=[""password""])

        return check_password(raw_password, self.password, setter)

    def set_unusable_password(self):
        # Set a value that will never be a valid hash
        self.password = make_password(None)

    def has_usable_password(self):
        """"""
        Return False if set_unusable_password() has been called for this user.
        """"""
        return is_password_usable(self.password)

    def get_session_auth_hash(self):
        """"""
        Return an HMAC of the password field.
        """"""
        key_salt = ""django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash""
        return salted_hmac(
            key_salt,
            self.password,
            algorithm=""sha256"",
        ).hexdigest()

    @classmethod
    def get_email_field_name(cls):
        try:
            return cls.EMAIL_FIELD
        except AttributeError:
            return ""email""

    @classmethod
    def normalize_username(cls, username):
        return (
            unicodedata.normalize(""NFKC"", username)
            if isinstance(username, str)
            else username
        )<EOS>"
"<BOS># PermWrapper and PermLookupDict proxy the permissions system into objects that
# the template system can understand.


class PermLookupDict:
    def __init__(self, user, app_label):
        self.user, self.app_label = user, app_label

    def __repr__(self):
        return str(self.user.get_all_permissions())

    def __getitem__(self, perm_name):
        return self.user.has_perm(""%s.%s"" % (self.app_label, perm_name))

    def __iter__(self):
        # To fix 'item in perms.someapp' and __getitem__ interaction we need to
        # define __iter__. See #18979 for details.
        raise TypeError(""PermLookupDict is not iterable."")

    def __bool__(self):
        return self.user.has_module_perms(self.app_label)


class PermWrapper:
    def __init__(self, user):
        self.user = user

    def __repr__(self):
        return f""{self.__class__.__qualname__}({self.user!r})""

    def __getitem__(self, app_label):
        return PermLookupDict(self.user, app_label)

    def __iter__(self):
        # I am large, I contain multitudes.
        raise TypeError(""PermWrapper is not iterable."")

    def __contains__(self, perm_name):
        """"""
        Lookup by ""someapp"" or ""someapp.someperm"" in perms.
        """"""
        if ""."" not in perm_name:
            # The name refers to module.
            return bool(self[perm_name])
        app_label, perm_name = perm_name.split(""."", 1)
        return self[app_label][perm_name]


def auth(request):
    """"""
    Return context variables required by apps that use Django's authentication
    system.

    If there is no 'user' attribute in the request, use AnonymousUser (from
    django.contrib.auth).
    """"""
    if hasattr(request, ""user""):
        user = request.user
    else:
        from django.contrib.auth.models import AnonymousUser

        user = AnonymousUser()

    return {
        ""user"": user,
        ""perms"": PermWrapper(user),
    }<EOS>"
"<BOS>import inspect
import re

from django.apps import apps as django_apps
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured, PermissionDenied
from django.middleware.csrf import rotate_token
from django.utils.crypto import constant_time_compare
from django.utils.module_loading import import_string
from django.views.decorators.debug import sensitive_variables

from .signals import user_logged_in, user_logged_out, user_login_failed

SESSION_KEY = ""_auth_user_id""
BACKEND_SESSION_KEY = ""_auth_user_backend""
HASH_SESSION_KEY = ""_auth_user_hash""
REDIRECT_FIELD_NAME = ""next""


def load_backend(path):
    return import_string(path)()


def _get_backends(return_tuples=False):
    backends = []
    for backend_path in settings.AUTHENTICATION_BACKENDS:
        backend = load_backend(backend_path)
        backends.append((backend, backend_path) if return_tuples else backend)
    if not backends:
        raise ImproperlyConfigured(
            ""No authentication backends have been defined. Does ""
            ""AUTHENTICATION_BACKENDS contain anything?""
        )
    return backends


def get_backends():
    return _get_backends(return_tuples=False)


@sensitive_variables(""credentials"")
def _clean_credentials(credentials):
    """"""
    Clean a dictionary of credentials of potentially sensitive info before
    sending to less secure functions.

    Not comprehensive - intended for user_login_failed signal
    """"""
    SENSITIVE_CREDENTIALS = re.compile(""api|token|key|secret|password|signature"", re.I)
    CLEANSED_SUBSTITUTE = ""********************""
    for key in credentials:
        if SENSITIVE_CREDENTIALS.search(key):
            credentials[key] = CLEANSED_SUBSTITUTE
    return credentials


def _get_user_session_key(request):
    # This value in the session is always serialized to a string, so we need
    # to convert it back to Python whenever we access it.
    return get_user_model()._meta.pk.to_python(request.session[SESSION_KEY])


@sensitive_variables(""credentials"")
def authenticate(request=None, **credentials):
    """"""
    If the given credentials are valid, return a User object.
    """"""
    for backend, backend_path in _get_backends(return_tuples=True):
        backend_signature = inspect.signature(backend.authenticate)
        try:
            backend_signature.bind(request, **credentials)
        except TypeError:
            # This backend doesn't accept these credentials as arguments. Try
            # the next one.
            continue
        try:
            user = backend.authenticate(request, **credentials)
        except PermissionDenied:
            # This backend says to stop in our tracks - this user should not be
            # allowed in at all.
            break
        if user is None:
            continue
        # Annotate the user object with the path of the backend.
        user.backend = backend_path
        return user

    # The credentials supplied are invalid to all backends, fire signal
    user_login_failed.send(
        sender=__name__, credentials=_clean_credentials(credentials), request=request
    )


def login(request, user, backend=None):
    """"""
    Persist a user id and a backend in the request. This way a user doesn't
    have to reauthenticate on every request. Note that data set during
    the anonymous session is retained when the user logs in.
    """"""
    session_auth_hash = """"
    if user is None:
        user = request.user
    if hasattr(user, ""get_session_auth_hash""):
        session_auth_hash = user.get_session_auth_hash()

    if SESSION_KEY in request.session:
        if _get_user_session_key(request) != user.pk or (
            session_auth_hash
            and not constant_time_compare(
                request.session.get(HASH_SESSION_KEY, """"), session_auth_hash
            )
        ):
            # To avoid reusing another user's session, create a new, empty
            # session if the existing session corresponds to a different
            # authenticated user.
            request.session.flush()
    else:
        request.session.cycle_key()

    try:
        backend = backend or user.backend
    except AttributeError:
        backends = _get_backends(return_tuples=True)
        if len(backends) == 1:
            _, backend = backends[0]
        else:
            raise ValueError(
                ""You have multiple authentication backends configured and ""
                ""therefore must provide the `backend` argument or set the ""
                ""`backend` attribute on the user.""
            )
    else:
        if not isinstance(backend, str):
            raise TypeError(
                ""backend must be a dotted import path string (got %r)."" % backend
            )

    request.session[SESSION_KEY] = user._meta.pk.value_to_string(user)
    request.session[BACKEND_SESSION_KEY] = backend
    request.session[HASH_SESSION_KEY] = session_auth_hash
    if hasattr(request, ""user""):
        request.user = user
    rotate_token(request)
    user_logged_in.send(sender=user.__class__, request=request, user=user)


def logout(request):
    """"""
    Remove the authenticated user's ID from the request and flush their session
    data.
    """"""
    # Dispatch the signal before the user is logged out so the receivers have a
    # chance to find out *who* logged out.
    user = getattr(request, ""user"", None)
    if not getattr(user, ""is_authenticated"", True):
        user = None
    user_logged_out.send(sender=user.__class__, request=request, user=user)
    request.session.flush()
    if hasattr(request, ""user""):
        from django.contrib.auth.models import AnonymousUser

        request.user = AnonymousUser()


def get_user_model():
    """"""
    Return the User model that is active in this project.
    """"""
    try:
        return django_apps.get_model(settings.AUTH_USER_MODEL, require_ready=False)
    except ValueError:
        raise ImproperlyConfigured(
            ""AUTH_USER_MODEL must be of the form 'app_label.model_name'""
        )
    except LookupError:
        raise ImproperlyConfigured(
            ""AUTH_USER_MODEL refers to model '%s' that has not been installed""
            % settings.AUTH_USER_MODEL
        )


def get_user(request):
    """"""
    Return the user model instance associated with the given request session.
    If no user is retrieved, return an instance of `AnonymousUser`.
    """"""
    from .models import AnonymousUser

    user = None
    try:
        user_id = _get_user_session_key(request)
        backend_path = request.session[BACKEND_SESSION_KEY]
    except KeyError:
        pass
    else:
        if backend_path in settings.AUTHENTICATION_BACKENDS:
            backend = load_backend(backend_path)
            user = backend.get_user(user_id)
            # Verify the session
            if hasattr(user, ""get_session_auth_hash""):
                session_hash = request.session.get(HASH_SESSION_KEY)
                session_hash_verified = session_hash and constant_time_compare(
                    session_hash, user.get_session_auth_hash()
                )
                if not session_hash_verified:
                    request.session.flush()
                    user = None

    return user or AnonymousUser()


def get_permission_codename(action, opts):
    """"""
    Return the codename of the permission for the specified action.
    """"""
    return ""%s_%s"" % (action, opts.model_name)


def update_session_auth_hash(request, user):
    """"""
    Updating a user's password logs out all sessions for the user.

    Take the current request and the updated user object from which the new
    session hash will be derived and update the session hash appropriately to
    prevent a password change from logging out the session from which the
    password was changed.
    """"""
    request.session.cycle_key()
    if hasattr(user, ""get_session_auth_hash"") and request.user == user:
        request.session[HASH_SESSION_KEY] = user.get_session_auth_hash()<EOS>"
"<BOS>from django.apps import AppConfig
from django.core import checks
from django.db.models.query_utils import DeferredAttribute
from django.db.models.signals import post_migrate
from django.utils.translation import gettext_lazy as _

from . import get_user_model
from .checks import check_models_permissions, check_user_model
from .management import create_permissions
from .signals import user_logged_in


class AuthConfig(AppConfig):
    default_auto_field = ""django.db.models.AutoField""
    name = ""django.contrib.auth""
    verbose_name = _(""Authentication and Authorization"")

    def ready(self):
        post_migrate.connect(
            create_permissions,
            dispatch_uid=""django.contrib.auth.management.create_permissions"",
        )
        last_login_field = getattr(get_user_model(), ""last_login"", None)
        # Register the handler only if UserModel.last_login is a field.
        if isinstance(last_login_field, DeferredAttribute):
            from .models import update_last_login

            user_logged_in.connect(update_last_login, dispatch_uid=""update_last_login"")
        checks.register(check_user_model, checks.Tags.models)
        checks.register(check_models_permissions, checks.Tags.models)<EOS>"
"<BOS>from itertools import chain
from types import MethodType

from django.apps import apps
from django.conf import settings
from django.core import checks

from .management import _get_builtin_permissions


def check_user_model(app_configs=None, **kwargs):
    if app_configs is None:
        cls = apps.get_model(settings.AUTH_USER_MODEL)
    else:
        app_label, model_name = settings.AUTH_USER_MODEL.split(""."")
        for app_config in app_configs:
            if app_config.label == app_label:
                cls = app_config.get_model(model_name)
                break
        else:
            # Checks might be run against a set of app configs that don't
            # include the specified user model. In this case we simply don't
            # perform the checks defined below.
            return []

    errors = []

    # Check that REQUIRED_FIELDS is a list
    if not isinstance(cls.REQUIRED_FIELDS, (list, tuple)):
        errors.append(
            checks.Error(
                ""'REQUIRED_FIELDS' must be a list or tuple."",
                obj=cls,
                id=""auth.E001"",
            )
        )

    # Check that the USERNAME FIELD isn't included in REQUIRED_FIELDS.
    if cls.USERNAME_FIELD in cls.REQUIRED_FIELDS:
        errors.append(
            checks.Error(
                ""The field named as the 'USERNAME_FIELD' ""
                ""for a custom user model must not be included in 'REQUIRED_FIELDS'."",
                hint=(
                    ""The 'USERNAME_FIELD' is currently set to '%s', you ""
                    ""should remove '%s' from the 'REQUIRED_FIELDS'.""
                    % (cls.USERNAME_FIELD, cls.USERNAME_FIELD)
                ),
                obj=cls,
                id=""auth.E002"",
            )
        )

    # Check that the username field is unique
    if not cls._meta.get_field(cls.USERNAME_FIELD).unique and not any(
        constraint.fields == (cls.USERNAME_FIELD,)
        for constraint in cls._meta.total_unique_constraints
    ):
        if settings.AUTHENTICATION_BACKENDS == [
            ""django.contrib.auth.backends.ModelBackend""
        ]:
            errors.append(
                checks.Error(
                    ""'%s.%s' must be unique because it is named as the ""
                    ""'USERNAME_FIELD'."" % (cls._meta.object_name, cls.USERNAME_FIELD),
                    obj=cls,
                    id=""auth.E003"",
                )
            )
        else:
            errors.append(
                checks.Warning(
                    ""'%s.%s' is named as the 'USERNAME_FIELD', but it is not unique.""
                    % (cls._meta.object_name, cls.USERNAME_FIELD),
                    hint=(
                        ""Ensure that your authentication backend(s) can handle ""
                        ""non-unique usernames.""
                    ),
                    obj=cls,
                    id=""auth.W004"",
                )
            )

    if isinstance(cls().is_anonymous, MethodType):
        errors.append(
            checks.Critical(
                ""%s.is_anonymous must be an attribute or property rather than ""
                ""a method. Ignoring this is a security issue as anonymous ""
                ""users will be treated as authenticated!"" % cls,
                obj=cls,
                id=""auth.C009"",
            )
        )
    if isinstance(cls().is_authenticated, MethodType):
        errors.append(
            checks.Critical(
                ""%s.is_authenticated must be an attribute or property rather ""
                ""than a method. Ignoring this is a security issue as anonymous ""
                ""users will be treated as authenticated!"" % cls,
                obj=cls,
                id=""auth.C010"",
            )
        )
    return errors


def check_models_permissions(app_configs=None, **kwargs):
    if app_configs is None:
        models = apps.get_models()
    else:
        models = chain.from_iterable(
            app_config.get_models() for app_config in app_configs
        )

    Permission = apps.get_model(""auth"", ""Permission"")
    permission_name_max_length = Permission._meta.get_field(""name"").max_length
    permission_codename_max_length = Permission._meta.get_field(""codename"").max_length
    errors = []

    for model in models:
        opts = model._meta
        builtin_permissions = dict(_get_builtin_permissions(opts))
        # Check builtin permission name length.
        max_builtin_permission_name_length = (
            max(len(name) for name in builtin_permissions.values())
            if builtin_permissions
            else 0
        )
        if max_builtin_permission_name_length > permission_name_max_length:
            verbose_name_max_length = permission_name_max_length - (
                max_builtin_permission_name_length - len(opts.verbose_name_raw)
            )
            errors.append(
                checks.Error(
                    ""The verbose_name of model '%s' must be at most %d ""
                    ""characters for its builtin permission names to be at ""
                    ""most %d characters.""
                    % (opts.label, verbose_name_max_length, permission_name_max_length),
                    obj=model,
                    id=""auth.E007"",
                )
            )
        # Check builtin permission codename length.
        max_builtin_permission_codename_length = (
            max(len(codename) for codename in builtin_permissions.keys())
            if builtin_permissions
            else 0
        )
        if max_builtin_permission_codename_length > permission_codename_max_length:
            model_name_max_length = permission_codename_max_length - (
                max_builtin_permission_codename_length - len(opts.model_name)
            )
            errors.append(
                checks.Error(
                    ""The name of model '%s' must be at most %d characters ""
                    ""for its builtin permission codenames to be at most %d ""
                    ""characters.""
                    % (
                        opts.label,
                        model_name_max_length,
                        permission_codename_max_length,
                    ),
                    obj=model,
                    id=""auth.E011"",
                )
            )
        codenames = set()
        for codename, name in opts.permissions:
            # Check custom permission name length.
            if len(name) > permission_name_max_length:
                errors.append(
                    checks.Error(
                        ""The permission named '%s' of model '%s' is longer ""
                        ""than %d characters.""
                        % (
                            name,
                            opts.label,
                            permission_name_max_length,
                        ),
                        obj=model,
                        id=""auth.E008"",
                    )
                )
            # Check custom permission codename length.
            if len(codename) > permission_codename_max_length:
                errors.append(
                    checks.Error(
                        ""The permission codenamed '%s' of model '%s' is ""
                        ""longer than %d characters.""
                        % (
                            codename,
                            opts.label,
                            permission_codename_max_length,
                        ),
                        obj=model,
                        id=""auth.E012"",
                    )
                )
            # Check custom permissions codename clashing.
            if codename in builtin_permissions:
                errors.append(
                    checks.Error(
                        ""The permission codenamed '%s' clashes with a builtin ""
                        ""permission for model '%s'."" % (codename, opts.label),
                        obj=model,
                        id=""auth.E005"",
                    )
                )
            elif codename in codenames:
                errors.append(
                    checks.Error(
                        ""The permission codenamed '%s' is duplicated for ""
                        ""model '%s'."" % (codename, opts.label),
                        obj=model,
                        id=""auth.E006"",
                    )
                )
            codenames.add(codename)

    return errors<EOS>"
"<BOS>from functools import wraps
from urllib.parse import urlparse

from django.conf import settings
from django.contrib.auth import REDIRECT_FIELD_NAME
from django.core.exceptions import PermissionDenied
from django.shortcuts import resolve_url


def user_passes_test(
    test_func, login_url=None, redirect_field_name=REDIRECT_FIELD_NAME
):
    """"""
    Decorator for views that checks that the user passes the given test,
    redirecting to the log-in page if necessary. The test should be a callable
    that takes the user object and returns True if the user passes.
    """"""

    def decorator(view_func):
        @wraps(view_func)
        def _wrapped_view(request, *args, **kwargs):
            if test_func(request.user):
                return view_func(request, *args, **kwargs)
            path = request.build_absolute_uri()
            resolved_login_url = resolve_url(login_url or settings.LOGIN_URL)
            # If the login url is the same scheme and net location then just
            # use the path as the ""next"" url.
            login_scheme, login_netloc = urlparse(resolved_login_url)[:2]
            current_scheme, current_netloc = urlparse(path)[:2]
            if (not login_scheme or login_scheme == current_scheme) and (
                not login_netloc or login_netloc == current_netloc
            ):
                path = request.get_full_path()
            from django.contrib.auth.views import redirect_to_login

            return redirect_to_login(path, resolved_login_url, redirect_field_name)

        return _wrapped_view

    return decorator


def login_required(
    function=None, redirect_field_name=REDIRECT_FIELD_NAME, login_url=None
):
    """"""
    Decorator for views that checks that the user is logged in, redirecting
    to the log-in page if necessary.
    """"""
    actual_decorator = user_passes_test(
        lambda u: u.is_authenticated,
        login_url=login_url,
        redirect_field_name=redirect_field_name,
    )
    if function:
        return actual_decorator(function)
    return actual_decorator


def permission_required(perm, login_url=None, raise_exception=False):
    """"""
    Decorator for views that checks whether a user has a particular permission
    enabled, redirecting to the log-in page if necessary.
    If the raise_exception parameter is given the PermissionDenied exception
    is raised.
    """"""

    def check_perms(user):
        if isinstance(perm, str):
            perms = (perm,)
        else:
            perms = perm
        # First check if the user has the permission (even anon users)
        if user.has_perms(perms):
            return True
        # In case the 403 handler should be called raise the exception
        if raise_exception:
            raise PermissionDenied
        # As the last resort, show the login form
        return False

    return user_passes_test(check_perms, login_url=login_url)<EOS>"
"<BOS>import unicodedata

from django import forms
from django.contrib.auth import authenticate, get_user_model, password_validation
from django.contrib.auth.hashers import UNUSABLE_PASSWORD_PREFIX, identify_hasher
from django.contrib.auth.models import User
from django.contrib.auth.tokens import default_token_generator
from django.contrib.sites.shortcuts import get_current_site
from django.core.exceptions import ValidationError
from django.core.mail import EmailMultiAlternatives
from django.template import loader
from django.utils.encoding import force_bytes
from django.utils.http import urlsafe_base64_encode
from django.utils.text import capfirst
from django.utils.translation import gettext
from django.utils.translation import gettext_lazy as _

UserModel = get_user_model()


def _unicode_ci_compare(s1, s2):
    """"""
    Perform case-insensitive comparison of two identifiers, using the
    recommended algorithm from Unicode Technical Report 36, section
    2.11.2(B)(2).
    """"""
    return (
        unicodedata.normalize(""NFKC"", s1).casefold()
        == unicodedata.normalize(""NFKC"", s2).casefold()
    )


class ReadOnlyPasswordHashWidget(forms.Widget):
    template_name = ""auth/widgets/read_only_password_hash.html""
    read_only = True

    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
        summary = []
        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):
            summary.append({""label"": gettext(""No password set."")})
        else:
            try:
                hasher = identify_hasher(value)
            except ValueError:
                summary.append(
                    {
                        ""label"": gettext(
                            ""Invalid password format or unknown hashing algorithm.""
                        )
                    }
                )
            else:
                for key, value_ in hasher.safe_summary(value).items():
                    summary.append({""label"": gettext(key), ""value"": value_})
        context[""summary""] = summary
        return context

    def id_for_label(self, id_):
        return None


class ReadOnlyPasswordHashField(forms.Field):
    widget = ReadOnlyPasswordHashWidget

    def __init__(self, *args, **kwargs):
        kwargs.setdefault(""required"", False)
        kwargs.setdefault(""disabled"", True)
        super().__init__(*args, **kwargs)


class UsernameField(forms.CharField):
    def to_python(self, value):
        return unicodedata.normalize(""NFKC"", super().to_python(value))

    def widget_attrs(self, widget):
        return {
            **super().widget_attrs(widget),
            ""autocapitalize"": ""none"",
            ""autocomplete"": ""username"",
        }


class UserCreationForm(forms.ModelForm):
    """"""
    A form that creates a user, with no privileges, from the given username and
    password.
    """"""

    error_messages = {
        ""password_mismatch"": _(""The two password fields didn’t match.""),
    }
    password1 = forms.CharField(
        label=_(""Password""),
        strip=False,
        widget=forms.PasswordInput(attrs={""autocomplete"": ""new-password""}),
        help_text=password_validation.password_validators_help_text_html(),
    )
    password2 = forms.CharField(
        label=_(""Password confirmation""),
        widget=forms.PasswordInput(attrs={""autocomplete"": ""new-password""}),
        strip=False,
        help_text=_(""Enter the same password as before, for verification.""),
    )

    class Meta:
        model = User
        fields = (""username"",)
        field_classes = {""username"": UsernameField}

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self._meta.model.USERNAME_FIELD in self.fields:
            self.fields[self._meta.model.USERNAME_FIELD].widget.attrs[
                ""autofocus""
            ] = True

    def clean_password2(self):
        password1 = self.cleaned_data.get(""password1"")
        password2 = self.cleaned_data.get(""password2"")
        if password1 and password2 and password1 != password2:
            raise ValidationError(
                self.error_messages[""password_mismatch""],
                code=""password_mismatch"",
            )
        return password2

    def _post_clean(self):
        super()._post_clean()
        # Validate the password after self.instance is updated with form data
        # by super().
        password = self.cleaned_data.get(""password2"")
        if password:
            try:
                password_validation.validate_password(password, self.instance)
            except ValidationError as error:
                self.add_error(""password2"", error)

    def save(self, commit=True):
        user = super().save(commit=False)
        user.set_password(self.cleaned_data[""password1""])
        if commit:
            user.save()
        return user


class UserChangeForm(forms.ModelForm):
    password = ReadOnlyPasswordHashField(
        label=_(""Password""),
        help_text=_(
            ""Raw passwords are not stored, so there is no way to see this ""
            ""user’s password, but you can change the password using ""
            '<a href=""{}"">this form</a>.'
        ),
    )

    class Meta:
        model = User
        fields = ""__all__""
        field_classes = {""username"": UsernameField}

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        password = self.fields.get(""password"")
        if password:
            password.help_text = password.help_text.format(""../password/"")
        user_permissions = self.fields.get(""user_permissions"")
        if user_permissions:
            user_permissions.queryset = user_permissions.queryset.select_related(
                ""content_type""
            )


class AuthenticationForm(forms.Form):
    """"""
    Base class for authenticating users. Extend this to get a form that accepts
    username/password logins.
    """"""

    username = UsernameField(widget=forms.TextInput(attrs={""autofocus"": True}))
    password = forms.CharField(
        label=_(""Password""),
        strip=False,
        widget=forms.PasswordInput(attrs={""autocomplete"": ""current-password""}),
    )

    error_messages = {
        ""invalid_login"": _(
            ""Please enter a correct %(username)s and password. Note that both ""
            ""fields may be case-sensitive.""
        ),
        ""inactive"": _(""This account is inactive.""),
    }

    def __init__(self, request=None, *args, **kwargs):
        """"""
        The 'request' parameter is set for custom auth use by subclasses.
        The form data comes in via the standard 'data' kwarg.
        """"""
        self.request = request
        self.user_cache = None
        super().__init__(*args, **kwargs)

        # Set the max length and label for the ""username"" field.
        self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)
        username_max_length = self.username_field.max_length or 254
        self.fields[""username""].max_length = username_max_length
        self.fields[""username""].widget.attrs[""maxlength""] = username_max_length
        if self.fields[""username""].label is None:
            self.fields[""username""].label = capfirst(self.username_field.verbose_name)

    def clean(self):
        username = self.cleaned_data.get(""username"")
        password = self.cleaned_data.get(""password"")

        if username is not None and password:
            self.user_cache = authenticate(
                self.request, username=username, password=password
            )
            if self.user_cache is None:
                raise self.get_invalid_login_error()
            else:
                self.confirm_login_allowed(self.user_cache)

        return self.cleaned_data

    def confirm_login_allowed(self, user):
        """"""
        Controls whether the given User may log in. This is a policy setting,
        independent of end-user authentication. This default behavior is to
        allow login by active users, and reject login by inactive users.

        If the given user cannot log in, this method should raise a
        ``ValidationError``.

        If the given user may log in, this method should return None.
        """"""
        if not user.is_active:
            raise ValidationError(
                self.error_messages[""inactive""],
                code=""inactive"",
            )

    def get_user(self):
        return self.user_cache

    def get_invalid_login_error(self):
        return ValidationError(
            self.error_messages[""invalid_login""],
            code=""invalid_login"",
            params={""username"": self.username_field.verbose_name},
        )


class PasswordResetForm(forms.Form):
    email = forms.EmailField(
        label=_(""Email""),
        max_length=254,
        widget=forms.EmailInput(attrs={""autocomplete"": ""email""}),
    )

    def send_mail(
        self,
        subject_template_name,
        email_template_name,
        context,
        from_email,
        to_email,
        html_email_template_name=None,
    ):
        """"""
        Send a django.core.mail.EmailMultiAlternatives to `to_email`.
        """"""
        subject = loader.render_to_string(subject_template_name, context)
        # Email subject *must not* contain newlines
        subject = """".join(subject.splitlines())
        body = loader.render_to_string(email_template_name, context)

        email_message = EmailMultiAlternatives(subject, body, from_email, [to_email])
        if html_email_template_name is not None:
            html_email = loader.render_to_string(html_email_template_name, context)
            email_message.attach_alternative(html_email, ""text/html"")

        email_message.send()

    def get_users(self, email):
        """"""Given an email, return matching user(s) who should receive a reset.

        This allows subclasses to more easily customize the default policies
        that prevent inactive users and users with unusable passwords from
        resetting their password.
        """"""
        email_field_name = UserModel.get_email_field_name()
        active_users = UserModel._default_manager.filter(
            **{
                ""%s__iexact"" % email_field_name: email,
                ""is_active"": True,
            }
        )
        return (
            u
            for u in active_users
            if u.has_usable_password()
            and _unicode_ci_compare(email, getattr(u, email_field_name))
        )

    def save(
        self,
        domain_override=None,
        subject_template_name=""registration/password_reset_subject.txt"",
        email_template_name=""registration/password_reset_email.html"",
        use_https=False,
        token_generator=default_token_generator,
        from_email=None,
        request=None,
        html_email_template_name=None,
        extra_email_context=None,
    ):
        """"""
        Generate a one-use only link for resetting password and send it to the
        user.
        """"""
        email = self.cleaned_data[""email""]
        if not domain_override:
            current_site = get_current_site(request)
            site_name = current_site.name
            domain = current_site.domain
        else:
            site_name = domain = domain_override
        email_field_name = UserModel.get_email_field_name()
        for user in self.get_users(email):
            user_email = getattr(user, email_field_name)
            context = {
                ""email"": user_email,
                ""domain"": domain,
                ""site_name"": site_name,
                ""uid"": urlsafe_base64_encode(force_bytes(user.pk)),
                ""user"": user,
                ""token"": token_generator.make_token(user),
                ""protocol"": ""https"" if use_https else ""http"",
                **(extra_email_context or {}),
            }
            self.send_mail(
                subject_template_name,
                email_template_name,
                context,
                from_email,
                user_email,
                html_email_template_name=html_email_template_name,
            )


class SetPasswordForm(forms.Form):
    """"""
    A form that lets a user change set their password without entering the old
    password
    """"""

    error_messages = {
        ""password_mismatch"": _(""The two password fields didn’t match.""),
    }
    new_password1 = forms.CharField(
        label=_(""New password""),
        widget=forms.PasswordInput(attrs={""autocomplete"": ""new-password""}),
        strip=False,
        help_text=password_validation.password_validators_help_text_html(),
    )
    new_password2 = forms.CharField(
        label=_(""New password confirmation""),
        strip=False,
        widget=forms.PasswordInput(attrs={""autocomplete"": ""new-password""}),
    )

    def __init__(self, user, *args, **kwargs):
        self.user = user
        super().__init__(*args, **kwargs)

    def clean_new_password2(self):
        password1 = self.cleaned_data.get(""new_password1"")
        password2 = self.cleaned_data.get(""new_password2"")
        if password1 and password2:
            if password1 != password2:
                raise ValidationError(
                    self.error_messages[""password_mismatch""],
                    code=""password_mismatch"",
                )
        password_validation.validate_password(password2, self.user)
        return password2

    def save(self, commit=True):
        password = self.cleaned_data[""new_password1""]
        self.user.set_password(password)
        if commit:
            self.user.save()
        return self.user


class PasswordChangeForm(SetPasswordForm):
    """"""
    A form that lets a user change their password by entering their old
    password.
    """"""

    error_messages = {
        **SetPasswordForm.error_messages,
        ""password_incorrect"": _(
            ""Your old password was entered incorrectly. Please enter it again.""
        ),
    }
    old_password = forms.CharField(
        label=_(""Old password""),
        strip=False,
        widget=forms.PasswordInput(
            attrs={""autocomplete"": ""current-password"", ""autofocus"": True}
        ),
    )

    field_order = [""old_password"", ""new_password1"", ""new_password2""]

    def clean_old_password(self):
        """"""
        Validate that the old_password field is correct.
        """"""
        old_password = self.cleaned_data[""old_password""]
        if not self.user.check_password(old_password):
            raise ValidationError(
                self.error_messages[""password_incorrect""],
                code=""password_incorrect"",
            )
        return old_password


class AdminPasswordChangeForm(forms.Form):
    """"""
    A form used to change the password of a user in the admin interface.
    """"""

    error_messages = {
        ""password_mismatch"": _(""The two password fields didn’t match.""),
    }
    required_css_class = ""required""
    password1 = forms.CharField(
        label=_(""Password""),
        widget=forms.PasswordInput(
            attrs={""autocomplete"": ""new-password"", ""autofocus"": True}
        ),
        strip=False,
        help_text=password_validation.password_validators_help_text_html(),
    )
    password2 = forms.CharField(
        label=_(""Password (again)""),
        widget=forms.PasswordInput(attrs={""autocomplete"": ""new-password""}),
        strip=False,
        help_text=_(""Enter the same password as before, for verification.""),
    )

    def __init__(self, user, *args, **kwargs):
        self.user = user
        super().__init__(*args, **kwargs)

    def clean_password2(self):
        password1 = self.cleaned_data.get(""password1"")
        password2 = self.cleaned_data.get(""password2"")
        if password1 and password2 and password1 != password2:
            raise ValidationError(
                self.error_messages[""password_mismatch""],
                code=""password_mismatch"",
            )
        password_validation.validate_password(password2, self.user)
        return password2

    def save(self, commit=True):
        """"""Save the new password.""""""
        password = self.cleaned_data[""password1""]
        self.user.set_password(password)
        if commit:
            self.user.save()
        return self.user

    @property
    def changed_data(self):
        data = super().changed_data
        for name in self.fields:
            if name not in data:
                return []
        return [""password""]<EOS>"
"<BOS>from django.conf import settings
from django.contrib import admin, messages
from django.contrib.admin.options import IS_POPUP_VAR
from django.contrib.admin.utils import unquote
from django.contrib.auth import update_session_auth_hash
from django.contrib.auth.forms import (
    AdminPasswordChangeForm,
    UserChangeForm,
    UserCreationForm,
)
from django.contrib.auth.models import Group, User
from django.core.exceptions import PermissionDenied
from django.db import router, transaction
from django.http import Http404, HttpResponseRedirect
from django.template.response import TemplateResponse
from django.urls import path, reverse
from django.utils.decorators import method_decorator
from django.utils.html import escape
from django.utils.translation import gettext
from django.utils.translation import gettext_lazy as _
from django.views.decorators.csrf import csrf_protect
from django.views.decorators.debug import sensitive_post_parameters

csrf_protect_m = method_decorator(csrf_protect)
sensitive_post_parameters_m = method_decorator(sensitive_post_parameters())


@admin.register(Group)
class GroupAdmin(admin.ModelAdmin):
    search_fields = (""name"",)
    ordering = (""name"",)
    filter_horizontal = (""permissions"",)

    def formfield_for_manytomany(self, db_field, request=None, **kwargs):
        if db_field.name == ""permissions"":
            qs = kwargs.get(""queryset"", db_field.remote_field.model.objects)
            # Avoid a major performance hit resolving permission names which
            # triggers a content_type load:
            kwargs[""queryset""] = qs.select_related(""content_type"")
        return super().formfield_for_manytomany(db_field, request=request, **kwargs)


@admin.register(User)
class UserAdmin(admin.ModelAdmin):
    add_form_template = ""admin/auth/user/add_form.html""
    change_user_password_template = None
    fieldsets = (
        (None, {""fields"": (""username"", ""password"")}),
        (_(""Personal info""), {""fields"": (""first_name"", ""last_name"", ""email"")}),
        (
            _(""Permissions""),
            {
                ""fields"": (
                    ""is_active"",
                    ""is_staff"",
                    ""is_superuser"",
                    ""groups"",
                    ""user_permissions"",
                ),
            },
        ),
        (_(""Important dates""), {""fields"": (""last_login"", ""date_joined"")}),
    )
    add_fieldsets = (
        (
            None,
            {
                ""classes"": (""wide"",),
                ""fields"": (""username"", ""password1"", ""password2""),
            },
        ),
    )
    form = UserChangeForm
    add_form = UserCreationForm
    change_password_form = AdminPasswordChangeForm
    list_display = (""username"", ""email"", ""first_name"", ""last_name"", ""is_staff"")
    list_filter = (""is_staff"", ""is_superuser"", ""is_active"", ""groups"")
    search_fields = (""username"", ""first_name"", ""last_name"", ""email"")
    ordering = (""username"",)
    filter_horizontal = (
        ""groups"",
        ""user_permissions"",
    )

    def get_fieldsets(self, request, obj=None):
        if not obj:
            return self.add_fieldsets
        return super().get_fieldsets(request, obj)

    def get_form(self, request, obj=None, **kwargs):
        """"""
        Use special form during user creation
        """"""
        defaults = {}
        if obj is None:
            defaults[""form""] = self.add_form
        defaults.update(kwargs)
        return super().get_form(request, obj, **defaults)

    def get_urls(self):
        return [
            path(
                ""<id>/password/"",
                self.admin_site.admin_view(self.user_change_password),
                name=""auth_user_password_change"",
            ),
        ] + super().get_urls()

    def lookup_allowed(self, lookup, value):
        # Don't allow lookups involving passwords.
        return not lookup.startswith(""password"") and super().lookup_allowed(
            lookup, value
        )

    @sensitive_post_parameters_m
    @csrf_protect_m
    def add_view(self, request, form_url="""", extra_context=None):
        with transaction.atomic(using=router.db_for_write(self.model)):
            return self._add_view(request, form_url, extra_context)

    def _add_view(self, request, form_url="""", extra_context=None):
        # It's an error for a user to have add permission but NOT change
        # permission for users. If we allowed such users to add users, they
        # could create superusers, which would mean they would essentially have
        # the permission to change users. To avoid the problem entirely, we
        # disallow users from adding users if they don't have change
        # permission.
        if not self.has_change_permission(request):
            if self.has_add_permission(request) and settings.DEBUG:
                # Raise Http404 in debug mode so that the user gets a helpful
                # error message.
                raise Http404(
                    'Your user does not have the ""Change user"" permission. In '
                    ""order to add users, Django requires that your user ""
                    'account have both the ""Add user"" and ""Change user"" '
                    ""permissions set.""
                )
            raise PermissionDenied
        if extra_context is None:
            extra_context = {}
        username_field = self.model._meta.get_field(self.model.USERNAME_FIELD)
        defaults = {
            ""auto_populated_fields"": (),
            ""username_help_text"": username_field.help_text,
        }
        extra_context.update(defaults)
        return super().add_view(request, form_url, extra_context)

    @sensitive_post_parameters_m
    def user_change_password(self, request, id, form_url=""""):
        user = self.get_object(request, unquote(id))
        if not self.has_change_permission(request, user):
            raise PermissionDenied
        if user is None:
            raise Http404(
                _(""%(name)s object with primary key %(key)r does not exist."")
                % {
                    ""name"": self.model._meta.verbose_name,
                    ""key"": escape(id),
                }
            )
        if request.method == ""POST"":
            form = self.change_password_form(user, request.POST)
            if form.is_valid():
                form.save()
                change_message = self.construct_change_message(request, form, None)
                self.log_change(request, user, change_message)
                msg = gettext(""Password changed successfully."")
                messages.success(request, msg)
                update_session_auth_hash(request, form.user)
                return HttpResponseRedirect(
                    reverse(
                        ""%s:%s_%s_change""
                        % (
                            self.admin_site.name,
                            user._meta.app_label,
                            user._meta.model_name,
                        ),
                        args=(user.pk,),
                    )
                )
        else:
            form = self.change_password_form(user)

        fieldsets = [(None, {""fields"": list(form.base_fields)})]
        adminForm = admin.helpers.AdminForm(form, fieldsets, {})

        context = {
            ""title"": _(""Change password: %s"") % escape(user.get_username()),
            ""adminForm"": adminForm,
            ""form_url"": form_url,
            ""form"": form,
            ""is_popup"": (IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET),
            ""is_popup_var"": IS_POPUP_VAR,
            ""add"": True,
            ""change"": False,
            ""has_delete_permission"": False,
            ""has_change_permission"": True,
            ""has_absolute_url"": False,
            ""opts"": self.model._meta,
            ""original"": user,
            ""save_as"": False,
            ""show_save"": True,
            **self.admin_site.each_context(request),
        }

        request.current_app = self.admin_site.name

        return TemplateResponse(
            request,
            self.change_user_password_template
            or ""admin/auth/user/change_password.html"",
            context,
        )

    def response_add(self, request, obj, post_url_continue=None):
        """"""
        Determine the HttpResponse for the add_view stage. It mostly defers to
        its superclass implementation but is customized because the User model
        has a slightly different workflow.
        """"""
        # We should allow further modification of the user just added i.e. the
        # 'Save' button should behave like the 'Save and continue editing'
        # button except in two scenarios:
        # * The user has pressed the 'Save and add another' button
        # * We are adding a user in a popup
        if ""_addanother"" not in request.POST and IS_POPUP_VAR not in request.POST:
            request.POST = request.POST.copy()
            request.POST[""_continue""] = 1
        return super().response_add(request, obj, post_url_continue)<EOS>"
"<BOS>import warnings

from django.contrib.auth import get_user_model
from django.contrib.auth.models import Permission
from django.db.models import Exists, OuterRef, Q
from django.utils.deprecation import RemovedInDjango50Warning
from django.utils.inspect import func_supports_parameter

UserModel = get_user_model()


class BaseBackend:
    def authenticate(self, request, **kwargs):
        return None

    def get_user(self, user_id):
        return None

    def get_user_permissions(self, user_obj, obj=None):
        return set()

    def get_group_permissions(self, user_obj, obj=None):
        return set()

    def get_all_permissions(self, user_obj, obj=None):
        return {
            *self.get_user_permissions(user_obj, obj=obj),
            *self.get_group_permissions(user_obj, obj=obj),
        }

    def has_perm(self, user_obj, perm, obj=None):
        return perm in self.get_all_permissions(user_obj, obj=obj)


class ModelBackend(BaseBackend):
    """"""
    Authenticates against settings.AUTH_USER_MODEL.
    """"""

    def authenticate(self, request, username=None, password=None, **kwargs):
        if username is None:
            username = kwargs.get(UserModel.USERNAME_FIELD)
        if username is None or password is None:
            return
        try:
            user = UserModel._default_manager.get_by_natural_key(username)
        except UserModel.DoesNotExist:
            # Run the default password hasher once to reduce the timing
            # difference between an existing and a nonexistent user (#20760).
            UserModel().set_password(password)
        else:
            if user.check_password(password) and self.user_can_authenticate(user):
                return user

    def user_can_authenticate(self, user):
        """"""
        Reject users with is_active=False. Custom user models that don't have
        that attribute are allowed.
        """"""
        is_active = getattr(user, ""is_active"", None)
        return is_active or is_active is None

    def _get_user_permissions(self, user_obj):
        return user_obj.user_permissions.all()

    def _get_group_permissions(self, user_obj):
        user_groups_field = get_user_model()._meta.get_field(""groups"")
        user_groups_query = ""group__%s"" % user_groups_field.related_query_name()
        return Permission.objects.filter(**{user_groups_query: user_obj})

    def _get_permissions(self, user_obj, obj, from_name):
        """"""
        Return the permissions of `user_obj` from `from_name`. `from_name` can
        be either ""group"" or ""user"" to return permissions from
        `_get_group_permissions` or `_get_user_permissions` respectively.
        """"""
        if not user_obj.is_active or user_obj.is_anonymous or obj is not None:
            return set()

        perm_cache_name = ""_%s_perm_cache"" % from_name
        if not hasattr(user_obj, perm_cache_name):
            if user_obj.is_superuser:
                perms = Permission.objects.all()
            else:
                perms = getattr(self, ""_get_%s_permissions"" % from_name)(user_obj)
            perms = perms.values_list(""content_type__app_label"", ""codename"").order_by()
            setattr(
                user_obj, perm_cache_name, {""%s.%s"" % (ct, name) for ct, name in perms}
            )
        return getattr(user_obj, perm_cache_name)

    def get_user_permissions(self, user_obj, obj=None):
        """"""
        Return a set of permission strings the user `user_obj` has from their
        `user_permissions`.
        """"""
        return self._get_permissions(user_obj, obj, ""user"")

    def get_group_permissions(self, user_obj, obj=None):
        """"""
        Return a set of permission strings the user `user_obj` has from the
        groups they belong.
        """"""
        return self._get_permissions(user_obj, obj, ""group"")

    def get_all_permissions(self, user_obj, obj=None):
        if not user_obj.is_active or user_obj.is_anonymous or obj is not None:
            return set()
        if not hasattr(user_obj, ""_perm_cache""):
            user_obj._perm_cache = super().get_all_permissions(user_obj)
        return user_obj._perm_cache

    def has_perm(self, user_obj, perm, obj=None):
        return user_obj.is_active and super().has_perm(user_obj, perm, obj=obj)

    def has_module_perms(self, user_obj, app_label):
        """"""
        Return True if user_obj has any permissions in the given app_label.
        """"""
        return user_obj.is_active and any(
            perm[: perm.index(""."")] == app_label
            for perm in self.get_all_permissions(user_obj)
        )

    def with_perm(self, perm, is_active=True, include_superusers=True, obj=None):
        """"""
        Return users that have permission ""perm"". By default, filter out
        inactive users and include superusers.
        """"""
        if isinstance(perm, str):
            try:
                app_label, codename = perm.split(""."")
            except ValueError:
                raise ValueError(
                    ""Permission name should be in the form ""
                    ""app_label.permission_codename.""
                )
        elif not isinstance(perm, Permission):
            raise TypeError(
                ""The `perm` argument must be a string or a permission instance.""
            )

        if obj is not None:
            return UserModel._default_manager.none()

        permission_q = Q(group__user=OuterRef(""pk"")) | Q(user=OuterRef(""pk""))
        if isinstance(perm, Permission):
            permission_q &= Q(pk=perm.pk)
        else:
            permission_q &= Q(codename=codename, content_type__app_label=app_label)

        user_q = Exists(Permission.objects.filter(permission_q))
        if include_superusers:
            user_q |= Q(is_superuser=True)
        if is_active is not None:
            user_q &= Q(is_active=is_active)

        return UserModel._default_manager.filter(user_q)

    def get_user(self, user_id):
        try:
            user = UserModel._default_manager.get(pk=user_id)
        except UserModel.DoesNotExist:
            return None
        return user if self.user_can_authenticate(user) else None


class AllowAllUsersModelBackend(ModelBackend):
    def user_can_authenticate(self, user):
        return True


class RemoteUserBackend(ModelBackend):
    """"""
    This backend is to be used in conjunction with the ``RemoteUserMiddleware``
    found in the middleware module of this package, and is used when the server
    is handling authentication outside of Django.

    By default, the ``authenticate`` method creates ``User`` objects for
    usernames that don't already exist in the database.  Subclasses can disable
    this behavior by setting the ``create_unknown_user`` attribute to
    ``False``.
    """"""

    # Create a User object if not already in the database?
    create_unknown_user = True

    def authenticate(self, request, remote_user):
        """"""
        The username passed as ``remote_user`` is considered trusted. Return
        the ``User`` object with the given username. Create a new ``User``
        object if ``create_unknown_user`` is ``True``.

        Return None if ``create_unknown_user`` is ``False`` and a ``User``
        object with the given username is not found in the database.
        """"""
        if not remote_user:
            return
        created = False
        user = None
        username = self.clean_username(remote_user)

        # Note that this could be accomplished in one try-except clause, but
        # instead we use get_or_create when creating unknown users since it has
        # built-in safeguards for multiple threads.
        if self.create_unknown_user:
            user, created = UserModel._default_manager.get_or_create(
                **{UserModel.USERNAME_FIELD: username}
            )
        else:
            try:
                user = UserModel._default_manager.get_by_natural_key(username)
            except UserModel.DoesNotExist:
                pass

        # RemovedInDjango50Warning: When the deprecation ends, replace with:
        #   user = self.configure_user(request, user, created=created)
        if func_supports_parameter(self.configure_user, ""created""):
            user = self.configure_user(request, user, created=created)
        else:
            warnings.warn(
                f""`created=True` must be added to the signature of ""
                f""{self.__class__.__qualname__}.configure_user()."",
                category=RemovedInDjango50Warning,
            )
            if created:
                user = self.configure_user(request, user)
        return user if self.user_can_authenticate(user) else None

    def clean_username(self, username):
        """"""
        Perform any cleaning on the ""username"" prior to using it to get or
        create the user object.  Return the cleaned username.

        By default, return the username unchanged.
        """"""
        return username

    def configure_user(self, request, user, created=True):
        """"""
        Configure a user and return the updated user.

        By default, return the user unmodified.
        """"""
        return user


class AllowAllUsersRemoteUserBackend(RemoteUserBackend):
    def user_can_authenticate(self, user):
        return True<EOS>"
"<BOS>from django import db
from django.contrib import auth

UserModel = auth.get_user_model()


def check_password(environ, username, password):
    """"""
    Authenticate against Django's auth database.

    mod_wsgi docs specify None, True, False as return value depending
    on whether the user exists and authenticates.
    """"""
    # db connection state is managed similarly to the wsgi handler
    # as mod_wsgi may call these functions outside of a request/response cycle
    db.reset_queries()
    try:
        try:
            user = UserModel._default_manager.get_by_natural_key(username)
        except UserModel.DoesNotExist:
            return None
        if not user.is_active:
            return None
        return user.check_password(password)
    finally:
        db.close_old_connections()


def groups_for_user(environ, username):
    """"""
    Authorize a user based on groups
    """"""
    db.reset_queries()
    try:
        try:
            user = UserModel._default_manager.get_by_natural_key(username)
        except UserModel.DoesNotExist:
            return []
        if not user.is_active:
            return []
        return [group.name.encode() for group in user.groups.all()]
    finally:
        db.close_old_connections()<EOS>"
"<BOS>from django.contrib.admin.decorators import action, display, register
from django.contrib.admin.filters import (
    AllValuesFieldListFilter,
    BooleanFieldListFilter,
    ChoicesFieldListFilter,
    DateFieldListFilter,
    EmptyFieldListFilter,
    FieldListFilter,
    ListFilter,
    RelatedFieldListFilter,
    RelatedOnlyFieldListFilter,
    SimpleListFilter,
)
from django.contrib.admin.options import (
    HORIZONTAL,
    VERTICAL,
    ModelAdmin,
    StackedInline,
    TabularInline,
)
from django.contrib.admin.sites import AdminSite, site
from django.utils.module_loading import autodiscover_modules

__all__ = [
    ""action"",
    ""display"",
    ""register"",
    ""ModelAdmin"",
    ""HORIZONTAL"",
    ""VERTICAL"",
    ""StackedInline"",
    ""TabularInline"",
    ""AdminSite"",
    ""site"",
    ""ListFilter"",
    ""SimpleListFilter"",
    ""FieldListFilter"",
    ""BooleanFieldListFilter"",
    ""RelatedFieldListFilter"",
    ""ChoicesFieldListFilter"",
    ""DateFieldListFilter"",
    ""AllValuesFieldListFilter"",
    ""EmptyFieldListFilter"",
    ""RelatedOnlyFieldListFilter"",
    ""autodiscover"",
]


def autodiscover():
    autodiscover_modules(""admin"", register_to=site)<EOS>"
"<BOS>from django.apps import AppConfig
from django.contrib.admin.checks import check_admin_app, check_dependencies
from django.core import checks
from django.utils.translation import gettext_lazy as _


class SimpleAdminConfig(AppConfig):
    """"""Simple AppConfig which does not do automatic discovery.""""""

    default_auto_field = ""django.db.models.AutoField""
    default_site = ""django.contrib.admin.sites.AdminSite""
    name = ""django.contrib.admin""
    verbose_name = _(""Administration"")

    def ready(self):
        checks.register(check_dependencies, checks.Tags.admin)
        checks.register(check_admin_app, checks.Tags.admin)


class AdminConfig(SimpleAdminConfig):
    """"""The default AppConfig for admin which does autodiscovery.""""""

    default = True

    def ready(self):
        super().ready()
        self.module.autodiscover()<EOS>"
"<BOS>import collections
from itertools import chain

from django.apps import apps
from django.conf import settings
from django.contrib.admin.utils import NotRelationField, flatten, get_fields_from_path
from django.core import checks
from django.core.exceptions import FieldDoesNotExist
from django.db import models
from django.db.models.constants import LOOKUP_SEP
from django.db.models.expressions import Combinable
from django.forms.models import BaseModelForm, BaseModelFormSet, _get_foreign_key
from django.template import engines
from django.template.backends.django import DjangoTemplates
from django.utils.module_loading import import_string


def _issubclass(cls, classinfo):
    """"""
    issubclass() variant that doesn't raise an exception if cls isn't a
    class.
    """"""
    try:
        return issubclass(cls, classinfo)
    except TypeError:
        return False


def _contains_subclass(class_path, candidate_paths):
    """"""
    Return whether or not a dotted class path (or a subclass of that class) is
    found in a list of candidate paths.
    """"""
    cls = import_string(class_path)
    for path in candidate_paths:
        try:
            candidate_cls = import_string(path)
        except ImportError:
            # ImportErrors are raised elsewhere.
            continue
        if _issubclass(candidate_cls, cls):
            return True
    return False


def check_admin_app(app_configs, **kwargs):
    from django.contrib.admin.sites import all_sites

    errors = []
    for site in all_sites:
        errors.extend(site.check(app_configs))
    return errors


def check_dependencies(**kwargs):
    """"""
    Check that the admin's dependencies are correctly installed.
    """"""
    from django.contrib.admin.sites import all_sites

    if not apps.is_installed(""django.contrib.admin""):
        return []
    errors = []
    app_dependencies = (
        (""django.contrib.contenttypes"", 401),
        (""django.contrib.auth"", 405),
        (""django.contrib.messages"", 406),
    )
    for app_name, error_code in app_dependencies:
        if not apps.is_installed(app_name):
            errors.append(
                checks.Error(
                    ""'%s' must be in INSTALLED_APPS in order to use the admin ""
                    ""application."" % app_name,
                    id=""admin.E%d"" % error_code,
                )
            )
    for engine in engines.all():
        if isinstance(engine, DjangoTemplates):
            django_templates_instance = engine.engine
            break
    else:
        django_templates_instance = None
    if not django_templates_instance:
        errors.append(
            checks.Error(
                ""A 'django.template.backends.django.DjangoTemplates' instance ""
                ""must be configured in TEMPLATES in order to use the admin ""
                ""application."",
                id=""admin.E403"",
            )
        )
    else:
        if (
            ""django.contrib.auth.context_processors.auth""
            not in django_templates_instance.context_processors
            and _contains_subclass(
                ""django.contrib.auth.backends.ModelBackend"",
                settings.AUTHENTICATION_BACKENDS,
            )
        ):
            errors.append(
                checks.Error(
                    ""'django.contrib.auth.context_processors.auth' must be ""
                    ""enabled in DjangoTemplates (TEMPLATES) if using the default ""
                    ""auth backend in order to use the admin application."",
                    id=""admin.E402"",
                )
            )
        if (
            ""django.contrib.messages.context_processors.messages""
            not in django_templates_instance.context_processors
        ):
            errors.append(
                checks.Error(
                    ""'django.contrib.messages.context_processors.messages' must ""
                    ""be enabled in DjangoTemplates (TEMPLATES) in order to use ""
                    ""the admin application."",
                    id=""admin.E404"",
                )
            )
        sidebar_enabled = any(site.enable_nav_sidebar for site in all_sites)
        if (
            sidebar_enabled
            and ""django.template.context_processors.request""
            not in django_templates_instance.context_processors
        ):
            errors.append(
                checks.Warning(
                    ""'django.template.context_processors.request' must be enabled ""
                    ""in DjangoTemplates (TEMPLATES) in order to use the admin ""
                    ""navigation sidebar."",
                    id=""admin.W411"",
                )
            )

    if not _contains_subclass(
        ""django.contrib.auth.middleware.AuthenticationMiddleware"", settings.MIDDLEWARE
    ):
        errors.append(
            checks.Error(
                ""'django.contrib.auth.middleware.AuthenticationMiddleware' must ""
                ""be in MIDDLEWARE in order to use the admin application."",
                id=""admin.E408"",
            )
        )
    if not _contains_subclass(
        ""django.contrib.messages.middleware.MessageMiddleware"", settings.MIDDLEWARE
    ):
        errors.append(
            checks.Error(
                ""'django.contrib.messages.middleware.MessageMiddleware' must ""
                ""be in MIDDLEWARE in order to use the admin application."",
                id=""admin.E409"",
            )
        )
    if not _contains_subclass(
        ""django.contrib.sessions.middleware.SessionMiddleware"", settings.MIDDLEWARE
    ):
        errors.append(
            checks.Error(
                ""'django.contrib.sessions.middleware.SessionMiddleware' must ""
                ""be in MIDDLEWARE in order to use the admin application."",
                hint=(
                    ""Insert ""
                    ""'django.contrib.sessions.middleware.SessionMiddleware' ""
                    ""before ""
                    ""'django.contrib.auth.middleware.AuthenticationMiddleware'.""
                ),
                id=""admin.E410"",
            )
        )
    return errors


class BaseModelAdminChecks:
    def check(self, admin_obj, **kwargs):
        return [
            *self._check_autocomplete_fields(admin_obj),
            *self._check_raw_id_fields(admin_obj),
            *self._check_fields(admin_obj),
            *self._check_fieldsets(admin_obj),
            *self._check_exclude(admin_obj),
            *self._check_form(admin_obj),
            *self._check_filter_vertical(admin_obj),
            *self._check_filter_horizontal(admin_obj),
            *self._check_radio_fields(admin_obj),
            *self._check_prepopulated_fields(admin_obj),
            *self._check_view_on_site_url(admin_obj),
            *self._check_ordering(admin_obj),
            *self._check_readonly_fields(admin_obj),
        ]

    def _check_autocomplete_fields(self, obj):
        """"""
        Check that `autocomplete_fields` is a list or tuple of model fields.
        """"""
        if not isinstance(obj.autocomplete_fields, (list, tuple)):
            return must_be(
                ""a list or tuple"",
                option=""autocomplete_fields"",
                obj=obj,
                id=""admin.E036"",
            )
        else:
            return list(
                chain.from_iterable(
                    [
                        self._check_autocomplete_fields_item(
                            obj, field_name, ""autocomplete_fields[%d]"" % index
                        )
                        for index, field_name in enumerate(obj.autocomplete_fields)
                    ]
                )
            )

    def _check_autocomplete_fields_item(self, obj, field_name, label):
        """"""
        Check that an item in `autocomplete_fields` is a ForeignKey or a
        ManyToManyField and that the item has a related ModelAdmin with
        search_fields defined.
        """"""
        try:
            field = obj.model._meta.get_field(field_name)
        except FieldDoesNotExist:
            return refer_to_missing_field(
                field=field_name, option=label, obj=obj, id=""admin.E037""
            )
        else:
            if not field.many_to_many and not isinstance(field, models.ForeignKey):
                return must_be(
                    ""a foreign key or a many-to-many field"",
                    option=label,
                    obj=obj,
                    id=""admin.E038"",
                )
            related_admin = obj.admin_site._registry.get(field.remote_field.model)
            if related_admin is None:
                return [
                    checks.Error(
                        'An admin for model ""%s"" has to be registered '
                        ""to be referenced by %s.autocomplete_fields.""
                        % (
                            field.remote_field.model.__name__,
                            type(obj).__name__,
                        ),
                        obj=obj.__class__,
                        id=""admin.E039"",
                    )
                ]
            elif not related_admin.search_fields:
                return [
                    checks.Error(
                        '%s must define ""search_fields"", because it\'s '
                        ""referenced by %s.autocomplete_fields.""
                        % (
                            related_admin.__class__.__name__,
                            type(obj).__name__,
                        ),
                        obj=obj.__class__,
                        id=""admin.E040"",
                    )
                ]
            return []

    def _check_raw_id_fields(self, obj):
        """"""Check that `raw_id_fields` only contains field names that are listed
        on the model.""""""

        if not isinstance(obj.raw_id_fields, (list, tuple)):
            return must_be(
                ""a list or tuple"", option=""raw_id_fields"", obj=obj, id=""admin.E001""
            )
        else:
            return list(
                chain.from_iterable(
                    self._check_raw_id_fields_item(
                        obj, field_name, ""raw_id_fields[%d]"" % index
                    )
                    for index, field_name in enumerate(obj.raw_id_fields)
                )
            )

    def _check_raw_id_fields_item(self, obj, field_name, label):
        """"""Check an item of `raw_id_fields`, i.e. check that field named
        `field_name` exists in model `model` and is a ForeignKey or a
        ManyToManyField.""""""

        try:
            field = obj.model._meta.get_field(field_name)
        except FieldDoesNotExist:
            return refer_to_missing_field(
                field=field_name, option=label, obj=obj, id=""admin.E002""
            )
        else:
            # Using attname is not supported.
            if field.name != field_name:
                return refer_to_missing_field(
                    field=field_name,
                    option=label,
                    obj=obj,
                    id=""admin.E002"",
                )
            if not field.many_to_many and not isinstance(field, models.ForeignKey):
                return must_be(
                    ""a foreign key or a many-to-many field"",
                    option=label,
                    obj=obj,
                    id=""admin.E003"",
                )
            else:
                return []

    def _check_fields(self, obj):
        """"""Check that `fields` only refer to existing fields, doesn't contain
        duplicates. Check if at most one of `fields` and `fieldsets` is defined.
        """"""

        if obj.fields is None:
            return []
        elif not isinstance(obj.fields, (list, tuple)):
            return must_be(""a list or tuple"", option=""fields"", obj=obj, id=""admin.E004"")
        elif obj.fieldsets:
            return [
                checks.Error(
                    ""Both 'fieldsets' and 'fields' are specified."",
                    obj=obj.__class__,
                    id=""admin.E005"",
                )
            ]
        fields = flatten(obj.fields)
        if len(fields) != len(set(fields)):
            return [
                checks.Error(
                    ""The value of 'fields' contains duplicate field(s)."",
                    obj=obj.__class__,
                    id=""admin.E006"",
                )
            ]

        return list(
            chain.from_iterable(
                self._check_field_spec(obj, field_name, ""fields"")
                for field_name in obj.fields
            )
        )

    def _check_fieldsets(self, obj):
        """"""Check that fieldsets is properly formatted and doesn't contain
        duplicates.""""""

        if obj.fieldsets is None:
            return []
        elif not isinstance(obj.fieldsets, (list, tuple)):
            return must_be(
                ""a list or tuple"", option=""fieldsets"", obj=obj, id=""admin.E007""
            )
        else:
            seen_fields = []
            return list(
                chain.from_iterable(
                    self._check_fieldsets_item(
                        obj, fieldset, ""fieldsets[%d]"" % index, seen_fields
                    )
                    for index, fieldset in enumerate(obj.fieldsets)
                )
            )

    def _check_fieldsets_item(self, obj, fieldset, label, seen_fields):
        """"""Check an item of `fieldsets`, i.e. check that this is a pair of a
        set name and a dictionary containing ""fields"" key.""""""

        if not isinstance(fieldset, (list, tuple)):
            return must_be(""a list or tuple"", option=label, obj=obj, id=""admin.E008"")
        elif len(fieldset) != 2:
            return must_be(""of length 2"", option=label, obj=obj, id=""admin.E009"")
        elif not isinstance(fieldset[1], dict):
            return must_be(
                ""a dictionary"", option=""%s[1]"" % label, obj=obj, id=""admin.E010""
            )
        elif ""fields"" not in fieldset[1]:
            return [
                checks.Error(
                    ""The value of '%s[1]' must contain the key 'fields'."" % label,
                    obj=obj.__class__,
                    id=""admin.E011"",
                )
            ]
        elif not isinstance(fieldset[1][""fields""], (list, tuple)):
            return must_be(
                ""a list or tuple"",
                option=""%s[1]['fields']"" % label,
                obj=obj,
                id=""admin.E008"",
            )

        seen_fields.extend(flatten(fieldset[1][""fields""]))
        if len(seen_fields) != len(set(seen_fields)):
            return [
                checks.Error(
                    ""There are duplicate field(s) in '%s[1]'."" % label,
                    obj=obj.__class__,
                    id=""admin.E012"",
                )
            ]
        return list(
            chain.from_iterable(
                self._check_field_spec(obj, fieldset_fields, '%s[1][""fields""]' % label)
                for fieldset_fields in fieldset[1][""fields""]
            )
        )

    def _check_field_spec(self, obj, fields, label):
        """"""`fields` should be an item of `fields` or an item of
        fieldset[1]['fields'] for any `fieldset` in `fieldsets`. It should be a
        field name or a tuple of field names.""""""

        if isinstance(fields, tuple):
            return list(
                chain.from_iterable(
                    self._check_field_spec_item(
                        obj, field_name, ""%s[%d]"" % (label, index)
                    )
                    for index, field_name in enumerate(fields)
                )
            )
        else:
            return self._check_field_spec_item(obj, fields, label)

    def _check_field_spec_item(self, obj, field_name, label):
        if field_name in obj.readonly_fields:
            # Stuff can be put in fields that isn't actually a model field if
            # it's in readonly_fields, readonly_fields will handle the
            # validation of such things.
            return []
        else:
            try:
                field = obj.model._meta.get_field(field_name)
            except FieldDoesNotExist:
                # If we can't find a field on the model that matches, it could
                # be an extra field on the form.
                return []
            else:
                if (
                    isinstance(field, models.ManyToManyField)
                    and not field.remote_field.through._meta.auto_created
                ):
                    return [
                        checks.Error(
                            ""The value of '%s' cannot include the ManyToManyField ""
                            ""'%s', because that field manually specifies a ""
                            ""relationship model."" % (label, field_name),
                            obj=obj.__class__,
                            id=""admin.E013"",
                        )
                    ]
                else:
                    return []

    def _check_exclude(self, obj):
        """"""Check that exclude is a sequence without duplicates.""""""

        if obj.exclude is None:  # default value is None
            return []
        elif not isinstance(obj.exclude, (list, tuple)):
            return must_be(
                ""a list or tuple"", option=""exclude"", obj=obj, id=""admin.E014""
            )
        elif len(obj.exclude) > len(set(obj.exclude)):
            return [
                checks.Error(
                    ""The value of 'exclude' contains duplicate field(s)."",
                    obj=obj.__class__,
                    id=""admin.E015"",
                )
            ]
        else:
            return []

    def _check_form(self, obj):
        """"""Check that form subclasses BaseModelForm.""""""
        if not _issubclass(obj.form, BaseModelForm):
            return must_inherit_from(
                parent=""BaseModelForm"", option=""form"", obj=obj, id=""admin.E016""
            )
        else:
            return []

    def _check_filter_vertical(self, obj):
        """"""Check that filter_vertical is a sequence of field names.""""""
        if not isinstance(obj.filter_vertical, (list, tuple)):
            return must_be(
                ""a list or tuple"", option=""filter_vertical"", obj=obj, id=""admin.E017""
            )
        else:
            return list(
                chain.from_iterable(
                    self._check_filter_item(
                        obj, field_name, ""filter_vertical[%d]"" % index
                    )
                    for index, field_name in enumerate(obj.filter_vertical)
                )
            )

    def _check_filter_horizontal(self, obj):
        """"""Check that filter_horizontal is a sequence of field names.""""""
        if not isinstance(obj.filter_horizontal, (list, tuple)):
            return must_be(
                ""a list or tuple"", option=""filter_horizontal"", obj=obj, id=""admin.E018""
            )
        else:
            return list(
                chain.from_iterable(
                    self._check_filter_item(
                        obj, field_name, ""filter_horizontal[%d]"" % index
                    )
                    for index, field_name in enumerate(obj.filter_horizontal)
                )
            )

    def _check_filter_item(self, obj, field_name, label):
        """"""Check one item of `filter_vertical` or `filter_horizontal`, i.e.
        check that given field exists and is a ManyToManyField.""""""

        try:
            field = obj.model._meta.get_field(field_name)
        except FieldDoesNotExist:
            return refer_to_missing_field(
                field=field_name, option=label, obj=obj, id=""admin.E019""
            )
        else:
            if not field.many_to_many:
                return must_be(
                    ""a many-to-many field"", option=label, obj=obj, id=""admin.E020""
                )
            else:
                return []

    def _check_radio_fields(self, obj):
        """"""Check that `radio_fields` is a dictionary.""""""
        if not isinstance(obj.radio_fields, dict):
            return must_be(
                ""a dictionary"", option=""radio_fields"", obj=obj, id=""admin.E021""
            )
        else:
            return list(
                chain.from_iterable(
                    self._check_radio_fields_key(obj, field_name, ""radio_fields"")
                    + self._check_radio_fields_value(
                        obj, val, 'radio_fields[""%s""]' % field_name
                    )
                    for field_name, val in obj.radio_fields.items()
                )
            )

    def _check_radio_fields_key(self, obj, field_name, label):
        """"""Check that a key of `radio_fields` dictionary is name of existing
        field and that the field is a ForeignKey or has `choices` defined.""""""

        try:
            field = obj.model._meta.get_field(field_name)
        except FieldDoesNotExist:
            return refer_to_missing_field(
                field=field_name, option=label, obj=obj, id=""admin.E022""
            )
        else:
            if not (isinstance(field, models.ForeignKey) or field.choices):
                return [
                    checks.Error(
                        ""The value of '%s' refers to '%s', which is not an ""
                        ""instance of ForeignKey, and does not have a 'choices' ""
                        ""definition."" % (label, field_name),
                        obj=obj.__class__,
                        id=""admin.E023"",
                    )
                ]
            else:
                return []

    def _check_radio_fields_value(self, obj, val, label):
        """"""Check type of a value of `radio_fields` dictionary.""""""

        from django.contrib.admin.options import HORIZONTAL, VERTICAL

        if val not in (HORIZONTAL, VERTICAL):
            return [
                checks.Error(
                    ""The value of '%s' must be either admin.HORIZONTAL or ""
                    ""admin.VERTICAL."" % label,
                    obj=obj.__class__,
                    id=""admin.E024"",
                )
            ]
        else:
            return []

    def _check_view_on_site_url(self, obj):
        if not callable(obj.view_on_site) and not isinstance(obj.view_on_site, bool):
            return [
                checks.Error(
                    ""The value of 'view_on_site' must be a callable or a boolean ""
                    ""value."",
                    obj=obj.__class__,
                    id=""admin.E025"",
                )
            ]
        else:
            return []

    def _check_prepopulated_fields(self, obj):
        """"""Check that `prepopulated_fields` is a dictionary containing allowed
        field types.""""""
        if not isinstance(obj.prepopulated_fields, dict):
            return must_be(
                ""a dictionary"", option=""prepopulated_fields"", obj=obj, id=""admin.E026""
            )
        else:
            return list(
                chain.from_iterable(
                    self._check_prepopulated_fields_key(
                        obj, field_name, ""prepopulated_fields""
                    )
                    + self._check_prepopulated_fields_value(
                        obj, val, 'prepopulated_fields[""%s""]' % field_name
                    )
                    for field_name, val in obj.prepopulated_fields.items()
                )
            )

    def _check_prepopulated_fields_key(self, obj, field_name, label):
        """"""Check a key of `prepopulated_fields` dictionary, i.e. check that it
        is a name of existing field and the field is one of the allowed types.
        """"""

        try:
            field = obj.model._meta.get_field(field_name)
        except FieldDoesNotExist:
            return refer_to_missing_field(
                field=field_name, option=label, obj=obj, id=""admin.E027""
            )
        else:
            if isinstance(
                field, (models.DateTimeField, models.ForeignKey, models.ManyToManyField)
            ):
                return [
                    checks.Error(
                        ""The value of '%s' refers to '%s', which must not be a ""
                        ""DateTimeField, a ForeignKey, a OneToOneField, or a ""
                        ""ManyToManyField."" % (label, field_name),
                        obj=obj.__class__,
                        id=""admin.E028"",
                    )
                ]
            else:
                return []

    def _check_prepopulated_fields_value(self, obj, val, label):
        """"""Check a value of `prepopulated_fields` dictionary, i.e. it's an
        iterable of existing fields.""""""

        if not isinstance(val, (list, tuple)):
            return must_be(""a list or tuple"", option=label, obj=obj, id=""admin.E029"")
        else:
            return list(
                chain.from_iterable(
                    self._check_prepopulated_fields_value_item(
                        obj, subfield_name, ""%s[%r]"" % (label, index)
                    )
                    for index, subfield_name in enumerate(val)
                )
            )

    def _check_prepopulated_fields_value_item(self, obj, field_name, label):
        """"""For `prepopulated_fields` equal to {""slug"": (""title"",)},
        `field_name` is ""title"".""""""

        try:
            obj.model._meta.get_field(field_name)
        except FieldDoesNotExist:
            return refer_to_missing_field(
                field=field_name, option=label, obj=obj, id=""admin.E030""
            )
        else:
            return []

    def _check_ordering(self, obj):
        """"""Check that ordering refers to existing fields or is random.""""""

        # ordering = None
        if obj.ordering is None:  # The default value is None
            return []
        elif not isinstance(obj.ordering, (list, tuple)):
            return must_be(
                ""a list or tuple"", option=""ordering"", obj=obj, id=""admin.E031""
            )
        else:
            return list(
                chain.from_iterable(
                    self._check_ordering_item(obj, field_name, ""ordering[%d]"" % index)
                    for index, field_name in enumerate(obj.ordering)
                )
            )

    def _check_ordering_item(self, obj, field_name, label):
        """"""Check that `ordering` refers to existing fields.""""""
        if isinstance(field_name, (Combinable, models.OrderBy)):
            if not isinstance(field_name, models.OrderBy):
                field_name = field_name.asc()
            if isinstance(field_name.expression, models.F):
                field_name = field_name.expression.name
            else:
                return []
        if field_name == ""?"" and len(obj.ordering) != 1:
            return [
                checks.Error(
                    ""The value of 'ordering' has the random ordering marker '?', ""
                    ""but contains other fields as well."",
                    hint='Either remove the ""?"", or remove the other fields.',
                    obj=obj.__class__,
                    id=""admin.E032"",
                )
            ]
        elif field_name == ""?"":
            return []
        elif LOOKUP_SEP in field_name:
            # Skip ordering in the format field1__field2 (FIXME: checking
            # this format would be nice, but it's a little fiddly).
            return []
        else:
            if field_name.startswith(""-""):
                field_name = field_name[1:]
            if field_name == ""pk"":
                return []
            try:
                obj.model._meta.get_field(field_name)
            except FieldDoesNotExist:
                return refer_to_missing_field(
                    field=field_name, option=label, obj=obj, id=""admin.E033""
                )
            else:
                return []

    def _check_readonly_fields(self, obj):
        """"""Check that readonly_fields refers to proper attribute or field.""""""

        if obj.readonly_fields == ():
            return []
        elif not isinstance(obj.readonly_fields, (list, tuple)):
            return must_be(
                ""a list or tuple"", option=""readonly_fields"", obj=obj, id=""admin.E034""
            )
        else:
            return list(
                chain.from_iterable(
                    self._check_readonly_fields_item(
                        obj, field_name, ""readonly_fields[%d]"" % index
                    )
                    for index, field_name in enumerate(obj.readonly_fields)
                )
            )

    def _check_readonly_fields_item(self, obj, field_name, label):
        if callable(field_name):
            return []
        elif hasattr(obj, field_name):
            return []
        elif hasattr(obj.model, field_name):
            return []
        else:
            try:
                obj.model._meta.get_field(field_name)
            except FieldDoesNotExist:
                return [
                    checks.Error(
                        ""The value of '%s' is not a callable, an attribute of ""
                        ""'%s', or an attribute of '%s'.""
                        % (
                            label,
                            obj.__class__.__name__,
                            obj.model._meta.label,
                        ),
                        obj=obj.__class__,
                        id=""admin.E035"",
                    )
                ]
            else:
                return []


class ModelAdminChecks(BaseModelAdminChecks):
    def check(self, admin_obj, **kwargs):
        return [
            *super().check(admin_obj),
            *self._check_save_as(admin_obj),
            *self._check_save_on_top(admin_obj),
            *self._check_inlines(admin_obj),
            *self._check_list_display(admin_obj),
            *self._check_list_display_links(admin_obj),
            *self._check_list_filter(admin_obj),
            *self._check_list_select_related(admin_obj),
            *self._check_list_per_page(admin_obj),
            *self._check_list_max_show_all(admin_obj),
            *self._check_list_editable(admin_obj),
            *self._check_search_fields(admin_obj),
            *self._check_date_hierarchy(admin_obj),
            *self._check_action_permission_methods(admin_obj),
            *self._check_actions_uniqueness(admin_obj),
        ]

    def _check_save_as(self, obj):
        """"""Check save_as is a boolean.""""""

        if not isinstance(obj.save_as, bool):
            return must_be(""a boolean"", option=""save_as"", obj=obj, id=""admin.E101"")
        else:
            return []

    def _check_save_on_top(self, obj):
        """"""Check save_on_top is a boolean.""""""

        if not isinstance(obj.save_on_top, bool):
            return must_be(""a boolean"", option=""save_on_top"", obj=obj, id=""admin.E102"")
        else:
            return []

    def _check_inlines(self, obj):
        """"""Check all inline model admin classes.""""""

        if not isinstance(obj.inlines, (list, tuple)):
            return must_be(
                ""a list or tuple"", option=""inlines"", obj=obj, id=""admin.E103""
            )
        else:
            return list(
                chain.from_iterable(
                    self._check_inlines_item(obj, item, ""inlines[%d]"" % index)
                    for index, item in enumerate(obj.inlines)
                )
            )

    def _check_inlines_item(self, obj, inline, label):
        """"""Check one inline model admin.""""""
        try:
            inline_label = inline.__module__ + ""."" + inline.__name__
        except AttributeError:
            return [
                checks.Error(
                    ""'%s' must inherit from 'InlineModelAdmin'."" % obj,
                    obj=obj.__class__,
                    id=""admin.E104"",
                )
            ]

        from django.contrib.admin.options import InlineModelAdmin

        if not _issubclass(inline, InlineModelAdmin):
            return [
                checks.Error(
                    ""'%s' must inherit from 'InlineModelAdmin'."" % inline_label,
                    obj=obj.__class__,
                    id=""admin.E104"",
                )
            ]
        elif not inline.model:
            return [
                checks.Error(
                    ""'%s' must have a 'model' attribute."" % inline_label,
                    obj=obj.__class__,
                    id=""admin.E105"",
                )
            ]
        elif not _issubclass(inline.model, models.Model):
            return must_be(
                ""a Model"", option=""%s.model"" % inline_label, obj=obj, id=""admin.E106""
            )
        else:
            return inline(obj.model, obj.admin_site).check()

    def _check_list_display(self, obj):
        """"""Check that list_display only contains fields or usable attributes.""""""

        if not isinstance(obj.list_display, (list, tuple)):
            return must_be(
                ""a list or tuple"", option=""list_display"", obj=obj, id=""admin.E107""
            )
        else:
            return list(
                chain.from_iterable(
                    self._check_list_display_item(obj, item, ""list_display[%d]"" % index)
                    for index, item in enumerate(obj.list_display)
                )
            )

    def _check_list_display_item(self, obj, item, label):
        if callable(item):
            return []
        elif hasattr(obj, item):
            return []
        try:
            field = obj.model._meta.get_field(item)
        except FieldDoesNotExist:
            try:
                field = getattr(obj.model, item)
            except AttributeError:
                return [
                    checks.Error(
                        ""The value of '%s' refers to '%s', which is not a ""
                        ""callable, an attribute of '%s', or an attribute or ""
                        ""method on '%s'.""
                        % (
                            label,
                            item,
                            obj.__class__.__name__,
                            obj.model._meta.label,
                        ),
                        obj=obj.__class__,
                        id=""admin.E108"",
                    )
                ]
        if isinstance(field, models.ManyToManyField):
            return [
                checks.Error(
                    ""The value of '%s' must not be a ManyToManyField."" % label,
                    obj=obj.__class__,
                    id=""admin.E109"",
                )
            ]
        return []

    def _check_list_display_links(self, obj):
        """"""Check that list_display_links is a unique subset of list_display.""""""
        from django.contrib.admin.options import ModelAdmin

        if obj.list_display_links is None:
            return []
        elif not isinstance(obj.list_display_links, (list, tuple)):
            return must_be(
                ""a list, a tuple, or None"",
                option=""list_display_links"",
                obj=obj,
                id=""admin.E110"",
            )
        # Check only if ModelAdmin.get_list_display() isn't overridden.
        elif obj.get_list_display.__func__ is ModelAdmin.get_list_display:
            return list(
                chain.from_iterable(
                    self._check_list_display_links_item(
                        obj, field_name, ""list_display_links[%d]"" % index
                    )
                    for index, field_name in enumerate(obj.list_display_links)
                )
            )
        return []

    def _check_list_display_links_item(self, obj, field_name, label):
        if field_name not in obj.list_display:
            return [
                checks.Error(
                    ""The value of '%s' refers to '%s', which is not defined in ""
                    ""'list_display'."" % (label, field_name),
                    obj=obj.__class__,
                    id=""admin.E111"",
                )
            ]
        else:
            return []

    def _check_list_filter(self, obj):
        if not isinstance(obj.list_filter, (list, tuple)):
            return must_be(
                ""a list or tuple"", option=""list_filter"", obj=obj, id=""admin.E112""
            )
        else:
            return list(
                chain.from_iterable(
                    self._check_list_filter_item(obj, item, ""list_filter[%d]"" % index)
                    for index, item in enumerate(obj.list_filter)
                )
            )

    def _check_list_filter_item(self, obj, item, label):
        """"""
        Check one item of `list_filter`, i.e. check if it is one of three options:
        1. 'field' -- a basic field filter, possibly w/ relationships (e.g.
           'field__rel')
        2. ('field', SomeFieldListFilter) - a field-based list filter class
        3. SomeListFilter - a non-field list filter class
        """"""
        from django.contrib.admin import FieldListFilter, ListFilter

        if callable(item) and not isinstance(item, models.Field):
            # If item is option 3, it should be a ListFilter...
            if not _issubclass(item, ListFilter):
                return must_inherit_from(
                    parent=""ListFilter"", option=label, obj=obj, id=""admin.E113""
                )
            # ...  but not a FieldListFilter.
            elif issubclass(item, FieldListFilter):
                return [
                    checks.Error(
                        ""The value of '%s' must not inherit from 'FieldListFilter'.""
                        % label,
                        obj=obj.__class__,
                        id=""admin.E114"",
                    )
                ]
            else:
                return []
        elif isinstance(item, (tuple, list)):
            # item is option #2
            field, list_filter_class = item
            if not _issubclass(list_filter_class, FieldListFilter):
                return must_inherit_from(
                    parent=""FieldListFilter"",
                    option=""%s[1]"" % label,
                    obj=obj,
                    id=""admin.E115"",
                )
            else:
                return []
        else:
            # item is option #1
            field = item

            # Validate the field string
            try:
                get_fields_from_path(obj.model, field)
            except (NotRelationField, FieldDoesNotExist):
                return [
                    checks.Error(
                        ""The value of '%s' refers to '%s', which does not refer to a ""
                        ""Field."" % (label, field),
                        obj=obj.__class__,
                        id=""admin.E116"",
                    )
                ]
            else:
                return []

    def _check_list_select_related(self, obj):
        """"""Check that list_select_related is a boolean, a list or a tuple.""""""

        if not isinstance(obj.list_select_related, (bool, list, tuple)):
            return must_be(
                ""a boolean, tuple or list"",
                option=""list_select_related"",
                obj=obj,
                id=""admin.E117"",
            )
        else:
            return []

    def _check_list_per_page(self, obj):
        """"""Check that list_per_page is an integer.""""""

        if not isinstance(obj.list_per_page, int):
            return must_be(
                ""an integer"", option=""list_per_page"", obj=obj, id=""admin.E118""
            )
        else:
            return []

    def _check_list_max_show_all(self, obj):
        """"""Check that list_max_show_all is an integer.""""""

        if not isinstance(obj.list_max_show_all, int):
            return must_be(
                ""an integer"", option=""list_max_show_all"", obj=obj, id=""admin.E119""
            )
        else:
            return []

    def _check_list_editable(self, obj):
        """"""Check that list_editable is a sequence of editable fields from
        list_display without first element.""""""

        if not isinstance(obj.list_editable, (list, tuple)):
            return must_be(
                ""a list or tuple"", option=""list_editable"", obj=obj, id=""admin.E120""
            )
        else:
            return list(
                chain.from_iterable(
                    self._check_list_editable_item(
                        obj, item, ""list_editable[%d]"" % index
                    )
                    for index, item in enumerate(obj.list_editable)
                )
            )

    def _check_list_editable_item(self, obj, field_name, label):
        try:
            field = obj.model._meta.get_field(field_name)
        except FieldDoesNotExist:
            return refer_to_missing_field(
                field=field_name, option=label, obj=obj, id=""admin.E121""
            )
        else:
            if field_name not in obj.list_display:
                return [
                    checks.Error(
                        ""The value of '%s' refers to '%s', which is not ""
                        ""contained in 'list_display'."" % (label, field_name),
                        obj=obj.__class__,
                        id=""admin.E122"",
                    )
                ]
            elif obj.list_display_links and field_name in obj.list_display_links:
                return [
                    checks.Error(
                        ""The value of '%s' cannot be in both 'list_editable' and ""
                        ""'list_display_links'."" % field_name,
                        obj=obj.__class__,
                        id=""admin.E123"",
                    )
                ]
            # If list_display[0] is in list_editable, check that
            # list_display_links is set. See #22792 and #26229 for use cases.
            elif (
                obj.list_display[0] == field_name
                and not obj.list_display_links
                and obj.list_display_links is not None
            ):
                return [
                    checks.Error(
                        ""The value of '%s' refers to the first field in 'list_display' ""
                        ""('%s'), which cannot be used unless 'list_display_links' is ""
                        ""set."" % (label, obj.list_display[0]),
                        obj=obj.__class__,
                        id=""admin.E124"",
                    )
                ]
            elif not field.editable:
                return [
                    checks.Error(
                        ""The value of '%s' refers to '%s', which is not editable ""
                        ""through the admin."" % (label, field_name),
                        obj=obj.__class__,
                        id=""admin.E125"",
                    )
                ]
            else:
                return []

    def _check_search_fields(self, obj):
        """"""Check search_fields is a sequence.""""""

        if not isinstance(obj.search_fields, (list, tuple)):
            return must_be(
                ""a list or tuple"", option=""search_fields"", obj=obj, id=""admin.E126""
            )
        else:
            return []

    def _check_date_hierarchy(self, obj):
        """"""Check that date_hierarchy refers to DateField or DateTimeField.""""""

        if obj.date_hierarchy is None:
            return []
        else:
            try:
                field = get_fields_from_path(obj.model, obj.date_hierarchy)[-1]
            except (NotRelationField, FieldDoesNotExist):
                return [
                    checks.Error(
                        ""The value of 'date_hierarchy' refers to '%s', which ""
                        ""does not refer to a Field."" % obj.date_hierarchy,
                        obj=obj.__class__,
                        id=""admin.E127"",
                    )
                ]
            else:
                if not isinstance(field, (models.DateField, models.DateTimeField)):
                    return must_be(
                        ""a DateField or DateTimeField"",
                        option=""date_hierarchy"",
                        obj=obj,
                        id=""admin.E128"",
                    )
                else:
                    return []

    def _check_action_permission_methods(self, obj):
        """"""
        Actions with an allowed_permission attribute require the ModelAdmin to
        implement a has_<perm>_permission() method for each permission.
        """"""
        actions = obj._get_base_actions()
        errors = []
        for func, name, _ in actions:
            if not hasattr(func, ""allowed_permissions""):
                continue
            for permission in func.allowed_permissions:
                method_name = ""has_%s_permission"" % permission
                if not hasattr(obj, method_name):
                    errors.append(
                        checks.Error(
                            ""%s must define a %s() method for the %s action.""
                            % (
                                obj.__class__.__name__,
                                method_name,
                                func.__name__,
                            ),
                            obj=obj.__class__,
                            id=""admin.E129"",
                        )
                    )
        return errors

    def _check_actions_uniqueness(self, obj):
        """"""Check that every action has a unique __name__.""""""
        errors = []
        names = collections.Counter(name for _, name, _ in obj._get_base_actions())
        for name, count in names.items():
            if count > 1:
                errors.append(
                    checks.Error(
                        ""__name__ attributes of actions defined in %s must be ""
                        ""unique. Name %r is not unique.""
                        % (
                            obj.__class__.__name__,
                            name,
                        ),
                        obj=obj.__class__,
                        id=""admin.E130"",
                    )
                )
        return errors


class InlineModelAdminChecks(BaseModelAdminChecks):
    def check(self, inline_obj, **kwargs):
        parent_model = inline_obj.parent_model
        return [
            *super().check(inline_obj),
            *self._check_relation(inline_obj, parent_model),
            *self._check_exclude_of_parent_model(inline_obj, parent_model),
            *self._check_extra(inline_obj),
            *self._check_max_num(inline_obj),
            *self._check_min_num(inline_obj),
            *self._check_formset(inline_obj),
        ]

    def _check_exclude_of_parent_model(self, obj, parent_model):
        # Do not perform more specific checks if the base checks result in an
        # error.
        errors = super()._check_exclude(obj)
        if errors:
            return []

        # Skip if `fk_name` is invalid.
        if self._check_relation(obj, parent_model):
            return []

        if obj.exclude is None:
            return []

        fk = _get_foreign_key(parent_model, obj.model, fk_name=obj.fk_name)
        if fk.name in obj.exclude:
            return [
                checks.Error(
                    ""Cannot exclude the field '%s', because it is the foreign key ""
                    ""to the parent model '%s'.""
                    % (
                        fk.name,
                        parent_model._meta.label,
                    ),
                    obj=obj.__class__,
                    id=""admin.E201"",
                )
            ]
        else:
            return []

    def _check_relation(self, obj, parent_model):
        try:
            _get_foreign_key(parent_model, obj.model, fk_name=obj.fk_name)
        except ValueError as e:
            return [checks.Error(e.args[0], obj=obj.__class__, id=""admin.E202"")]
        else:
            return []

    def _check_extra(self, obj):
        """"""Check that extra is an integer.""""""

        if not isinstance(obj.extra, int):
            return must_be(""an integer"", option=""extra"", obj=obj, id=""admin.E203"")
        else:
            return []

    def _check_max_num(self, obj):
        """"""Check that max_num is an integer.""""""

        if obj.max_num is None:
            return []
        elif not isinstance(obj.max_num, int):
            return must_be(""an integer"", option=""max_num"", obj=obj, id=""admin.E204"")
        else:
            return []

    def _check_min_num(self, obj):
        """"""Check that min_num is an integer.""""""

        if obj.min_num is None:
            return []
        elif not isinstance(obj.min_num, int):
            return must_be(""an integer"", option=""min_num"", obj=obj, id=""admin.E205"")
        else:
            return []

    def _check_formset(self, obj):
        """"""Check formset is a subclass of BaseModelFormSet.""""""

        if not _issubclass(obj.formset, BaseModelFormSet):
            return must_inherit_from(
                parent=""BaseModelFormSet"", option=""formset"", obj=obj, id=""admin.E206""
            )
        else:
            return []


def must_be(type, option, obj, id):
    return [
        checks.Error(
            ""The value of '%s' must be %s."" % (option, type),
            obj=obj.__class__,
            id=id,
        ),
    ]


def must_inherit_from(parent, option, obj, id):
    return [
        checks.Error(
            ""The value of '%s' must inherit from '%s'."" % (option, parent),
            obj=obj.__class__,
            id=id,
        ),
    ]


def refer_to_missing_field(field, option, obj, id):
    return [
        checks.Error(
            ""The value of '%s' refers to '%s', which is not a field of '%s'.""
            % (option, field, obj.model._meta.label),
            obj=obj.__class__,
            id=id,
        ),
    ]<EOS>"
"<BOS>""""""
Form Widget classes specific to the Django admin site.
""""""
import copy
import json

from django import forms
from django.conf import settings
from django.core.exceptions import ValidationError
from django.core.validators import URLValidator
from django.db.models import CASCADE, UUIDField
from django.urls import reverse
from django.urls.exceptions import NoReverseMatch
from django.utils.html import smart_urlquote
from django.utils.http import urlencode
from django.utils.text import Truncator
from django.utils.translation import get_language
from django.utils.translation import gettext as _


class FilteredSelectMultiple(forms.SelectMultiple):
    """"""
    A SelectMultiple with a JavaScript filter interface.

    Note that the resulting JavaScript assumes that the jsi18n
    catalog has been loaded in the page
    """"""

    class Media:
        js = [
            ""admin/js/core.js"",
            ""admin/js/SelectBox.js"",
            ""admin/js/SelectFilter2.js"",
        ]

    def __init__(self, verbose_name, is_stacked, attrs=None, choices=()):
        self.verbose_name = verbose_name
        self.is_stacked = is_stacked
        super().__init__(attrs, choices)

    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
        context[""widget""][""attrs""][""class""] = ""selectfilter""
        if self.is_stacked:
            context[""widget""][""attrs""][""class""] += ""stacked""
        context[""widget""][""attrs""][""data-field-name""] = self.verbose_name
        context[""widget""][""attrs""][""data-is-stacked""] = int(self.is_stacked)
        return context


class AdminDateWidget(forms.DateInput):
    class Media:
        js = [
            ""admin/js/calendar.js"",
            ""admin/js/admin/DateTimeShortcuts.js"",
        ]

    def __init__(self, attrs=None, format=None):
        attrs = {""class"": ""vDateField"", ""size"": ""10"", **(attrs or {})}
        super().__init__(attrs=attrs, format=format)


class AdminTimeWidget(forms.TimeInput):
    class Media:
        js = [
            ""admin/js/calendar.js"",
            ""admin/js/admin/DateTimeShortcuts.js"",
        ]

    def __init__(self, attrs=None, format=None):
        attrs = {""class"": ""vTimeField"", ""size"": ""8"", **(attrs or {})}
        super().__init__(attrs=attrs, format=format)


class AdminSplitDateTime(forms.SplitDateTimeWidget):
    """"""
    A SplitDateTime Widget that has some admin-specific styling.
    """"""

    template_name = ""admin/widgets/split_datetime.html""

    def __init__(self, attrs=None):
        widgets = [AdminDateWidget, AdminTimeWidget]
        # Note that we're calling MultiWidget, not SplitDateTimeWidget, because
        # we want to define widgets.
        forms.MultiWidget.__init__(self, widgets, attrs)

    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
        context[""date_label""] = _(""Date:"")
        context[""time_label""] = _(""Time:"")
        return context


class AdminRadioSelect(forms.RadioSelect):
    template_name = ""admin/widgets/radio.html""


class AdminFileWidget(forms.ClearableFileInput):
    template_name = ""admin/widgets/clearable_file_input.html""


def url_params_from_lookup_dict(lookups):
    """"""
    Convert the type of lookups specified in a ForeignKey limit_choices_to
    attribute to a dictionary of query parameters
    """"""
    params = {}
    if lookups and hasattr(lookups, ""items""):
        for k, v in lookups.items():
            if callable(v):
                v = v()
            if isinstance(v, (tuple, list)):
                v = "","".join(str(x) for x in v)
            elif isinstance(v, bool):
                v = (""0"", ""1"")[v]
            else:
                v = str(v)
            params[k] = v
    return params


class ForeignKeyRawIdWidget(forms.TextInput):
    """"""
    A Widget for displaying ForeignKeys in the ""raw_id"" interface rather than
    in a <select> box.
    """"""

    template_name = ""admin/widgets/foreign_key_raw_id.html""

    def __init__(self, rel, admin_site, attrs=None, using=None):
        self.rel = rel
        self.admin_site = admin_site
        self.db = using
        super().__init__(attrs)

    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
        rel_to = self.rel.model
        if rel_to in self.admin_site._registry:
            # The related object is registered with the same AdminSite
            related_url = reverse(
                ""admin:%s_%s_changelist""
                % (
                    rel_to._meta.app_label,
                    rel_to._meta.model_name,
                ),
                current_app=self.admin_site.name,
            )

            params = self.url_parameters()
            if params:
                related_url += ""?"" + urlencode(params)
            context[""related_url""] = related_url
            context[""link_title""] = _(""Lookup"")
            # The JavaScript code looks for this class.
            css_class = ""vForeignKeyRawIdAdminField""
            if isinstance(self.rel.get_related_field(), UUIDField):
                css_class += "" vUUIDField""
            context[""widget""][""attrs""].setdefault(""class"", css_class)
        else:
            context[""related_url""] = None
        if context[""widget""][""value""]:
            context[""link_label""], context[""link_url""] = self.label_and_url_for_value(
                value
            )
        else:
            context[""link_label""] = None
        return context

    def base_url_parameters(self):
        limit_choices_to = self.rel.limit_choices_to
        if callable(limit_choices_to):
            limit_choices_to = limit_choices_to()
        return url_params_from_lookup_dict(limit_choices_to)

    def url_parameters(self):
        from django.contrib.admin.views.main import TO_FIELD_VAR

        params = self.base_url_parameters()
        params.update({TO_FIELD_VAR: self.rel.get_related_field().name})
        return params

    def label_and_url_for_value(self, value):
        key = self.rel.get_related_field().name
        try:
            obj = self.rel.model._default_manager.using(self.db).get(**{key: value})
        except (ValueError, self.rel.model.DoesNotExist, ValidationError):
            return """", """"

        try:
            url = reverse(
                ""%s:%s_%s_change""
                % (
                    self.admin_site.name,
                    obj._meta.app_label,
                    obj._meta.object_name.lower(),
                ),
                args=(obj.pk,),
            )
        except NoReverseMatch:
            url = """"  # Admin not registered for target model.

        return Truncator(obj).words(14), url


class ManyToManyRawIdWidget(ForeignKeyRawIdWidget):
    """"""
    A Widget for displaying ManyToMany ids in the ""raw_id"" interface rather than
    in a <select multiple> box.
    """"""

    template_name = ""admin/widgets/many_to_many_raw_id.html""

    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
        if self.rel.model in self.admin_site._registry:
            # The related object is registered with the same AdminSite
            context[""widget""][""attrs""][""class""] = ""vManyToManyRawIdAdminField""
        return context

    def url_parameters(self):
        return self.base_url_parameters()

    def label_and_url_for_value(self, value):
        return """", """"

    def value_from_datadict(self, data, files, name):
        value = data.get(name)
        if value:
            return value.split("","")

    def format_value(self, value):
        return "","".join(str(v) for v in value) if value else """"


class RelatedFieldWidgetWrapper(forms.Widget):
    """"""
    This class is a wrapper to a given widget to add the add icon for the
    admin interface.
    """"""

    template_name = ""admin/widgets/related_widget_wrapper.html""

    def __init__(
        self,
        widget,
        rel,
        admin_site,
        can_add_related=None,
        can_change_related=False,
        can_delete_related=False,
        can_view_related=False,
    ):
        self.needs_multipart_form = widget.needs_multipart_form
        self.attrs = widget.attrs
        self.choices = widget.choices
        self.widget = widget
        self.rel = rel
        # Backwards compatible check for whether a user can add related
        # objects.
        if can_add_related is None:
            can_add_related = rel.model in admin_site._registry
        self.can_add_related = can_add_related
        # XXX: The UX does not support multiple selected values.
        multiple = getattr(widget, ""allow_multiple_selected"", False)
        self.can_change_related = not multiple and can_change_related
        # XXX: The deletion UX can be confusing when dealing with cascading deletion.
        cascade = getattr(rel, ""on_delete"", None) is CASCADE
        self.can_delete_related = not multiple and not cascade and can_delete_related
        self.can_view_related = not multiple and can_view_related
        # so we can check if the related object is registered with this AdminSite
        self.admin_site = admin_site

    def __deepcopy__(self, memo):
        obj = copy.copy(self)
        obj.widget = copy.deepcopy(self.widget, memo)
        obj.attrs = self.widget.attrs
        memo[id(self)] = obj
        return obj

    @property
    def is_hidden(self):
        return self.widget.is_hidden

    @property
    def media(self):
        return self.widget.media

    def get_related_url(self, info, action, *args):
        return reverse(
            ""admin:%s_%s_%s"" % (info + (action,)),
            current_app=self.admin_site.name,
            args=args,
        )

    def get_context(self, name, value, attrs):
        from django.contrib.admin.views.main import IS_POPUP_VAR, TO_FIELD_VAR

        rel_opts = self.rel.model._meta
        info = (rel_opts.app_label, rel_opts.model_name)
        self.widget.choices = self.choices
        related_field_name = self.rel.get_related_field().name
        url_params = ""&"".join(
            ""%s=%s"" % param
            for param in [
                (TO_FIELD_VAR, related_field_name),
                (IS_POPUP_VAR, 1),
            ]
        )
        context = {
            ""rendered_widget"": self.widget.render(name, value, attrs),
            ""is_hidden"": self.is_hidden,
            ""name"": name,
            ""url_params"": url_params,
            ""model"": rel_opts.verbose_name,
            ""can_add_related"": self.can_add_related,
            ""can_change_related"": self.can_change_related,
            ""can_delete_related"": self.can_delete_related,
            ""can_view_related"": self.can_view_related,
        }
        if self.can_add_related:
            context[""add_related_url""] = self.get_related_url(info, ""add"")
        if self.can_delete_related:
            context[""delete_related_template_url""] = self.get_related_url(
                info, ""delete"", ""__fk__""
            )
        if self.can_view_related or self.can_change_related:
            context[""view_related_url_params""] = f""{TO_FIELD_VAR}={related_field_name}""
            context[""change_related_template_url""] = self.get_related_url(
                info, ""change"", ""__fk__""
            )
        return context

    def value_from_datadict(self, data, files, name):
        return self.widget.value_from_datadict(data, files, name)

    def value_omitted_from_data(self, data, files, name):
        return self.widget.value_omitted_from_data(data, files, name)

    def id_for_label(self, id_):
        return self.widget.id_for_label(id_)


class AdminTextareaWidget(forms.Textarea):
    def __init__(self, attrs=None):
        super().__init__(attrs={""class"": ""vLargeTextField"", **(attrs or {})})


class AdminTextInputWidget(forms.TextInput):
    def __init__(self, attrs=None):
        super().__init__(attrs={""class"": ""vTextField"", **(attrs or {})})


class AdminEmailInputWidget(forms.EmailInput):
    def __init__(self, attrs=None):
        super().__init__(attrs={""class"": ""vTextField"", **(attrs or {})})


class AdminURLFieldWidget(forms.URLInput):
    template_name = ""admin/widgets/url.html""

    def __init__(self, attrs=None, validator_class=URLValidator):
        super().__init__(attrs={""class"": ""vURLField"", **(attrs or {})})
        self.validator = validator_class()

    def get_context(self, name, value, attrs):
        try:
            self.validator(value if value else """")
            url_valid = True
        except ValidationError:
            url_valid = False
        context = super().get_context(name, value, attrs)
        context[""current_label""] = _(""Currently:"")
        context[""change_label""] = _(""Change:"")
        context[""widget""][""href""] = (
            smart_urlquote(context[""widget""][""value""]) if value else """"
        )
        context[""url_valid""] = url_valid
        return context


class AdminIntegerFieldWidget(forms.NumberInput):
    class_name = ""vIntegerField""

    def __init__(self, attrs=None):
        super().__init__(attrs={""class"": self.class_name, **(attrs or {})})


class AdminBigIntegerFieldWidget(AdminIntegerFieldWidget):
    class_name = ""vBigIntegerField""


class AdminUUIDInputWidget(forms.TextInput):
    def __init__(self, attrs=None):
        super().__init__(attrs={""class"": ""vUUIDField"", **(attrs or {})})


# Mapping of lowercase language codes [returned by Django's get_language()] to
# language codes supported by select2.
# See django/contrib/admin/static/admin/js/vendor/select2/i18n/*
SELECT2_TRANSLATIONS = {
    x.lower(): x
    for x in [
        ""ar"",
        ""az"",
        ""bg"",
        ""ca"",
        ""cs"",
        ""da"",
        ""de"",
        ""el"",
        ""en"",
        ""es"",
        ""et"",
        ""eu"",
        ""fa"",
        ""fi"",
        ""fr"",
        ""gl"",
        ""he"",
        ""hi"",
        ""hr"",
        ""hu"",
        ""id"",
        ""is"",
        ""it"",
        ""ja"",
        ""km"",
        ""ko"",
        ""lt"",
        ""lv"",
        ""mk"",
        ""ms"",
        ""nb"",
        ""nl"",
        ""pl"",
        ""pt-BR"",
        ""pt"",
        ""ro"",
        ""ru"",
        ""sk"",
        ""sr-Cyrl"",
        ""sr"",
        ""sv"",
        ""th"",
        ""tr"",
        ""uk"",
        ""vi"",
    ]
}
SELECT2_TRANSLATIONS.update({""zh-hans"": ""zh-CN"", ""zh-hant"": ""zh-TW""})


def get_select2_language():
    lang_code = get_language()
    supported_code = SELECT2_TRANSLATIONS.get(lang_code)
    if supported_code is None:
        # If 'zh-hant-tw' is not supported, try subsequent language codes i.e.
        # 'zh-hant' and 'zh'.
        i = None
        while (i := lang_code.rfind(""-"", 0, i)) > -1:
            if supported_code := SELECT2_TRANSLATIONS.get(lang_code[:i]):
                return supported_code
    return supported_code


class AutocompleteMixin:
    """"""
    Select widget mixin that loads options from AutocompleteJsonView via AJAX.

    Renders the necessary data attributes for select2 and adds the static form
    media.
    """"""

    url_name = ""%s:autocomplete""

    def __init__(self, field, admin_site, attrs=None, choices=(), using=None):
        self.field = field
        self.admin_site = admin_site
        self.db = using
        self.choices = choices
        self.attrs = {} if attrs is None else attrs.copy()
        self.i18n_name = get_select2_language()

    def get_url(self):
        return reverse(self.url_name % self.admin_site.name)

    def build_attrs(self, base_attrs, extra_attrs=None):
        """"""
        Set select2's AJAX attributes.

        Attributes can be set using the html5 data attribute.
        Nested attributes require a double dash as per
        https://select2.org/configuration/data-attributes#nested-subkey-options
        """"""
        attrs = super().build_attrs(base_attrs, extra_attrs=extra_attrs)
        attrs.setdefault(""class"", """")
        attrs.update(
            {
                ""data-ajax--cache"": ""true"",
                ""data-ajax--delay"": 250,
                ""data-ajax--type"": ""GET"",
                ""data-ajax--url"": self.get_url(),
                ""data-app-label"": self.field.model._meta.app_label,
                ""data-model-name"": self.field.model._meta.model_name,
                ""data-field-name"": self.field.name,
                ""data-theme"": ""admin-autocomplete"",
                ""data-allow-clear"": json.dumps(not self.is_required),
                ""data-placeholder"": """",  # Allows clearing of the input.
                ""lang"": self.i18n_name,
                ""class"": attrs[""class""]
                + ("" "" if attrs[""class""] else """")
                + ""admin-autocomplete"",
            }
        )
        return attrs

    def optgroups(self, name, value, attr=None):
        """"""Return selected options based on the ModelChoiceIterator.""""""
        default = (None, [], 0)
        groups = [default]
        has_selected = False
        selected_choices = {
            str(v) for v in value if str(v) not in self.choices.field.empty_values
        }
        if not self.is_required and not self.allow_multiple_selected:
            default[1].append(self.create_option(name, """", """", False, 0))
        remote_model_opts = self.field.remote_field.model._meta
        to_field_name = getattr(
            self.field.remote_field, ""field_name"", remote_model_opts.pk.attname
        )
        to_field_name = remote_model_opts.get_field(to_field_name).attname
        choices = (
            (getattr(obj, to_field_name), self.choices.field.label_from_instance(obj))
            for obj in self.choices.queryset.using(self.db).filter(
                **{""%s__in"" % to_field_name: selected_choices}
            )
        )
        for option_value, option_label in choices:
            selected = str(option_value) in value and (
                has_selected is False or self.allow_multiple_selected
            )
            has_selected |= selected
            index = len(default[1])
            subgroup = default[1]
            subgroup.append(
                self.create_option(
                    name, option_value, option_label, selected_choices, index
                )
            )
        return groups

    @property
    def media(self):
        extra = """" if settings.DEBUG else "".min""
        i18n_file = (
            (""admin/js/vendor/select2/i18n/%s.js"" % self.i18n_name,)
            if self.i18n_name
            else ()
        )
        return forms.Media(
            js=(
                ""admin/js/vendor/jquery/jquery%s.js"" % extra,
                ""admin/js/vendor/select2/select2.full%s.js"" % extra,
            )
            + i18n_file
            + (
                ""admin/js/jquery.init.js"",
                ""admin/js/autocomplete.js"",
            ),
            css={
                ""screen"": (
                    ""admin/css/vendor/select2/select2%s.css"" % extra,
                    ""admin/css/autocomplete.css"",
                ),
            },
        )


class AutocompleteSelect(AutocompleteMixin, forms.Select):
    pass


class AutocompleteSelectMultiple(AutocompleteMixin, forms.SelectMultiple):
    pass<EOS>"
"<BOS>from django.core.exceptions import SuspiciousOperation


class DisallowedModelAdminLookup(SuspiciousOperation):
    """"""Invalid filter was passed to admin view via URL querystring""""""

    pass


class DisallowedModelAdminToField(SuspiciousOperation):
    """"""Invalid to_field was passed to admin view via URL query string""""""

    pass<EOS>"
"<BOS>import json

from django import forms
from django.contrib.admin.utils import (
    display_for_field,
    flatten_fieldsets,
    help_text_for_field,
    label_for_field,
    lookup_field,
    quote,
)
from django.core.exceptions import ObjectDoesNotExist
from django.db.models.fields.related import (
    ForeignObjectRel,
    ManyToManyRel,
    OneToOneField,
)
from django.forms.utils import flatatt
from django.template.defaultfilters import capfirst, linebreaksbr
from django.urls import NoReverseMatch, reverse
from django.utils.html import conditional_escape, format_html
from django.utils.safestring import mark_safe
from django.utils.translation import gettext
from django.utils.translation import gettext_lazy as _

ACTION_CHECKBOX_NAME = ""_selected_action""


class ActionForm(forms.Form):
    action = forms.ChoiceField(label=_(""Action:""))
    select_across = forms.BooleanField(
        label="""",
        required=False,
        initial=0,
        widget=forms.HiddenInput({""class"": ""select-across""}),
    )


checkbox = forms.CheckboxInput({""class"": ""action-select""}, lambda value: False)


class AdminForm:
    def __init__(
        self,
        form,
        fieldsets,
        prepopulated_fields,
        readonly_fields=None,
        model_admin=None,
    ):
        self.form, self.fieldsets = form, fieldsets
        self.prepopulated_fields = [
            {""field"": form[field_name], ""dependencies"": [form[f] for f in dependencies]}
            for field_name, dependencies in prepopulated_fields.items()
        ]
        self.model_admin = model_admin
        if readonly_fields is None:
            readonly_fields = ()
        self.readonly_fields = readonly_fields

    def __repr__(self):
        return (
            f""<{self.__class__.__qualname__}: ""
            f""form={self.form.__class__.__qualname__} ""
            f""fieldsets={self.fieldsets!r}>""
        )

    def __iter__(self):
        for name, options in self.fieldsets:
            yield Fieldset(
                self.form,
                name,
                readonly_fields=self.readonly_fields,
                model_admin=self.model_admin,
                **options,
            )

    @property
    def errors(self):
        return self.form.errors

    @property
    def non_field_errors(self):
        return self.form.non_field_errors

    @property
    def fields(self):
        return self.form.fields

    @property
    def is_bound(self):
        return self.form.is_bound

    @property
    def media(self):
        media = self.form.media
        for fs in self:
            media = media + fs.media
        return media


class Fieldset:
    def __init__(
        self,
        form,
        name=None,
        readonly_fields=(),
        fields=(),
        classes=(),
        description=None,
        model_admin=None,
    ):
        self.form = form
        self.name, self.fields = name, fields
        self.classes = "" "".join(classes)
        self.description = description
        self.model_admin = model_admin
        self.readonly_fields = readonly_fields

    @property
    def media(self):
        if ""collapse"" in self.classes:
            return forms.Media(js=[""admin/js/collapse.js""])
        return forms.Media()

    def __iter__(self):
        for field in self.fields:
            yield Fieldline(
                self.form, field, self.readonly_fields, model_admin=self.model_admin
            )


class Fieldline:
    def __init__(self, form, field, readonly_fields=None, model_admin=None):
        self.form = form  # A django.forms.Form instance
        if not hasattr(field, ""__iter__"") or isinstance(field, str):
            self.fields = [field]
        else:
            self.fields = field
        self.has_visible_field = not all(
            field in self.form.fields and self.form.fields[field].widget.is_hidden
            for field in self.fields
        )
        self.model_admin = model_admin
        if readonly_fields is None:
            readonly_fields = ()
        self.readonly_fields = readonly_fields

    def __iter__(self):
        for i, field in enumerate(self.fields):
            if field in self.readonly_fields:
                yield AdminReadonlyField(
                    self.form, field, is_first=(i == 0), model_admin=self.model_admin
                )
            else:
                yield AdminField(self.form, field, is_first=(i == 0))

    def errors(self):
        return mark_safe(
            ""\n"".join(
                self.form[f].errors.as_ul()
                for f in self.fields
                if f not in self.readonly_fields
            ).strip(""\n"")
        )


class AdminField:
    def __init__(self, form, field, is_first):
        self.field = form[field]  # A django.forms.BoundField instance
        self.is_first = is_first  # Whether this field is first on the line
        self.is_checkbox = isinstance(self.field.field.widget, forms.CheckboxInput)
        self.is_readonly = False

    def label_tag(self):
        classes = []
        contents = conditional_escape(self.field.label)
        if self.is_checkbox:
            classes.append(""vCheckboxLabel"")

        if self.field.field.required:
            classes.append(""required"")
        if not self.is_first:
            classes.append(""inline"")
        attrs = {""class"": "" "".join(classes)} if classes else {}
        # checkboxes should not have a label suffix as the checkbox appears
        # to the left of the label.
        return self.field.label_tag(
            contents=mark_safe(contents),
            attrs=attrs,
            label_suffix="""" if self.is_checkbox else None,
        )

    def errors(self):
        return mark_safe(self.field.errors.as_ul())


class AdminReadonlyField:
    def __init__(self, form, field, is_first, model_admin=None):
        # Make self.field look a little bit like a field. This means that
        # {{ field.name }} must be a useful class name to identify the field.
        # For convenience, store other field-related data here too.
        if callable(field):
            class_name = field.__name__ if field.__name__ != ""<lambda>"" else """"
        else:
            class_name = field

        if form._meta.labels and class_name in form._meta.labels:
            label = form._meta.labels[class_name]
        else:
            label = label_for_field(field, form._meta.model, model_admin, form=form)

        if form._meta.help_texts and class_name in form._meta.help_texts:
            help_text = form._meta.help_texts[class_name]
        else:
            help_text = help_text_for_field(class_name, form._meta.model)

        if field in form.fields:
            is_hidden = form.fields[field].widget.is_hidden
        else:
            is_hidden = False

        self.field = {
            ""name"": class_name,
            ""label"": label,
            ""help_text"": help_text,
            ""field"": field,
            ""is_hidden"": is_hidden,
        }
        self.form = form
        self.model_admin = model_admin
        self.is_first = is_first
        self.is_checkbox = False
        self.is_readonly = True
        self.empty_value_display = model_admin.get_empty_value_display()

    def label_tag(self):
        attrs = {}
        if not self.is_first:
            attrs[""class""] = ""inline""
        label = self.field[""label""]
        return format_html(
            ""<label{}>{}{}</label>"",
            flatatt(attrs),
            capfirst(label),
            self.form.label_suffix,
        )

    def get_admin_url(self, remote_field, remote_obj):
        url_name = ""admin:%s_%s_change"" % (
            remote_field.model._meta.app_label,
            remote_field.model._meta.model_name,
        )
        try:
            url = reverse(
                url_name,
                args=[quote(remote_obj.pk)],
                current_app=self.model_admin.admin_site.name,
            )
            return format_html('<a href=""{}"">{}</a>', url, remote_obj)
        except NoReverseMatch:
            return str(remote_obj)

    def contents(self):
        from django.contrib.admin.templatetags.admin_list import _boolean_icon

        field, obj, model_admin = (
            self.field[""field""],
            self.form.instance,
            self.model_admin,
        )
        try:
            f, attr, value = lookup_field(field, obj, model_admin)
        except (AttributeError, ValueError, ObjectDoesNotExist):
            result_repr = self.empty_value_display
        else:
            if field in self.form.fields:
                widget = self.form[field].field.widget
                # This isn't elegant but suffices for contrib.auth's
                # ReadOnlyPasswordHashWidget.
                if getattr(widget, ""read_only"", False):
                    return widget.render(field, value)
            if f is None:
                if getattr(attr, ""boolean"", False):
                    result_repr = _boolean_icon(value)
                else:
                    if hasattr(value, ""__html__""):
                        result_repr = value
                    else:
                        result_repr = linebreaksbr(value)
            else:
                if isinstance(f.remote_field, ManyToManyRel) and value is not None:
                    result_repr = "", "".join(map(str, value.all()))
                elif (
                    isinstance(f.remote_field, (ForeignObjectRel, OneToOneField))
                    and value is not None
                ):
                    result_repr = self.get_admin_url(f.remote_field, value)
                else:
                    result_repr = display_for_field(value, f, self.empty_value_display)
                result_repr = linebreaksbr(result_repr)
        return conditional_escape(result_repr)


class InlineAdminFormSet:
    """"""
    A wrapper around an inline formset for use in the admin system.
    """"""

    def __init__(
        self,
        inline,
        formset,
        fieldsets,
        prepopulated_fields=None,
        readonly_fields=None,
        model_admin=None,
        has_add_permission=True,
        has_change_permission=True,
        has_delete_permission=True,
        has_view_permission=True,
    ):
        self.opts = inline
        self.formset = formset
        self.fieldsets = fieldsets
        self.model_admin = model_admin
        if readonly_fields is None:
            readonly_fields = ()
        self.readonly_fields = readonly_fields
        if prepopulated_fields is None:
            prepopulated_fields = {}
        self.prepopulated_fields = prepopulated_fields
        self.classes = "" "".join(inline.classes) if inline.classes else """"
        self.has_add_permission = has_add_permission
        self.has_change_permission = has_change_permission
        self.has_delete_permission = has_delete_permission
        self.has_view_permission = has_view_permission

    def __iter__(self):
        if self.has_change_permission:
            readonly_fields_for_editing = self.readonly_fields
        else:
            readonly_fields_for_editing = self.readonly_fields + flatten_fieldsets(
                self.fieldsets
            )

        for form, original in zip(
            self.formset.initial_forms, self.formset.get_queryset()
        ):
            view_on_site_url = self.opts.get_view_on_site_url(original)
            yield InlineAdminForm(
                self.formset,
                form,
                self.fieldsets,
                self.prepopulated_fields,
                original,
                readonly_fields_for_editing,
                model_admin=self.opts,
                view_on_site_url=view_on_site_url,
            )
        for form in self.formset.extra_forms:
            yield InlineAdminForm(
                self.formset,
                form,
                self.fieldsets,
                self.prepopulated_fields,
                None,
                self.readonly_fields,
                model_admin=self.opts,
            )
        if self.has_add_permission:
            yield InlineAdminForm(
                self.formset,
                self.formset.empty_form,
                self.fieldsets,
                self.prepopulated_fields,
                None,
                self.readonly_fields,
                model_admin=self.opts,
            )

    def fields(self):
        fk = getattr(self.formset, ""fk"", None)
        empty_form = self.formset.empty_form
        meta_labels = empty_form._meta.labels or {}
        meta_help_texts = empty_form._meta.help_texts or {}
        for i, field_name in enumerate(flatten_fieldsets(self.fieldsets)):
            if fk and fk.name == field_name:
                continue
            if not self.has_change_permission or field_name in self.readonly_fields:
                form_field = empty_form.fields.get(field_name)
                widget_is_hidden = False
                if form_field is not None:
                    widget_is_hidden = form_field.widget.is_hidden
                yield {
                    ""name"": field_name,
                    ""label"": meta_labels.get(field_name)
                    or label_for_field(
                        field_name,
                        self.opts.model,
                        self.opts,
                        form=empty_form,
                    ),
                    ""widget"": {""is_hidden"": widget_is_hidden},
                    ""required"": False,
                    ""help_text"": meta_help_texts.get(field_name)
                    or help_text_for_field(field_name, self.opts.model),
                }
            else:
                form_field = empty_form.fields[field_name]
                label = form_field.label
                if label is None:
                    label = label_for_field(
                        field_name, self.opts.model, self.opts, form=empty_form
                    )
                yield {
                    ""name"": field_name,
                    ""label"": label,
                    ""widget"": form_field.widget,
                    ""required"": form_field.required,
                    ""help_text"": form_field.help_text,
                }

    def inline_formset_data(self):
        verbose_name = self.opts.verbose_name
        return json.dumps(
            {
                ""name"": ""#%s"" % self.formset.prefix,
                ""options"": {
                    ""prefix"": self.formset.prefix,
                    ""addText"": gettext(""Add another %(verbose_name)s"")
                    % {
                        ""verbose_name"": capfirst(verbose_name),
                    },
                    ""deleteText"": gettext(""Remove""),
                },
            }
        )

    @property
    def forms(self):
        return self.formset.forms

    @property
    def non_form_errors(self):
        return self.formset.non_form_errors

    @property
    def is_bound(self):
        return self.formset.is_bound

    @property
    def total_form_count(self):
        return self.formset.total_form_count

    @property
    def media(self):
        media = self.opts.media + self.formset.media
        for fs in self:
            media = media + fs.media
        return media


class InlineAdminForm(AdminForm):
    """"""
    A wrapper around an inline form for use in the admin system.
    """"""

    def __init__(
        self,
        formset,
        form,
        fieldsets,
        prepopulated_fields,
        original,
        readonly_fields=None,
        model_admin=None,
        view_on_site_url=None,
    ):
        self.formset = formset
        self.model_admin = model_admin
        self.original = original
        self.show_url = original and view_on_site_url is not None
        self.absolute_url = view_on_site_url
        super().__init__(
            form, fieldsets, prepopulated_fields, readonly_fields, model_admin
        )

    def __iter__(self):
        for name, options in self.fieldsets:
            yield InlineFieldset(
                self.formset,
                self.form,
                name,
                self.readonly_fields,
                model_admin=self.model_admin,
                **options,
            )

    def needs_explicit_pk_field(self):
        return (
            # Auto fields are editable, so check for auto or non-editable pk.
            self.form._meta.model._meta.auto_field
            or not self.form._meta.model._meta.pk.editable
            or
            # Also search any parents for an auto field. (The pk info is
            # propagated to child models so that does not need to be checked
            # in parents.)
            any(
                parent._meta.auto_field or not parent._meta.model._meta.pk.editable
                for parent in self.form._meta.model._meta.get_parent_list()
            )
        )

    def pk_field(self):
        return AdminField(self.form, self.formset._pk_field.name, False)

    def fk_field(self):
        fk = getattr(self.formset, ""fk"", None)
        if fk:
            return AdminField(self.form, fk.name, False)
        else:
            return """"

    def deletion_field(self):
        from django.forms.formsets import DELETION_FIELD_NAME

        return AdminField(self.form, DELETION_FIELD_NAME, False)

    def ordering_field(self):
        from django.forms.formsets import ORDERING_FIELD_NAME

        return AdminField(self.form, ORDERING_FIELD_NAME, False)


class InlineFieldset(Fieldset):
    def __init__(self, formset, *args, **kwargs):
        self.formset = formset
        super().__init__(*args, **kwargs)

    def __iter__(self):
        fk = getattr(self.formset, ""fk"", None)
        for field in self.fields:
            if not fk or fk.name != field:
                yield Fieldline(
                    self.form, field, self.readonly_fields, model_admin=self.model_admin
                )


class AdminErrorList(forms.utils.ErrorList):
    """"""Store errors for the form/formsets in an add/change view.""""""

    def __init__(self, form, inline_formsets):
        super().__init__()

        if form.is_bound:
            self.extend(form.errors.values())
            for inline_formset in inline_formsets:
                self.extend(inline_formset.non_form_errors())
                for errors_in_inline_form in inline_formset.errors:
                    self.extend(errors_in_inline_form.values())<EOS>"
"<BOS>""""""
Built-in, globally-available admin actions.
""""""

from django.contrib import messages
from django.contrib.admin import helpers
from django.contrib.admin.decorators import action
from django.contrib.admin.utils import model_ngettext
from django.core.exceptions import PermissionDenied
from django.template.response import TemplateResponse
from django.utils.translation import gettext as _
from django.utils.translation import gettext_lazy


@action(
    permissions=[""delete""],
    description=gettext_lazy(""Delete selected %(verbose_name_plural)s""),
)
def delete_selected(modeladmin, request, queryset):
    """"""
    Default action which deletes the selected objects.

    This action first displays a confirmation page which shows all the
    deletable objects, or, if the user has no permission one of the related
    childs (foreignkeys), a ""permission denied"" message.

    Next, it deletes all selected objects and redirects back to the change list.
    """"""
    opts = modeladmin.model._meta
    app_label = opts.app_label

    # Populate deletable_objects, a data structure of all related objects that
    # will also be deleted.
    (
        deletable_objects,
        model_count,
        perms_needed,
        protected,
    ) = modeladmin.get_deleted_objects(queryset, request)

    # The user has already confirmed the deletion.
    # Do the deletion and return None to display the change list view again.
    if request.POST.get(""post"") and not protected:
        if perms_needed:
            raise PermissionDenied
        n = queryset.count()
        if n:
            for obj in queryset:
                obj_display = str(obj)
                modeladmin.log_deletion(request, obj, obj_display)
            modeladmin.delete_queryset(request, queryset)
            modeladmin.message_user(
                request,
                _(""Successfully deleted %(count)d %(items)s."")
                % {""count"": n, ""items"": model_ngettext(modeladmin.opts, n)},
                messages.SUCCESS,
            )
        # Return None to display the change list page again.
        return None

    objects_name = model_ngettext(queryset)

    if perms_needed or protected:
        title = _(""Cannot delete %(name)s"") % {""name"": objects_name}
    else:
        title = _(""Are you sure?"")

    context = {
        **modeladmin.admin_site.each_context(request),
        ""title"": title,
        ""subtitle"": None,
        ""objects_name"": str(objects_name),
        ""deletable_objects"": [deletable_objects],
        ""model_count"": dict(model_count).items(),
        ""queryset"": queryset,
        ""perms_lacking"": perms_needed,
        ""protected"": protected,
        ""opts"": opts,
        ""action_checkbox_name"": helpers.ACTION_CHECKBOX_NAME,
        ""media"": modeladmin.media,
    }

    request.current_app = modeladmin.admin_site.name

    # Display the confirmation page
    return TemplateResponse(
        request,
        modeladmin.delete_selected_confirmation_template
        or [
            ""admin/%s/%s/delete_selected_confirmation.html""
            % (app_label, opts.model_name),
            ""admin/%s/delete_selected_confirmation.html"" % app_label,
            ""admin/delete_selected_confirmation.html"",
        ],
        context,
    )<EOS>"
"<BOS>import re
from functools import update_wrapper
from weakref import WeakSet

from django.apps import apps
from django.conf import settings
from django.contrib.admin import ModelAdmin, actions
from django.contrib.admin.views.autocomplete import AutocompleteJsonView
from django.contrib.auth import REDIRECT_FIELD_NAME
from django.core.exceptions import ImproperlyConfigured
from django.db.models.base import ModelBase
from django.http import Http404, HttpResponsePermanentRedirect, HttpResponseRedirect
from django.template.response import TemplateResponse
from django.urls import NoReverseMatch, Resolver404, resolve, reverse
from django.utils.decorators import method_decorator
from django.utils.functional import LazyObject
from django.utils.module_loading import import_string
from django.utils.text import capfirst
from django.utils.translation import gettext as _
from django.utils.translation import gettext_lazy
from django.views.decorators.cache import never_cache
from django.views.decorators.common import no_append_slash
from django.views.decorators.csrf import csrf_protect
from django.views.i18n import JavaScriptCatalog

all_sites = WeakSet()


class AlreadyRegistered(Exception):
    pass


class NotRegistered(Exception):
    pass


class AdminSite:
    """"""
    An AdminSite object encapsulates an instance of the Django admin application, ready
    to be hooked in to your URLconf. Models are registered with the AdminSite using the
    register() method, and the get_urls() method can then be used to access Django view
    functions that present a full admin interface for the collection of registered
    models.
    """"""

    # Text to put at the end of each page's <title>.
    site_title = gettext_lazy(""Django site admin"")

    # Text to put in each page's <h1>.
    site_header = gettext_lazy(""Django administration"")

    # Text to put at the top of the admin index page.
    index_title = gettext_lazy(""Site administration"")

    # URL for the ""View site"" link at the top of each admin page.
    site_url = ""/""

    enable_nav_sidebar = True

    empty_value_display = ""-""

    login_form = None
    index_template = None
    app_index_template = None
    login_template = None
    logout_template = None
    password_change_template = None
    password_change_done_template = None

    final_catch_all_view = True

    def __init__(self, name=""admin""):
        self._registry = {}  # model_class class -> admin_class instance
        self.name = name
        self._actions = {""delete_selected"": actions.delete_selected}
        self._global_actions = self._actions.copy()
        all_sites.add(self)

    def __repr__(self):
        return f""{self.__class__.__name__}(name={self.name!r})""

    def check(self, app_configs):
        """"""
        Run the system checks on all ModelAdmins, except if they aren't
        customized at all.
        """"""
        if app_configs is None:
            app_configs = apps.get_app_configs()
        app_configs = set(app_configs)  # Speed up lookups below

        errors = []
        modeladmins = (
            o for o in self._registry.values() if o.__class__ is not ModelAdmin
        )
        for modeladmin in modeladmins:
            if modeladmin.model._meta.app_config in app_configs:
                errors.extend(modeladmin.check())
        return errors

    def register(self, model_or_iterable, admin_class=None, **options):
        """"""
        Register the given model(s) with the given admin class.

        The model(s) should be Model classes, not instances.

        If an admin class isn't given, use ModelAdmin (the default admin
        options). If keyword arguments are given -- e.g., list_display --
        apply them as options to the admin class.

        If a model is already registered, raise AlreadyRegistered.

        If a model is abstract, raise ImproperlyConfigured.
        """"""
        admin_class = admin_class or ModelAdmin
        if isinstance(model_or_iterable, ModelBase):
            model_or_iterable = [model_or_iterable]
        for model in model_or_iterable:
            if model._meta.abstract:
                raise ImproperlyConfigured(
                    ""The model %s is abstract, so it cannot be registered with admin.""
                    % model.__name__
                )

            if model in self._registry:
                registered_admin = str(self._registry[model])
                msg = ""The model %s is already registered "" % model.__name__
                if registered_admin.endswith("".ModelAdmin""):
                    # Most likely registered without a ModelAdmin subclass.
                    msg += ""in app %r."" % re.sub(r""\.ModelAdmin$"", """", registered_admin)
                else:
                    msg += ""with %r."" % registered_admin
                raise AlreadyRegistered(msg)

            # Ignore the registration if the model has been
            # swapped out.
            if not model._meta.swapped:
                # If we got **options then dynamically construct a subclass of
                # admin_class with those **options.
                if options:
                    # For reasons I don't quite understand, without a __module__
                    # the created class appears to ""live"" in the wrong place,
                    # which causes issues later on.
                    options[""__module__""] = __name__
                    admin_class = type(
                        ""%sAdmin"" % model.__name__, (admin_class,), options
                    )

                # Instantiate the admin class to save in the registry
                self._registry[model] = admin_class(model, self)

    def unregister(self, model_or_iterable):
        """"""
        Unregister the given model(s).

        If a model isn't already registered, raise NotRegistered.
        """"""
        if isinstance(model_or_iterable, ModelBase):
            model_or_iterable = [model_or_iterable]
        for model in model_or_iterable:
            if model not in self._registry:
                raise NotRegistered(""The model %s is not registered"" % model.__name__)
            del self._registry[model]

    def is_registered(self, model):
        """"""
        Check if a model class is registered with this `AdminSite`.
        """"""
        return model in self._registry

    def add_action(self, action, name=None):
        """"""
        Register an action to be available globally.
        """"""
        name = name or action.__name__
        self._actions[name] = action
        self._global_actions[name] = action

    def disable_action(self, name):
        """"""
        Disable a globally-registered action. Raise KeyError for invalid names.
        """"""
        del self._actions[name]

    def get_action(self, name):
        """"""
        Explicitly get a registered global action whether it's enabled or
        not. Raise KeyError for invalid names.
        """"""
        return self._global_actions[name]

    @property
    def actions(self):
        """"""
        Get all the enabled actions as an iterable of (name, func).
        """"""
        return self._actions.items()

    def has_permission(self, request):
        """"""
        Return True if the given HttpRequest has permission to view
        *at least one* page in the admin site.
        """"""
        return request.user.is_active and request.user.is_staff

    def admin_view(self, view, cacheable=False):
        """"""
        Decorator to create an admin view attached to this ``AdminSite``. This
        wraps the view and provides permission checking by calling
        ``self.has_permission``.

        You'll want to use this from within ``AdminSite.get_urls()``:

            class MyAdminSite(AdminSite):

                def get_urls(self):
                    from django.urls import path

                    urls = super().get_urls()
                    urls += [
                        path('my_view/', self.admin_view(some_view))
                    ]
                    return urls

        By default, admin_views are marked non-cacheable using the
        ``never_cache`` decorator. If the view can be safely cached, set
        cacheable=True.
        """"""

        def inner(request, *args, **kwargs):
            if not self.has_permission(request):
                if request.path == reverse(""admin:logout"", current_app=self.name):
                    index_path = reverse(""admin:index"", current_app=self.name)
                    return HttpResponseRedirect(index_path)
                # Inner import to prevent django.contrib.admin (app) from
                # importing django.contrib.auth.models.User (unrelated model).
                from django.contrib.auth.views import redirect_to_login

                return redirect_to_login(
                    request.get_full_path(),
                    reverse(""admin:login"", current_app=self.name),
                )
            return view(request, *args, **kwargs)

        if not cacheable:
            inner = never_cache(inner)
        # We add csrf_protect here so this function can be used as a utility
        # function for any view, without having to repeat 'csrf_protect'.
        if not getattr(view, ""csrf_exempt"", False):
            inner = csrf_protect(inner)
        return update_wrapper(inner, view)

    def get_urls(self):
        # Since this module gets imported in the application's root package,
        # it cannot import models from other applications at the module level,
        # and django.contrib.contenttypes.views imports ContentType.
        from django.contrib.contenttypes import views as contenttype_views
        from django.urls import include, path, re_path

        def wrap(view, cacheable=False):
            def wrapper(*args, **kwargs):
                return self.admin_view(view, cacheable)(*args, **kwargs)

            wrapper.admin_site = self
            return update_wrapper(wrapper, view)

        # Admin-site-wide views.
        urlpatterns = [
            path("""", wrap(self.index), name=""index""),
            path(""login/"", self.login, name=""login""),
            path(""logout/"", wrap(self.logout), name=""logout""),
            path(
                ""password_change/"",
                wrap(self.password_change, cacheable=True),
                name=""password_change"",
            ),
            path(
                ""password_change/done/"",
                wrap(self.password_change_done, cacheable=True),
                name=""password_change_done"",
            ),
            path(""autocomplete/"", wrap(self.autocomplete_view), name=""autocomplete""),
            path(""jsi18n/"", wrap(self.i18n_javascript, cacheable=True), name=""jsi18n""),
            path(
                ""r/<int:content_type_id>/<path:object_id>/"",
                wrap(contenttype_views.shortcut),
                name=""view_on_site"",
            ),
        ]

        # Add in each model's views, and create a list of valid URLS for the
        # app_index
        valid_app_labels = []
        for model, model_admin in self._registry.items():
            urlpatterns += [
                path(
                    ""%s/%s/"" % (model._meta.app_label, model._meta.model_name),
                    include(model_admin.urls),
                ),
            ]
            if model._meta.app_label not in valid_app_labels:
                valid_app_labels.append(model._meta.app_label)

        # If there were ModelAdmins registered, we should have a list of app
        # labels for which we need to allow access to the app_index view,
        if valid_app_labels:
            regex = r""^(?P<app_label>"" + ""|"".join(valid_app_labels) + "")/$""
            urlpatterns += [
                re_path(regex, wrap(self.app_index), name=""app_list""),
            ]

        if self.final_catch_all_view:
            urlpatterns.append(re_path(r""(?P<url>.*)$"", wrap(self.catch_all_view)))

        return urlpatterns

    @property
    def urls(self):
        return self.get_urls(), ""admin"", self.name

    def each_context(self, request):
        """"""
        Return a dictionary of variables to put in the template context for
        *every* page in the admin site.

        For sites running on a subpath, use the SCRIPT_NAME value if site_url
        hasn't been customized.
        """"""
        script_name = request.META[""SCRIPT_NAME""]
        site_url = (
            script_name if self.site_url == ""/"" and script_name else self.site_url
        )
        return {
            ""site_title"": self.site_title,
            ""site_header"": self.site_header,
            ""site_url"": site_url,
            ""has_permission"": self.has_permission(request),
            ""available_apps"": self.get_app_list(request),
            ""is_popup"": False,
            ""is_nav_sidebar_enabled"": self.enable_nav_sidebar,
        }

    def password_change(self, request, extra_context=None):
        """"""
        Handle the ""change password"" task -- both form display and validation.
        """"""
        from django.contrib.admin.forms import AdminPasswordChangeForm
        from django.contrib.auth.views import PasswordChangeView

        url = reverse(""admin:password_change_done"", current_app=self.name)
        defaults = {
            ""form_class"": AdminPasswordChangeForm,
            ""success_url"": url,
            ""extra_context"": {**self.each_context(request), **(extra_context or {})},
        }
        if self.password_change_template is not None:
            defaults[""template_name""] = self.password_change_template
        request.current_app = self.name
        return PasswordChangeView.as_view(**defaults)(request)

    def password_change_done(self, request, extra_context=None):
        """"""
        Display the ""success"" page after a password change.
        """"""
        from django.contrib.auth.views import PasswordChangeDoneView

        defaults = {
            ""extra_context"": {**self.each_context(request), **(extra_context or {})},
        }
        if self.password_change_done_template is not None:
            defaults[""template_name""] = self.password_change_done_template
        request.current_app = self.name
        return PasswordChangeDoneView.as_view(**defaults)(request)

    def i18n_javascript(self, request, extra_context=None):
        """"""
        Display the i18n JavaScript that the Django admin requires.

        `extra_context` is unused but present for consistency with the other
        admin views.
        """"""
        return JavaScriptCatalog.as_view(packages=[""django.contrib.admin""])(request)

    def logout(self, request, extra_context=None):
        """"""
        Log out the user for the given HttpRequest.

        This should *not* assume the user is already logged in.
        """"""
        from django.contrib.auth.views import LogoutView

        defaults = {
            ""extra_context"": {
                **self.each_context(request),
                # Since the user isn't logged out at this point, the value of
                # has_permission must be overridden.
                ""has_permission"": False,
                **(extra_context or {}),
            },
        }
        if self.logout_template is not None:
            defaults[""template_name""] = self.logout_template
        request.current_app = self.name
        return LogoutView.as_view(**defaults)(request)

    @method_decorator(never_cache)
    def login(self, request, extra_context=None):
        """"""
        Display the login form for the given HttpRequest.
        """"""
        if request.method == ""GET"" and self.has_permission(request):
            # Already logged-in, redirect to admin index
            index_path = reverse(""admin:index"", current_app=self.name)
            return HttpResponseRedirect(index_path)

        # Since this module gets imported in the application's root package,
        # it cannot import models from other applications at the module level,
        # and django.contrib.admin.forms eventually imports User.
        from django.contrib.admin.forms import AdminAuthenticationForm
        from django.contrib.auth.views import LoginView

        context = {
            **self.each_context(request),
            ""title"": _(""Log in""),
            ""subtitle"": None,
            ""app_path"": request.get_full_path(),
            ""username"": request.user.get_username(),
        }
        if (
            REDIRECT_FIELD_NAME not in request.GET
            and REDIRECT_FIELD_NAME not in request.POST
        ):
            context[REDIRECT_FIELD_NAME] = reverse(""admin:index"", current_app=self.name)
        context.update(extra_context or {})

        defaults = {
            ""extra_context"": context,
            ""authentication_form"": self.login_form or AdminAuthenticationForm,
            ""template_name"": self.login_template or ""admin/login.html"",
        }
        request.current_app = self.name
        return LoginView.as_view(**defaults)(request)

    def autocomplete_view(self, request):
        return AutocompleteJsonView.as_view(admin_site=self)(request)

    @no_append_slash
    def catch_all_view(self, request, url):
        if settings.APPEND_SLASH and not url.endswith(""/""):
            urlconf = getattr(request, ""urlconf"", None)
            try:
                match = resolve(""%s/"" % request.path_info, urlconf)
            except Resolver404:
                pass
            else:
                if getattr(match.func, ""should_append_slash"", True):
                    return HttpResponsePermanentRedirect(""%s/"" % request.path)
        raise Http404

    def _build_app_dict(self, request, label=None):
        """"""
        Build the app dictionary. The optional `label` parameter filters models
        of a specific app.
        """"""
        app_dict = {}

        if label:
            models = {
                m: m_a
                for m, m_a in self._registry.items()
                if m._meta.app_label == label
            }
        else:
            models = self._registry

        for model, model_admin in models.items():
            app_label = model._meta.app_label

            has_module_perms = model_admin.has_module_permission(request)
            if not has_module_perms:
                continue

            perms = model_admin.get_model_perms(request)

            # Check whether user has any perm for this module.
            # If so, add the module to the model_list.
            if True not in perms.values():
                continue

            info = (app_label, model._meta.model_name)
            model_dict = {
                ""model"": model,
                ""name"": capfirst(model._meta.verbose_name_plural),
                ""object_name"": model._meta.object_name,
                ""perms"": perms,
                ""admin_url"": None,
                ""add_url"": None,
            }
            if perms.get(""change"") or perms.get(""view""):
                model_dict[""view_only""] = not perms.get(""change"")
                try:
                    model_dict[""admin_url""] = reverse(
                        ""admin:%s_%s_changelist"" % info, current_app=self.name
                    )
                except NoReverseMatch:
                    pass
            if perms.get(""add""):
                try:
                    model_dict[""add_url""] = reverse(
                        ""admin:%s_%s_add"" % info, current_app=self.name
                    )
                except NoReverseMatch:
                    pass

            if app_label in app_dict:
                app_dict[app_label][""models""].append(model_dict)
            else:
                app_dict[app_label] = {
                    ""name"": apps.get_app_config(app_label).verbose_name,
                    ""app_label"": app_label,
                    ""app_url"": reverse(
                        ""admin:app_list"",
                        kwargs={""app_label"": app_label},
                        current_app=self.name,
                    ),
                    ""has_module_perms"": has_module_perms,
                    ""models"": [model_dict],
                }

        if label:
            return app_dict.get(label)
        return app_dict

    def get_app_list(self, request):
        """"""
        Return a sorted list of all the installed apps that have been
        registered in this site.
        """"""
        app_dict = self._build_app_dict(request)

        # Sort the apps alphabetically.
        app_list = sorted(app_dict.values(), key=lambda x: x[""name""].lower())

        # Sort the models alphabetically within each app.
        for app in app_list:
            app[""models""].sort(key=lambda x: x[""name""])

        return app_list

    def index(self, request, extra_context=None):
        """"""
        Display the main admin index page, which lists all of the installed
        apps that have been registered in this site.
        """"""
        app_list = self.get_app_list(request)

        context = {
            **self.each_context(request),
            ""title"": self.index_title,
            ""subtitle"": None,
            ""app_list"": app_list,
            **(extra_context or {}),
        }

        request.current_app = self.name

        return TemplateResponse(
            request, self.index_template or ""admin/index.html"", context
        )

    def app_index(self, request, app_label, extra_context=None):
        app_dict = self._build_app_dict(request, app_label)
        if not app_dict:
            raise Http404(""The requested admin page does not exist."")
        # Sort the models alphabetically within each app.
        app_dict[""models""].sort(key=lambda x: x[""name""])
        context = {
            **self.each_context(request),
            ""title"": _(""%(app)s administration"") % {""app"": app_dict[""name""]},
            ""subtitle"": None,
            ""app_list"": [app_dict],
            ""app_label"": app_label,
            **(extra_context or {}),
        }

        request.current_app = self.name

        return TemplateResponse(
            request,
            self.app_index_template
            or [""admin/%s/app_index.html"" % app_label, ""admin/app_index.html""],
            context,
        )


class DefaultAdminSite(LazyObject):
    def _setup(self):
        AdminSiteClass = import_string(apps.get_app_config(""admin"").default_site)
        self._wrapped = AdminSiteClass()

    def __repr__(self):
        return repr(self._wrapped)


# This global object represents the default admin site, for the common case.
# You can provide your own AdminSite using the (Simple)AdminConfig.default_site
# attribute. You can also instantiate AdminSite in your own code to create a
# custom admin site.
site = DefaultAdminSite()<EOS>"
"<BOS>import json

from django.conf import settings
from django.contrib.admin.utils import quote
from django.contrib.contenttypes.models import ContentType
from django.db import models
from django.urls import NoReverseMatch, reverse
from django.utils import timezone
from django.utils.text import get_text_list
from django.utils.translation import gettext
from django.utils.translation import gettext_lazy as _

ADDITION = 1
CHANGE = 2
DELETION = 3

ACTION_FLAG_CHOICES = (
    (ADDITION, _(""Addition"")),
    (CHANGE, _(""Change"")),
    (DELETION, _(""Deletion"")),
)


class LogEntryManager(models.Manager):
    use_in_migrations = True

    def log_action(
        self,
        user_id,
        content_type_id,
        object_id,
        object_repr,
        action_flag,
        change_message="""",
    ):
        if isinstance(change_message, list):
            change_message = json.dumps(change_message)
        return self.model.objects.create(
            user_id=user_id,
            content_type_id=content_type_id,
            object_id=str(object_id),
            object_repr=object_repr[:200],
            action_flag=action_flag,
            change_message=change_message,
        )


class LogEntry(models.Model):
    action_time = models.DateTimeField(
        _(""action time""),
        default=timezone.now,
        editable=False,
    )
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        models.CASCADE,
        verbose_name=_(""user""),
    )
    content_type = models.ForeignKey(
        ContentType,
        models.SET_NULL,
        verbose_name=_(""content type""),
        blank=True,
        null=True,
    )
    object_id = models.TextField(_(""object id""), blank=True, null=True)
    # Translators: 'repr' means representation
    # (https://docs.python.org/library/functions.html#repr)
    object_repr = models.CharField(_(""object repr""), max_length=200)
    action_flag = models.PositiveSmallIntegerField(
        _(""action flag""), choices=ACTION_FLAG_CHOICES
    )
    # change_message is either a string or a JSON structure
    change_message = models.TextField(_(""change message""), blank=True)

    objects = LogEntryManager()

    class Meta:
        verbose_name = _(""log entry"")
        verbose_name_plural = _(""log entries"")
        db_table = ""django_admin_log""
        ordering = [""-action_time""]

    def __repr__(self):
        return str(self.action_time)

    def __str__(self):
        if self.is_addition():
            return gettext(""Added “%(object)s”."") % {""object"": self.object_repr}
        elif self.is_change():
            return gettext(""Changed “%(object)s” — %(changes)s"") % {
                ""object"": self.object_repr,
                ""changes"": self.get_change_message(),
            }
        elif self.is_deletion():
            return gettext(""Deleted “%(object)s.”"") % {""object"": self.object_repr}

        return gettext(""LogEntry Object"")

    def is_addition(self):
        return self.action_flag == ADDITION

    def is_change(self):
        return self.action_flag == CHANGE

    def is_deletion(self):
        return self.action_flag == DELETION

    def get_change_message(self):
        """"""
        If self.change_message is a JSON structure, interpret it as a change
        string, properly translated.
        """"""
        if self.change_message and self.change_message[0] == ""["":
            try:
                change_message = json.loads(self.change_message)
            except json.JSONDecodeError:
                return self.change_message
            messages = []
            for sub_message in change_message:
                if ""added"" in sub_message:
                    if sub_message[""added""]:
                        sub_message[""added""][""name""] = gettext(
                            sub_message[""added""][""name""]
                        )
                        messages.append(
                            gettext(""Added {name} “{object}”."").format(
                                **sub_message[""added""]
                            )
                        )
                    else:
                        messages.append(gettext(""Added.""))

                elif ""changed"" in sub_message:
                    sub_message[""changed""][""fields""] = get_text_list(
                        [
                            gettext(field_name)
                            for field_name in sub_message[""changed""][""fields""]
                        ],
                        gettext(""and""),
                    )
                    if ""name"" in sub_message[""changed""]:
                        sub_message[""changed""][""name""] = gettext(
                            sub_message[""changed""][""name""]
                        )
                        messages.append(
                            gettext(""Changed {fields} for {name} “{object}”."").format(
                                **sub_message[""changed""]
                            )
                        )
                    else:
                        messages.append(
                            gettext(""Changed {fields}."").format(
                                **sub_message[""changed""]
                            )
                        )

                elif ""deleted"" in sub_message:
                    sub_message[""deleted""][""name""] = gettext(
                        sub_message[""deleted""][""name""]
                    )
                    messages.append(
                        gettext(""Deleted {name} “{object}”."").format(
                            **sub_message[""deleted""]
                        )
                    )

            change_message = "" "".join(msg[0].upper() + msg[1:] for msg in messages)
            return change_message or gettext(""No fields changed."")
        else:
            return self.change_message

    def get_edited_object(self):
        """"""Return the edited object represented by this log entry.""""""
        return self.content_type.get_object_for_this_type(pk=self.object_id)

    def get_admin_url(self):
        """"""
        Return the admin URL to edit the object represented by this log entry.
        """"""
        if self.content_type and self.object_id:
            url_name = ""admin:%s_%s_change"" % (
                self.content_type.app_label,
                self.content_type.model,
            )
            try:
                return reverse(url_name, args=(quote(self.object_id),))
            except NoReverseMatch:
                pass
        return None<EOS>"
"<BOS>import datetime
import decimal
import json
from collections import defaultdict

from django.core.exceptions import FieldDoesNotExist
from django.db import models, router
from django.db.models.constants import LOOKUP_SEP
from django.db.models.deletion import Collector
from django.forms.utils import pretty_name
from django.urls import NoReverseMatch, reverse
from django.utils import formats, timezone
from django.utils.html import format_html
from django.utils.regex_helper import _lazy_re_compile
from django.utils.text import capfirst
from django.utils.translation import ngettext
from django.utils.translation import override as translation_override

QUOTE_MAP = {i: ""_%02X"" % i for i in b'"":/_#?;@&=+$,""[]<>%\n\\'}
UNQUOTE_MAP = {v: chr(k) for k, v in QUOTE_MAP.items()}
UNQUOTE_RE = _lazy_re_compile(""_(?:%s)"" % ""|"".join([x[1:] for x in UNQUOTE_MAP]))


class FieldIsAForeignKeyColumnName(Exception):
    """"""A field is a foreign key attname, i.e. <FK>_id.""""""

    pass


def lookup_spawns_duplicates(opts, lookup_path):
    """"""
    Return True if the given lookup path spawns duplicates.
    """"""
    lookup_fields = lookup_path.split(LOOKUP_SEP)
    # Go through the fields (following all relations) and look for an m2m.
    for field_name in lookup_fields:
        if field_name == ""pk"":
            field_name = opts.pk.name
        try:
            field = opts.get_field(field_name)
        except FieldDoesNotExist:
            # Ignore query lookups.
            continue
        else:
            if hasattr(field, ""path_infos""):
                # This field is a relation; update opts to follow the relation.
                path_info = field.path_infos
                opts = path_info[-1].to_opts
                if any(path.m2m for path in path_info):
                    # This field is a m2m relation so duplicates must be
                    # handled.
                    return True
    return False


def prepare_lookup_value(key, value, separator="",""):
    """"""
    Return a lookup value prepared to be used in queryset filtering.
    """"""
    # if key ends with __in, split parameter into separate values
    if key.endswith(""__in""):
        value = value.split(separator)
    # if key ends with __isnull, special case '' and the string literals 'false' and '0'
    elif key.endswith(""__isnull""):
        value = value.lower() not in ("""", ""false"", ""0"")
    return value


def quote(s):
    """"""
    Ensure that primary key values do not confuse the admin URLs by escaping
    any '/', '_' and ':' and similarly problematic characters.
    Similar to urllib.parse.quote(), except that the quoting is slightly
    different so that it doesn't get automatically unquoted by the web browser.
    """"""
    return s.translate(QUOTE_MAP) if isinstance(s, str) else s


def unquote(s):
    """"""Undo the effects of quote().""""""
    return UNQUOTE_RE.sub(lambda m: UNQUOTE_MAP[m[0]], s)


def flatten(fields):
    """"""
    Return a list which is a single level of flattening of the original list.
    """"""
    flat = []
    for field in fields:
        if isinstance(field, (list, tuple)):
            flat.extend(field)
        else:
            flat.append(field)
    return flat


def flatten_fieldsets(fieldsets):
    """"""Return a list of field names from an admin fieldsets structure.""""""
    field_names = []
    for name, opts in fieldsets:
        field_names.extend(flatten(opts[""fields""]))
    return field_names


def get_deleted_objects(objs, request, admin_site):
    """"""
    Find all objects related to ``objs`` that should also be deleted. ``objs``
    must be a homogeneous iterable of objects (e.g. a QuerySet).

    Return a nested list of strings suitable for display in the
    template with the ``unordered_list`` filter.
    """"""
    try:
        obj = objs[0]
    except IndexError:
        return [], {}, set(), []
    else:
        using = router.db_for_write(obj._meta.model)
    collector = NestedObjects(using=using, origin=objs)
    collector.collect(objs)
    perms_needed = set()

    def format_callback(obj):
        model = obj.__class__
        has_admin = model in admin_site._registry
        opts = obj._meta

        no_edit_link = ""%s: %s"" % (capfirst(opts.verbose_name), obj)

        if has_admin:
            if not admin_site._registry[model].has_delete_permission(request, obj):
                perms_needed.add(opts.verbose_name)
            try:
                admin_url = reverse(
                    ""%s:%s_%s_change""
                    % (admin_site.name, opts.app_label, opts.model_name),
                    None,
                    (quote(obj.pk),),
                )
            except NoReverseMatch:
                # Change url doesn't exist -- don't display link to edit
                return no_edit_link

            # Display a link to the admin page.
            return format_html(
                '{}: <a href=""{}"">{}</a>', capfirst(opts.verbose_name), admin_url, obj
            )
        else:
            # Don't display link to edit, because it either has no
            # admin or is edited inline.
            return no_edit_link

    to_delete = collector.nested(format_callback)

    protected = [format_callback(obj) for obj in collector.protected]
    model_count = {
        model._meta.verbose_name_plural: len(objs)
        for model, objs in collector.model_objs.items()
    }

    return to_delete, model_count, perms_needed, protected


class NestedObjects(Collector):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.edges = {}  # {from_instance: [to_instances]}
        self.protected = set()
        self.model_objs = defaultdict(set)

    def add_edge(self, source, target):
        self.edges.setdefault(source, []).append(target)

    def collect(self, objs, source=None, source_attr=None, **kwargs):
        for obj in objs:
            if source_attr and not source_attr.endswith(""+""):
                related_name = source_attr % {
                    ""class"": source._meta.model_name,
                    ""app_label"": source._meta.app_label,
                }
                self.add_edge(getattr(obj, related_name), obj)
            else:
                self.add_edge(None, obj)
            self.model_objs[obj._meta.model].add(obj)
        try:
            return super().collect(objs, source_attr=source_attr, **kwargs)
        except models.ProtectedError as e:
            self.protected.update(e.protected_objects)
        except models.RestrictedError as e:
            self.protected.update(e.restricted_objects)

    def related_objects(self, related_model, related_fields, objs):
        qs = super().related_objects(related_model, related_fields, objs)
        return qs.select_related(
            *[related_field.name for related_field in related_fields]
        )

    def _nested(self, obj, seen, format_callback):
        if obj in seen:
            return []
        seen.add(obj)
        children = []
        for child in self.edges.get(obj, ()):
            children.extend(self._nested(child, seen, format_callback))
        if format_callback:
            ret = [format_callback(obj)]
        else:
            ret = [obj]
        if children:
            ret.append(children)
        return ret

    def nested(self, format_callback=None):
        """"""
        Return the graph as a nested list.
        """"""
        seen = set()
        roots = []
        for root in self.edges.get(None, ()):
            roots.extend(self._nested(root, seen, format_callback))
        return roots

    def can_fast_delete(self, *args, **kwargs):
        """"""
        We always want to load the objects into memory so that we can display
        them to the user in confirm page.
        """"""
        return False


def model_format_dict(obj):
    """"""
    Return a `dict` with keys 'verbose_name' and 'verbose_name_plural',
    typically for use with string formatting.

    `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.
    """"""
    if isinstance(obj, (models.Model, models.base.ModelBase)):
        opts = obj._meta
    elif isinstance(obj, models.query.QuerySet):
        opts = obj.model._meta
    else:
        opts = obj
    return {
        ""verbose_name"": opts.verbose_name,
        ""verbose_name_plural"": opts.verbose_name_plural,
    }


def model_ngettext(obj, n=None):
    """"""
    Return the appropriate `verbose_name` or `verbose_name_plural` value for
    `obj` depending on the count `n`.

    `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.
    If `obj` is a `QuerySet` instance, `n` is optional and the length of the
    `QuerySet` is used.
    """"""
    if isinstance(obj, models.query.QuerySet):
        if n is None:
            n = obj.count()
        obj = obj.model
    d = model_format_dict(obj)
    singular, plural = d[""verbose_name""], d[""verbose_name_plural""]
    return ngettext(singular, plural, n or 0)


def lookup_field(name, obj, model_admin=None):
    opts = obj._meta
    try:
        f = _get_non_gfk_field(opts, name)
    except (FieldDoesNotExist, FieldIsAForeignKeyColumnName):
        # For non-field values, the value is either a method, property or
        # returned via a callable.
        if callable(name):
            attr = name
            value = attr(obj)
        elif hasattr(model_admin, name) and name != ""__str__"":
            attr = getattr(model_admin, name)
            value = attr(obj)
        else:
            attr = getattr(obj, name)
            if callable(attr):
                value = attr()
            else:
                value = attr
        f = None
    else:
        attr = None
        value = getattr(obj, name)
    return f, attr, value


def _get_non_gfk_field(opts, name):
    """"""
    For historical reasons, the admin app relies on GenericForeignKeys as being
    ""not found"" by get_field(). This could likely be cleaned up.

    Reverse relations should also be excluded as these aren't attributes of the
    model (rather something like `foo_set`).
    """"""
    field = opts.get_field(name)
    if (
        field.is_relation
        and
        # Generic foreign keys OR reverse relations
        ((field.many_to_one and not field.related_model) or field.one_to_many)
    ):
        raise FieldDoesNotExist()

    # Avoid coercing <FK>_id fields to FK
    if (
        field.is_relation
        and not field.many_to_many
        and hasattr(field, ""attname"")
        and field.attname == name
    ):
        raise FieldIsAForeignKeyColumnName()

    return field


def label_for_field(name, model, model_admin=None, return_attr=False, form=None):
    """"""
    Return a sensible label for a field name. The name can be a callable,
    property (but not created with @property decorator), or the name of an
    object's attribute, as well as a model field. If return_attr is True, also
    return the resolved attribute (which could be a callable). This will be
    None if (and only if) the name refers to a field.
    """"""
    attr = None
    try:
        field = _get_non_gfk_field(model._meta, name)
        try:
            label = field.verbose_name
        except AttributeError:
            # field is likely a ForeignObjectRel
            label = field.related_model._meta.verbose_name
    except FieldDoesNotExist:
        if name == ""__str__"":
            label = str(model._meta.verbose_name)
            attr = str
        else:
            if callable(name):
                attr = name
            elif hasattr(model_admin, name):
                attr = getattr(model_admin, name)
            elif hasattr(model, name):
                attr = getattr(model, name)
            elif form and name in form.fields:
                attr = form.fields[name]
            else:
                message = ""Unable to lookup '%s' on %s"" % (
                    name,
                    model._meta.object_name,
                )
                if model_admin:
                    message += "" or %s"" % model_admin.__class__.__name__
                if form:
                    message += "" or %s"" % form.__class__.__name__
                raise AttributeError(message)

            if hasattr(attr, ""short_description""):
                label = attr.short_description
            elif (
                isinstance(attr, property)
                and hasattr(attr, ""fget"")
                and hasattr(attr.fget, ""short_description"")
            ):
                label = attr.fget.short_description
            elif callable(attr):
                if attr.__name__ == ""<lambda>"":
                    label = ""--""
                else:
                    label = pretty_name(attr.__name__)
            else:
                label = pretty_name(name)
    except FieldIsAForeignKeyColumnName:
        label = pretty_name(name)
        attr = name

    if return_attr:
        return (label, attr)
    else:
        return label


def help_text_for_field(name, model):
    help_text = """"
    try:
        field = _get_non_gfk_field(model._meta, name)
    except (FieldDoesNotExist, FieldIsAForeignKeyColumnName):
        pass
    else:
        if hasattr(field, ""help_text""):
            help_text = field.help_text
    return help_text


def display_for_field(value, field, empty_value_display):
    from django.contrib.admin.templatetags.admin_list import _boolean_icon

    if getattr(field, ""flatchoices"", None):
        return dict(field.flatchoices).get(value, empty_value_display)
    # BooleanField needs special-case null-handling, so it comes before the
    # general null test.
    elif isinstance(field, models.BooleanField):
        return _boolean_icon(value)
    elif value is None:
        return empty_value_display
    elif isinstance(field, models.DateTimeField):
        return formats.localize(timezone.template_localtime(value))
    elif isinstance(field, (models.DateField, models.TimeField)):
        return formats.localize(value)
    elif isinstance(field, models.DecimalField):
        return formats.number_format(value, field.decimal_places)
    elif isinstance(field, (models.IntegerField, models.FloatField)):
        return formats.number_format(value)
    elif isinstance(field, models.FileField) and value:
        return format_html('<a href=""{}"">{}</a>', value.url, value)
    elif isinstance(field, models.JSONField) and value:
        try:
            return json.dumps(value, ensure_ascii=False, cls=field.encoder)
        except TypeError:
            return display_for_value(value, empty_value_display)
    else:
        return display_for_value(value, empty_value_display)


def display_for_value(value, empty_value_display, boolean=False):
    from django.contrib.admin.templatetags.admin_list import _boolean_icon

    if boolean:
        return _boolean_icon(value)
    elif value is None:
        return empty_value_display
    elif isinstance(value, bool):
        return str(value)
    elif isinstance(value, datetime.datetime):
        return formats.localize(timezone.template_localtime(value))
    elif isinstance(value, (datetime.date, datetime.time)):
        return formats.localize(value)
    elif isinstance(value, (int, decimal.Decimal, float)):
        return formats.number_format(value)
    elif isinstance(value, (list, tuple)):
        return "", "".join(str(v) for v in value)
    else:
        return str(value)


class NotRelationField(Exception):
    pass


def get_model_from_relation(field):
    if hasattr(field, ""path_infos""):
        return field.path_infos[-1].to_opts.model
    else:
        raise NotRelationField


def reverse_field_path(model, path):
    """"""Create a reversed field path.

    E.g. Given (Order, ""user__groups""),
    return (Group, ""user__order"").

    Final field must be a related model, not a data field.
    """"""
    reversed_path = []
    parent = model
    pieces = path.split(LOOKUP_SEP)
    for piece in pieces:
        field = parent._meta.get_field(piece)
        # skip trailing data field if extant:
        if len(reversed_path) == len(pieces) - 1:  # final iteration
            try:
                get_model_from_relation(field)
            except NotRelationField:
                break

        # Field should point to another model
        if field.is_relation and not (field.auto_created and not field.concrete):
            related_name = field.related_query_name()
            parent = field.remote_field.model
        else:
            related_name = field.field.name
            parent = field.related_model
        reversed_path.insert(0, related_name)
    return (parent, LOOKUP_SEP.join(reversed_path))


def get_fields_from_path(model, path):
    """"""Return list of Fields given path relative to model.

    e.g. (ModelX, ""user__groups__name"") -> [
        <django.db.models.fields.related.ForeignKey object at 0x...>,
        <django.db.models.fields.related.ManyToManyField object at 0x...>,
        <django.db.models.fields.CharField object at 0x...>,
    ]
    """"""
    pieces = path.split(LOOKUP_SEP)
    fields = []
    for piece in pieces:
        if fields:
            parent = get_model_from_relation(fields[-1])
        else:
            parent = model
        fields.append(parent._meta.get_field(piece))
    return fields


def construct_change_message(form, formsets, add):
    """"""
    Construct a JSON structure describing changes from a changed object.
    Translations are deactivated so that strings are stored untranslated.
    Translation happens later on LogEntry access.
    """"""
    # Evaluating `form.changed_data` prior to disabling translations is required
    # to avoid fields affected by localization from being included incorrectly,
    # e.g. where date formats differ such as MM/DD/YYYY vs DD/MM/YYYY.
    changed_data = form.changed_data
    with translation_override(None):
        # Deactivate translations while fetching verbose_name for form
        # field labels and using `field_name`, if verbose_name is not provided.
        # Translations will happen later on LogEntry access.
        changed_field_labels = _get_changed_field_labels_from_form(form, changed_data)

    change_message = []
    if add:
        change_message.append({""added"": {}})
    elif form.changed_data:
        change_message.append({""changed"": {""fields"": changed_field_labels}})
    if formsets:
        with translation_override(None):
            for formset in formsets:
                for added_object in formset.new_objects:
                    change_message.append(
                        {
                            ""added"": {
                                ""name"": str(added_object._meta.verbose_name),
                                ""object"": str(added_object),
                            }
                        }
                    )
                for changed_object, changed_fields in formset.changed_objects:
                    change_message.append(
                        {
                            ""changed"": {
                                ""name"": str(changed_object._meta.verbose_name),
                                ""object"": str(changed_object),
                                ""fields"": _get_changed_field_labels_from_form(
                                    formset.forms[0], changed_fields
                                ),
                            }
                        }
                    )
                for deleted_object in formset.deleted_objects:
                    change_message.append(
                        {
                            ""deleted"": {
                                ""name"": str(deleted_object._meta.verbose_name),
                                ""object"": str(deleted_object),
                            }
                        }
                    )
    return change_message


def _get_changed_field_labels_from_form(form, changed_data):
    changed_field_labels = []
    for field_name in changed_data:
        try:
            verbose_field_name = form.fields[field_name].label or field_name
        except KeyError:
            verbose_field_name = field_name
        changed_field_labels.append(str(verbose_field_name))
    return changed_field_labels<EOS>"
"<BOS>import copy
import json
import re
from functools import partial, update_wrapper
from urllib.parse import quote as urlquote

from django import forms
from django.conf import settings
from django.contrib import messages
from django.contrib.admin import helpers, widgets
from django.contrib.admin.checks import (
    BaseModelAdminChecks,
    InlineModelAdminChecks,
    ModelAdminChecks,
)
from django.contrib.admin.decorators import display
from django.contrib.admin.exceptions import DisallowedModelAdminToField
from django.contrib.admin.templatetags.admin_urls import add_preserved_filters
from django.contrib.admin.utils import (
    NestedObjects,
    construct_change_message,
    flatten_fieldsets,
    get_deleted_objects,
    lookup_spawns_duplicates,
    model_format_dict,
    model_ngettext,
    quote,
    unquote,
)
from django.contrib.admin.widgets import AutocompleteSelect, AutocompleteSelectMultiple
from django.contrib.auth import get_permission_codename
from django.core.exceptions import (
    FieldDoesNotExist,
    FieldError,
    PermissionDenied,
    ValidationError,
)
from django.core.paginator import Paginator
from django.db import models, router, transaction
from django.db.models.constants import LOOKUP_SEP
from django.forms.formsets import DELETION_FIELD_NAME, all_valid
from django.forms.models import (
    BaseInlineFormSet,
    inlineformset_factory,
    modelform_defines_fields,
    modelform_factory,
    modelformset_factory,
)
from django.forms.widgets import CheckboxSelectMultiple, SelectMultiple
from django.http import HttpResponseRedirect
from django.http.response import HttpResponseBase
from django.template.response import SimpleTemplateResponse, TemplateResponse
from django.urls import reverse
from django.utils.decorators import method_decorator
from django.utils.html import format_html
from django.utils.http import urlencode
from django.utils.safestring import mark_safe
from django.utils.text import (
    capfirst,
    format_lazy,
    get_text_list,
    smart_split,
    unescape_string_literal,
)
from django.utils.translation import gettext as _
from django.utils.translation import ngettext
from django.views.decorators.csrf import csrf_protect
from django.views.generic import RedirectView

IS_POPUP_VAR = ""_popup""
TO_FIELD_VAR = ""_to_field""


HORIZONTAL, VERTICAL = 1, 2


def get_content_type_for_model(obj):
    # Since this module gets imported in the application's root package,
    # it cannot import models from other applications at the module level.
    from django.contrib.contenttypes.models import ContentType

    return ContentType.objects.get_for_model(obj, for_concrete_model=False)


def get_ul_class(radio_style):
    return ""radiolist"" if radio_style == VERTICAL else ""radiolist inline""


class IncorrectLookupParameters(Exception):
    pass


# Defaults for formfield_overrides. ModelAdmin subclasses can change this
# by adding to ModelAdmin.formfield_overrides.

FORMFIELD_FOR_DBFIELD_DEFAULTS = {
    models.DateTimeField: {
        ""form_class"": forms.SplitDateTimeField,
        ""widget"": widgets.AdminSplitDateTime,
    },
    models.DateField: {""widget"": widgets.AdminDateWidget},
    models.TimeField: {""widget"": widgets.AdminTimeWidget},
    models.TextField: {""widget"": widgets.AdminTextareaWidget},
    models.URLField: {""widget"": widgets.AdminURLFieldWidget},
    models.IntegerField: {""widget"": widgets.AdminIntegerFieldWidget},
    models.BigIntegerField: {""widget"": widgets.AdminBigIntegerFieldWidget},
    models.CharField: {""widget"": widgets.AdminTextInputWidget},
    models.ImageField: {""widget"": widgets.AdminFileWidget},
    models.FileField: {""widget"": widgets.AdminFileWidget},
    models.EmailField: {""widget"": widgets.AdminEmailInputWidget},
    models.UUIDField: {""widget"": widgets.AdminUUIDInputWidget},
}

csrf_protect_m = method_decorator(csrf_protect)


class BaseModelAdmin(metaclass=forms.MediaDefiningClass):
    """"""Functionality common to both ModelAdmin and InlineAdmin.""""""

    autocomplete_fields = ()
    raw_id_fields = ()
    fields = None
    exclude = None
    fieldsets = None
    form = forms.ModelForm
    filter_vertical = ()
    filter_horizontal = ()
    radio_fields = {}
    prepopulated_fields = {}
    formfield_overrides = {}
    readonly_fields = ()
    ordering = None
    sortable_by = None
    view_on_site = True
    show_full_result_count = True
    checks_class = BaseModelAdminChecks

    def check(self, **kwargs):
        return self.checks_class().check(self, **kwargs)

    def __init__(self):
        # Merge FORMFIELD_FOR_DBFIELD_DEFAULTS with the formfield_overrides
        # rather than simply overwriting.
        overrides = copy.deepcopy(FORMFIELD_FOR_DBFIELD_DEFAULTS)
        for k, v in self.formfield_overrides.items():
            overrides.setdefault(k, {}).update(v)
        self.formfield_overrides = overrides

    def formfield_for_dbfield(self, db_field, request, **kwargs):
        """"""
        Hook for specifying the form Field instance for a given database Field
        instance.

        If kwargs are given, they're passed to the form Field's constructor.
        """"""
        # If the field specifies choices, we don't need to look for special
        # admin widgets - we just need to use a select widget of some kind.
        if db_field.choices:
            return self.formfield_for_choice_field(db_field, request, **kwargs)

        # ForeignKey or ManyToManyFields
        if isinstance(db_field, (models.ForeignKey, models.ManyToManyField)):
            # Combine the field kwargs with any options for formfield_overrides.
            # Make sure the passed in **kwargs override anything in
            # formfield_overrides because **kwargs is more specific, and should
            # always win.
            if db_field.__class__ in self.formfield_overrides:
                kwargs = {**self.formfield_overrides[db_field.__class__], **kwargs}

            # Get the correct formfield.
            if isinstance(db_field, models.ForeignKey):
                formfield = self.formfield_for_foreignkey(db_field, request, **kwargs)
            elif isinstance(db_field, models.ManyToManyField):
                formfield = self.formfield_for_manytomany(db_field, request, **kwargs)

            # For non-raw_id fields, wrap the widget with a wrapper that adds
            # extra HTML -- the ""add other"" interface -- to the end of the
            # rendered output. formfield can be None if it came from a
            # OneToOneField with parent_link=True or a M2M intermediary.
            if formfield and db_field.name not in self.raw_id_fields:
                related_modeladmin = self.admin_site._registry.get(
                    db_field.remote_field.model
                )
                wrapper_kwargs = {}
                if related_modeladmin:
                    wrapper_kwargs.update(
                        can_add_related=related_modeladmin.has_add_permission(request),
                        can_change_related=related_modeladmin.has_change_permission(
                            request
                        ),
                        can_delete_related=related_modeladmin.has_delete_permission(
                            request
                        ),
                        can_view_related=related_modeladmin.has_view_permission(
                            request
                        ),
                    )
                formfield.widget = widgets.RelatedFieldWidgetWrapper(
                    formfield.widget,
                    db_field.remote_field,
                    self.admin_site,
                    **wrapper_kwargs,
                )

            return formfield

        # If we've got overrides for the formfield defined, use 'em. **kwargs
        # passed to formfield_for_dbfield override the defaults.
        for klass in db_field.__class__.mro():
            if klass in self.formfield_overrides:
                kwargs = {**copy.deepcopy(self.formfield_overrides[klass]), **kwargs}
                return db_field.formfield(**kwargs)

        # For any other type of field, just call its formfield() method.
        return db_field.formfield(**kwargs)

    def formfield_for_choice_field(self, db_field, request, **kwargs):
        """"""
        Get a form Field for a database Field that has declared choices.
        """"""
        # If the field is named as a radio_field, use a RadioSelect
        if db_field.name in self.radio_fields:
            # Avoid stomping on custom widget/choices arguments.
            if ""widget"" not in kwargs:
                kwargs[""widget""] = widgets.AdminRadioSelect(
                    attrs={
                        ""class"": get_ul_class(self.radio_fields[db_field.name]),
                    }
                )
            if ""choices"" not in kwargs:
                kwargs[""choices""] = db_field.get_choices(
                    include_blank=db_field.blank, blank_choice=[("""", _(""None""))]
                )
        return db_field.formfield(**kwargs)

    def get_field_queryset(self, db, db_field, request):
        """"""
        If the ModelAdmin specifies ordering, the queryset should respect that
        ordering.  Otherwise don't specify the queryset, let the field decide
        (return None in that case).
        """"""
        related_admin = self.admin_site._registry.get(db_field.remote_field.model)
        if related_admin is not None:
            ordering = related_admin.get_ordering(request)
            if ordering is not None and ordering != ():
                return db_field.remote_field.model._default_manager.using(db).order_by(
                    *ordering
                )
        return None

    def formfield_for_foreignkey(self, db_field, request, **kwargs):
        """"""
        Get a form Field for a ForeignKey.
        """"""
        db = kwargs.get(""using"")

        if ""widget"" not in kwargs:
            if db_field.name in self.get_autocomplete_fields(request):
                kwargs[""widget""] = AutocompleteSelect(
                    db_field, self.admin_site, using=db
                )
            elif db_field.name in self.raw_id_fields:
                kwargs[""widget""] = widgets.ForeignKeyRawIdWidget(
                    db_field.remote_field, self.admin_site, using=db
                )
            elif db_field.name in self.radio_fields:
                kwargs[""widget""] = widgets.AdminRadioSelect(
                    attrs={
                        ""class"": get_ul_class(self.radio_fields[db_field.name]),
                    }
                )
                kwargs[""empty_label""] = (
                    kwargs.get(""empty_label"", _(""None"")) if db_field.blank else None
                )

        if ""queryset"" not in kwargs:
            queryset = self.get_field_queryset(db, db_field, request)
            if queryset is not None:
                kwargs[""queryset""] = queryset

        return db_field.formfield(**kwargs)

    def formfield_for_manytomany(self, db_field, request, **kwargs):
        """"""
        Get a form Field for a ManyToManyField.
        """"""
        # If it uses an intermediary model that isn't auto created, don't show
        # a field in admin.
        if not db_field.remote_field.through._meta.auto_created:
            return None
        db = kwargs.get(""using"")

        if ""widget"" not in kwargs:
            autocomplete_fields = self.get_autocomplete_fields(request)
            if db_field.name in autocomplete_fields:
                kwargs[""widget""] = AutocompleteSelectMultiple(
                    db_field,
                    self.admin_site,
                    using=db,
                )
            elif db_field.name in self.raw_id_fields:
                kwargs[""widget""] = widgets.ManyToManyRawIdWidget(
                    db_field.remote_field,
                    self.admin_site,
                    using=db,
                )
            elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:
                kwargs[""widget""] = widgets.FilteredSelectMultiple(
                    db_field.verbose_name, db_field.name in self.filter_vertical
                )
        if ""queryset"" not in kwargs:
            queryset = self.get_field_queryset(db, db_field, request)
            if queryset is not None:
                kwargs[""queryset""] = queryset

        form_field = db_field.formfield(**kwargs)
        if isinstance(form_field.widget, SelectMultiple) and not isinstance(
            form_field.widget, (CheckboxSelectMultiple, AutocompleteSelectMultiple)
        ):
            msg = _(
                ""Hold down “Control”, or “Command” on a Mac, to select more than one.""
            )
            help_text = form_field.help_text
            form_field.help_text = (
                format_lazy(""{} {}"", help_text, msg) if help_text else msg
            )
        return form_field

    def get_autocomplete_fields(self, request):
        """"""
        Return a list of ForeignKey and/or ManyToMany fields which should use
        an autocomplete widget.
        """"""
        return self.autocomplete_fields

    def get_view_on_site_url(self, obj=None):
        if obj is None or not self.view_on_site:
            return None

        if callable(self.view_on_site):
            return self.view_on_site(obj)
        elif hasattr(obj, ""get_absolute_url""):
            # use the ContentType lookup if view_on_site is True
            return reverse(
                ""admin:view_on_site"",
                kwargs={
                    ""content_type_id"": get_content_type_for_model(obj).pk,
                    ""object_id"": obj.pk,
                },
            )

    def get_empty_value_display(self):
        """"""
        Return the empty_value_display set on ModelAdmin or AdminSite.
        """"""
        try:
            return mark_safe(self.empty_value_display)
        except AttributeError:
            return mark_safe(self.admin_site.empty_value_display)

    def get_exclude(self, request, obj=None):
        """"""
        Hook for specifying exclude.
        """"""
        return self.exclude

    def get_fields(self, request, obj=None):
        """"""
        Hook for specifying fields.
        """"""
        if self.fields:
            return self.fields
        # _get_form_for_get_fields() is implemented in subclasses.
        form = self._get_form_for_get_fields(request, obj)
        return [*form.base_fields, *self.get_readonly_fields(request, obj)]

    def get_fieldsets(self, request, obj=None):
        """"""
        Hook for specifying fieldsets.
        """"""
        if self.fieldsets:
            return self.fieldsets
        return [(None, {""fields"": self.get_fields(request, obj)})]

    def get_inlines(self, request, obj):
        """"""Hook for specifying custom inlines.""""""
        return self.inlines

    def get_ordering(self, request):
        """"""
        Hook for specifying field ordering.
        """"""
        return self.ordering or ()  # otherwise we might try to *None, which is bad ;)

    def get_readonly_fields(self, request, obj=None):
        """"""
        Hook for specifying custom readonly fields.
        """"""
        return self.readonly_fields

    def get_prepopulated_fields(self, request, obj=None):
        """"""
        Hook for specifying custom prepopulated fields.
        """"""
        return self.prepopulated_fields

    def get_queryset(self, request):
        """"""
        Return a QuerySet of all model instances that can be edited by the
        admin site. This is used by changelist_view.
        """"""
        qs = self.model._default_manager.get_queryset()
        # TODO: this should be handled by some parameter to the ChangeList.
        ordering = self.get_ordering(request)
        if ordering:
            qs = qs.order_by(*ordering)
        return qs

    def get_sortable_by(self, request):
        """"""Hook for specifying which fields can be sorted in the changelist.""""""
        return (
            self.sortable_by
            if self.sortable_by is not None
            else self.get_list_display(request)
        )

    def lookup_allowed(self, lookup, value):
        from django.contrib.admin.filters import SimpleListFilter

        model = self.model
        # Check FKey lookups that are allowed, so that popups produced by
        # ForeignKeyRawIdWidget, on the basis of ForeignKey.limit_choices_to,
        # are allowed to work.
        for fk_lookup in model._meta.related_fkey_lookups:
            # As ``limit_choices_to`` can be a callable, invoke it here.
            if callable(fk_lookup):
                fk_lookup = fk_lookup()
            if (lookup, value) in widgets.url_params_from_lookup_dict(
                fk_lookup
            ).items():
                return True

        relation_parts = []
        prev_field = None
        for part in lookup.split(LOOKUP_SEP):
            try:
                field = model._meta.get_field(part)
            except FieldDoesNotExist:
                # Lookups on nonexistent fields are ok, since they're ignored
                # later.
                break
            # It is allowed to filter on values that would be found from local
            # model anyways. For example, if you filter on employee__department__id,
            # then the id value would be found already from employee__department_id.
            if not prev_field or (
                prev_field.is_relation
                and field not in prev_field.path_infos[-1].target_fields
            ):
                relation_parts.append(part)
            if not getattr(field, ""path_infos"", None):
                # This is not a relational field, so further parts
                # must be transforms.
                break
            prev_field = field
            model = field.path_infos[-1].to_opts.model

        if len(relation_parts) <= 1:
            # Either a local field filter, or no fields at all.
            return True
        valid_lookups = {self.date_hierarchy}
        for filter_item in self.list_filter:
            if isinstance(filter_item, type) and issubclass(
                filter_item, SimpleListFilter
            ):
                valid_lookups.add(filter_item.parameter_name)
            elif isinstance(filter_item, (list, tuple)):
                valid_lookups.add(filter_item[0])
            else:
                valid_lookups.add(filter_item)

        # Is it a valid relational lookup?
        return not {
            LOOKUP_SEP.join(relation_parts),
            LOOKUP_SEP.join(relation_parts + [part]),
        }.isdisjoint(valid_lookups)

    def to_field_allowed(self, request, to_field):
        """"""
        Return True if the model associated with this admin should be
        allowed to be referenced by the specified field.
        """"""
        opts = self.model._meta

        try:
            field = opts.get_field(to_field)
        except FieldDoesNotExist:
            return False

        # Always allow referencing the primary key since it's already possible
        # to get this information from the change view URL.
        if field.primary_key:
            return True

        # Allow reverse relationships to models defining m2m fields if they
        # target the specified field.
        for many_to_many in opts.many_to_many:
            if many_to_many.m2m_target_field_name() == to_field:
                return True

        # Make sure at least one of the models registered for this site
        # references this field through a FK or a M2M relationship.
        registered_models = set()
        for model, admin in self.admin_site._registry.items():
            registered_models.add(model)
            for inline in admin.inlines:
                registered_models.add(inline.model)

        related_objects = (
            f
            for f in opts.get_fields(include_hidden=True)
            if (f.auto_created and not f.concrete)
        )
        for related_object in related_objects:
            related_model = related_object.related_model
            remote_field = related_object.field.remote_field
            if (
                any(issubclass(model, related_model) for model in registered_models)
                and hasattr(remote_field, ""get_related_field"")
                and remote_field.get_related_field() == field
            ):
                return True

        return False

    def has_add_permission(self, request):
        """"""
        Return True if the given request has permission to add an object.
        Can be overridden by the user in subclasses.
        """"""
        opts = self.opts
        codename = get_permission_codename(""add"", opts)
        return request.user.has_perm(""%s.%s"" % (opts.app_label, codename))

    def has_change_permission(self, request, obj=None):
        """"""
        Return True if the given request has permission to change the given
        Django model instance, the default implementation doesn't examine the
        `obj` parameter.

        Can be overridden by the user in subclasses. In such case it should
        return True if the given request has permission to change the `obj`
        model instance. If `obj` is None, this should return True if the given
        request has permission to change *any* object of the given type.
        """"""
        opts = self.opts
        codename = get_permission_codename(""change"", opts)
        return request.user.has_perm(""%s.%s"" % (opts.app_label, codename))

    def has_delete_permission(self, request, obj=None):
        """"""
        Return True if the given request has permission to change the given
        Django model instance, the default implementation doesn't examine the
        `obj` parameter.

        Can be overridden by the user in subclasses. In such case it should
        return True if the given request has permission to delete the `obj`
        model instance. If `obj` is None, this should return True if the given
        request has permission to delete *any* object of the given type.
        """"""
        opts = self.opts
        codename = get_permission_codename(""delete"", opts)
        return request.user.has_perm(""%s.%s"" % (opts.app_label, codename))

    def has_view_permission(self, request, obj=None):
        """"""
        Return True if the given request has permission to view the given
        Django model instance. The default implementation doesn't examine the
        `obj` parameter.

        If overridden by the user in subclasses, it should return True if the
        given request has permission to view the `obj` model instance. If `obj`
        is None, it should return True if the request has permission to view
        any object of the given type.
        """"""
        opts = self.opts
        codename_view = get_permission_codename(""view"", opts)
        codename_change = get_permission_codename(""change"", opts)
        return request.user.has_perm(
            ""%s.%s"" % (opts.app_label, codename_view)
        ) or request.user.has_perm(""%s.%s"" % (opts.app_label, codename_change))

    def has_view_or_change_permission(self, request, obj=None):
        return self.has_view_permission(request, obj) or self.has_change_permission(
            request, obj
        )

    def has_module_permission(self, request):
        """"""
        Return True if the given request has any permission in the given
        app label.

        Can be overridden by the user in subclasses. In such case it should
        return True if the given request has permission to view the module on
        the admin index page and access the module's index page. Overriding it
        does not restrict access to the add, change or delete views. Use
        `ModelAdmin.has_(add|change|delete)_permission` for that.
        """"""
        return request.user.has_module_perms(self.opts.app_label)


class ModelAdmin(BaseModelAdmin):
    """"""Encapsulate all admin options and functionality for a given model.""""""

    list_display = (""__str__"",)
    list_display_links = ()
    list_filter = ()
    list_select_related = False
    list_per_page = 100
    list_max_show_all = 200
    list_editable = ()
    search_fields = ()
    search_help_text = None
    date_hierarchy = None
    save_as = False
    save_as_continue = True
    save_on_top = False
    paginator = Paginator
    preserve_filters = True
    inlines = ()

    # Custom templates (designed to be over-ridden in subclasses)
    add_form_template = None
    change_form_template = None
    change_list_template = None
    delete_confirmation_template = None
    delete_selected_confirmation_template = None
    object_history_template = None
    popup_response_template = None

    # Actions
    actions = ()
    action_form = helpers.ActionForm
    actions_on_top = True
    actions_on_bottom = False
    actions_selection_counter = True
    checks_class = ModelAdminChecks

    def __init__(self, model, admin_site):
        self.model = model
        self.opts = model._meta
        self.admin_site = admin_site
        super().__init__()

    def __str__(self):
        return ""%s.%s"" % (self.model._meta.app_label, self.__class__.__name__)

    def __repr__(self):
        return (
            f""<{self.__class__.__qualname__}: model={self.model.__qualname__} ""
            f""site={self.admin_site!r}>""
        )

    def get_inline_instances(self, request, obj=None):
        inline_instances = []
        for inline_class in self.get_inlines(request, obj):
            inline = inline_class(self.model, self.admin_site)
            if request:
                if not (
                    inline.has_view_or_change_permission(request, obj)
                    or inline.has_add_permission(request, obj)
                    or inline.has_delete_permission(request, obj)
                ):
                    continue
                if not inline.has_add_permission(request, obj):
                    inline.max_num = 0
            inline_instances.append(inline)

        return inline_instances

    def get_urls(self):
        from django.urls import path

        def wrap(view):
            def wrapper(*args, **kwargs):
                return self.admin_site.admin_view(view)(*args, **kwargs)

            wrapper.model_admin = self
            return update_wrapper(wrapper, view)

        info = self.model._meta.app_label, self.model._meta.model_name

        return [
            path("""", wrap(self.changelist_view), name=""%s_%s_changelist"" % info),
            path(""add/"", wrap(self.add_view), name=""%s_%s_add"" % info),
            path(
                ""<path:object_id>/history/"",
                wrap(self.history_view),
                name=""%s_%s_history"" % info,
            ),
            path(
                ""<path:object_id>/delete/"",
                wrap(self.delete_view),
                name=""%s_%s_delete"" % info,
            ),
            path(
                ""<path:object_id>/change/"",
                wrap(self.change_view),
                name=""%s_%s_change"" % info,
            ),
            # For backwards compatibility (was the change url before 1.9)
            path(
                ""<path:object_id>/"",
                wrap(
                    RedirectView.as_view(
                        pattern_name=""%s:%s_%s_change""
                        % ((self.admin_site.name,) + info)
                    )
                ),
            ),
        ]

    @property
    def urls(self):
        return self.get_urls()

    @property
    def media(self):
        extra = """" if settings.DEBUG else "".min""
        js = [
            ""vendor/jquery/jquery%s.js"" % extra,
            ""jquery.init.js"",
            ""core.js"",
            ""admin/RelatedObjectLookups.js"",
            ""actions.js"",
            ""urlify.js"",
            ""prepopulate.js"",
            ""vendor/xregexp/xregexp%s.js"" % extra,
        ]
        return forms.Media(js=[""admin/js/%s"" % url for url in js])

    def get_model_perms(self, request):
        """"""
        Return a dict of all perms for this model. This dict has the keys
        ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
        for each of those actions.
        """"""
        return {
            ""add"": self.has_add_permission(request),
            ""change"": self.has_change_permission(request),
            ""delete"": self.has_delete_permission(request),
            ""view"": self.has_view_permission(request),
        }

    def _get_form_for_get_fields(self, request, obj):
        return self.get_form(request, obj, fields=None)

    def get_form(self, request, obj=None, change=False, **kwargs):
        """"""
        Return a Form class for use in the admin add view. This is used by
        add_view and change_view.
        """"""
        if ""fields"" in kwargs:
            fields = kwargs.pop(""fields"")
        else:
            fields = flatten_fieldsets(self.get_fieldsets(request, obj))
        excluded = self.get_exclude(request, obj)
        exclude = [] if excluded is None else list(excluded)
        readonly_fields = self.get_readonly_fields(request, obj)
        exclude.extend(readonly_fields)
        # Exclude all fields if it's a change form and the user doesn't have
        # the change permission.
        if (
            change
            and hasattr(request, ""user"")
            and not self.has_change_permission(request, obj)
        ):
            exclude.extend(fields)
        if excluded is None and hasattr(self.form, ""_meta"") and self.form._meta.exclude:
            # Take the custom ModelForm's Meta.exclude into account only if the
            # ModelAdmin doesn't define its own.
            exclude.extend(self.form._meta.exclude)
        # if exclude is an empty list we pass None to be consistent with the
        # default on modelform_factory
        exclude = exclude or None

        # Remove declared form fields which are in readonly_fields.
        new_attrs = dict.fromkeys(
            f for f in readonly_fields if f in self.form.declared_fields
        )
        form = type(self.form.__name__, (self.form,), new_attrs)

        defaults = {
            ""form"": form,
            ""fields"": fields,
            ""exclude"": exclude,
            ""formfield_callback"": partial(self.formfield_for_dbfield, request=request),
            **kwargs,
        }

        if defaults[""fields""] is None and not modelform_defines_fields(
            defaults[""form""]
        ):
            defaults[""fields""] = forms.ALL_FIELDS

        try:
            return modelform_factory(self.model, **defaults)
        except FieldError as e:
            raise FieldError(
                ""%s. Check fields/fieldsets/exclude attributes of class %s.""
                % (e, self.__class__.__name__)
            )

    def get_changelist(self, request, **kwargs):
        """"""
        Return the ChangeList class for use on the changelist page.
        """"""
        from django.contrib.admin.views.main import ChangeList

        return ChangeList

    def get_changelist_instance(self, request):
        """"""
        Return a `ChangeList` instance based on `request`. May raise
        `IncorrectLookupParameters`.
        """"""
        list_display = self.get_list_display(request)
        list_display_links = self.get_list_display_links(request, list_display)
        # Add the action checkboxes if any actions are available.
        if self.get_actions(request):
            list_display = [""action_checkbox"", *list_display]
        sortable_by = self.get_sortable_by(request)
        ChangeList = self.get_changelist(request)
        return ChangeList(
            request,
            self.model,
            list_display,
            list_display_links,
            self.get_list_filter(request),
            self.date_hierarchy,
            self.get_search_fields(request),
            self.get_list_select_related(request),
            self.list_per_page,
            self.list_max_show_all,
            self.list_editable,
            self,
            sortable_by,
            self.search_help_text,
        )

    def get_object(self, request, object_id, from_field=None):
        """"""
        Return an instance matching the field and value provided, the primary
        key is used if no field is provided. Return ``None`` if no match is
        found or the object_id fails validation.
        """"""
        queryset = self.get_queryset(request)
        model = queryset.model
        field = (
            model._meta.pk if from_field is None else model._meta.get_field(from_field)
        )
        try:
            object_id = field.to_python(object_id)
            return queryset.get(**{field.name: object_id})
        except (model.DoesNotExist, ValidationError, ValueError):
            return None

    def get_changelist_form(self, request, **kwargs):
        """"""
        Return a Form class for use in the Formset on the changelist page.
        """"""
        defaults = {
            ""formfield_callback"": partial(self.formfield_for_dbfield, request=request),
            **kwargs,
        }
        if defaults.get(""fields"") is None and not modelform_defines_fields(
            defaults.get(""form"")
        ):
            defaults[""fields""] = forms.ALL_FIELDS

        return modelform_factory(self.model, **defaults)

    def get_changelist_formset(self, request, **kwargs):
        """"""
        Return a FormSet class for use on the changelist page if list_editable
        is used.
        """"""
        defaults = {
            ""formfield_callback"": partial(self.formfield_for_dbfield, request=request),
            **kwargs,
        }
        return modelformset_factory(
            self.model,
            self.get_changelist_form(request),
            extra=0,
            fields=self.list_editable,
            **defaults,
        )

    def get_formsets_with_inlines(self, request, obj=None):
        """"""
        Yield formsets and the corresponding inlines.
        """"""
        for inline in self.get_inline_instances(request, obj):
            yield inline.get_formset(request, obj), inline

    def get_paginator(
        self, request, queryset, per_page, orphans=0, allow_empty_first_page=True
    ):
        return self.paginator(queryset, per_page, orphans, allow_empty_first_page)

    def log_addition(self, request, obj, message):
        """"""
        Log that an object has been successfully added.

        The default implementation creates an admin LogEntry object.
        """"""
        from django.contrib.admin.models import ADDITION, LogEntry

        return LogEntry.objects.log_action(
            user_id=request.user.pk,
            content_type_id=get_content_type_for_model(obj).pk,
            object_id=obj.pk,
            object_repr=str(obj),
            action_flag=ADDITION,
            change_message=message,
        )

    def log_change(self, request, obj, message):
        """"""
        Log that an object has been successfully changed.

        The default implementation creates an admin LogEntry object.
        """"""
        from django.contrib.admin.models import CHANGE, LogEntry

        return LogEntry.objects.log_action(
            user_id=request.user.pk,
            content_type_id=get_content_type_for_model(obj).pk,
            object_id=obj.pk,
            object_repr=str(obj),
            action_flag=CHANGE,
            change_message=message,
        )

    def log_deletion(self, request, obj, object_repr):
        """"""
        Log that an object will be deleted. Note that this method must be
        called before the deletion.

        The default implementation creates an admin LogEntry object.
        """"""
        from django.contrib.admin.models import DELETION, LogEntry

        return LogEntry.objects.log_action(
            user_id=request.user.pk,
            content_type_id=get_content_type_for_model(obj).pk,
            object_id=obj.pk,
            object_repr=object_repr,
            action_flag=DELETION,
        )

    @display(description=mark_safe('<input type=""checkbox"" id=""action-toggle"">'))
    def action_checkbox(self, obj):
        """"""
        A list_display column containing a checkbox widget.
        """"""
        return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))

    @staticmethod
    def _get_action_description(func, name):
        return getattr(func, ""short_description"", capfirst(name.replace(""_"", "" "")))

    def _get_base_actions(self):
        """"""Return the list of actions, prior to any request-based filtering.""""""
        actions = []
        base_actions = (self.get_action(action) for action in self.actions or [])
        # get_action might have returned None, so filter any of those out.
        base_actions = [action for action in base_actions if action]
        base_action_names = {name for _, name, _ in base_actions}

        # Gather actions from the admin site first
        for (name, func) in self.admin_site.actions:
            if name in base_action_names:
                continue
            description = self._get_action_description(func, name)
            actions.append((func, name, description))
        # Add actions from this ModelAdmin.
        actions.extend(base_actions)
        return actions

    def _filter_actions_by_permissions(self, request, actions):
        """"""Filter out any actions that the user doesn't have access to.""""""
        filtered_actions = []
        for action in actions:
            callable = action[0]
            if not hasattr(callable, ""allowed_permissions""):
                filtered_actions.append(action)
                continue
            permission_checks = (
                getattr(self, ""has_%s_permission"" % permission)
                for permission in callable.allowed_permissions
            )
            if any(has_permission(request) for has_permission in permission_checks):
                filtered_actions.append(action)
        return filtered_actions

    def get_actions(self, request):
        """"""
        Return a dictionary mapping the names of all actions for this
        ModelAdmin to a tuple of (callable, name, description) for each action.
        """"""
        # If self.actions is set to None that means actions are disabled on
        # this page.
        if self.actions is None or IS_POPUP_VAR in request.GET:
            return {}
        actions = self._filter_actions_by_permissions(request, self._get_base_actions())
        return {name: (func, name, desc) for func, name, desc in actions}

    def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
        """"""
        Return a list of choices for use in a form object.  Each choice is a
        tuple (name, description).
        """"""
        choices = [] + default_choices
        for func, name, description in self.get_actions(request).values():
            choice = (name, description % model_format_dict(self.opts))
            choices.append(choice)
        return choices

    def get_action(self, action):
        """"""
        Return a given action from a parameter, which can either be a callable,
        or the name of a method on the ModelAdmin.  Return is a tuple of
        (callable, name, description).
        """"""
        # If the action is a callable, just use it.
        if callable(action):
            func = action
            action = action.__name__

        # Next, look for a method. Grab it off self.__class__ to get an unbound
        # method instead of a bound one; this ensures that the calling
        # conventions are the same for functions and methods.
        elif hasattr(self.__class__, action):
            func = getattr(self.__class__, action)

        # Finally, look for a named method on the admin site
        else:
            try:
                func = self.admin_site.get_action(action)
            except KeyError:
                return None

        description = self._get_action_description(func, action)
        return func, action, description

    def get_list_display(self, request):
        """"""
        Return a sequence containing the fields to be displayed on the
        changelist.
        """"""
        return self.list_display

    def get_list_display_links(self, request, list_display):
        """"""
        Return a sequence containing the fields to be displayed as links
        on the changelist. The list_display parameter is the list of fields
        returned by get_list_display().
        """"""
        if (
            self.list_display_links
            or self.list_display_links is None
            or not list_display
        ):
            return self.list_display_links
        else:
            # Use only the first item in list_display as link
            return list(list_display)[:1]

    def get_list_filter(self, request):
        """"""
        Return a sequence containing the fields to be displayed as filters in
        the right sidebar of the changelist page.
        """"""
        return self.list_filter

    def get_list_select_related(self, request):
        """"""
        Return a list of fields to add to the select_related() part of the
        changelist items query.
        """"""
        return self.list_select_related

    def get_search_fields(self, request):
        """"""
        Return a sequence containing the fields to be searched whenever
        somebody submits a search query.
        """"""
        return self.search_fields

    def get_search_results(self, request, queryset, search_term):
        """"""
        Return a tuple containing a queryset to implement the search
        and a boolean indicating if the results may contain duplicates.
        """"""
        # Apply keyword searches.
        def construct_search(field_name):
            if field_name.startswith(""^""):
                return ""%s__istartswith"" % field_name[1:]
            elif field_name.startswith(""=""):
                return ""%s__iexact"" % field_name[1:]
            elif field_name.startswith(""@""):
                return ""%s__search"" % field_name[1:]
            # Use field_name if it includes a lookup.
            opts = queryset.model._meta
            lookup_fields = field_name.split(LOOKUP_SEP)
            # Go through the fields, following all relations.
            prev_field = None
            for path_part in lookup_fields:
                if path_part == ""pk"":
                    path_part = opts.pk.name
                try:
                    field = opts.get_field(path_part)
                except FieldDoesNotExist:
                    # Use valid query lookups.
                    if prev_field and prev_field.get_lookup(path_part):
                        return field_name
                else:
                    prev_field = field
                    if hasattr(field, ""path_infos""):
                        # Update opts to follow the relation.
                        opts = field.path_infos[-1].to_opts
            # Otherwise, use the field with icontains.
            return ""%s__icontains"" % field_name

        may_have_duplicates = False
        search_fields = self.get_search_fields(request)
        if search_fields and search_term:
            orm_lookups = [
                construct_search(str(search_field)) for search_field in search_fields
            ]
            term_queries = []
            for bit in smart_split(search_term):
                if bit.startswith(('""', ""'"")) and bit[0] == bit[-1]:
                    bit = unescape_string_literal(bit)
                or_queries = models.Q(
                    *((orm_lookup, bit) for orm_lookup in orm_lookups),
                    _connector=models.Q.OR,
                )
                term_queries.append(or_queries)
            queryset = queryset.filter(models.Q(*term_queries))
            may_have_duplicates |= any(
                lookup_spawns_duplicates(self.opts, search_spec)
                for search_spec in orm_lookups
            )
        return queryset, may_have_duplicates

    def get_preserved_filters(self, request):
        """"""
        Return the preserved filters querystring.
        """"""
        match = request.resolver_match
        if self.preserve_filters and match:
            opts = self.model._meta
            current_url = ""%s:%s"" % (match.app_name, match.url_name)
            changelist_url = ""admin:%s_%s_changelist"" % (
                opts.app_label,
                opts.model_name,
            )
            if current_url == changelist_url:
                preserved_filters = request.GET.urlencode()
            else:
                preserved_filters = request.GET.get(""_changelist_filters"")

            if preserved_filters:
                return urlencode({""_changelist_filters"": preserved_filters})
        return """"

    def construct_change_message(self, request, form, formsets, add=False):
        """"""
        Construct a JSON structure describing changes from a changed object.
        """"""
        return construct_change_message(form, formsets, add)

    def message_user(
        self, request, message, level=messages.INFO, extra_tags="""", fail_silently=False
    ):
        """"""
        Send a message to the user. The default implementation
        posts a message using the django.contrib.messages backend.

        Exposes almost the same API as messages.add_message(), but accepts the
        positional arguments in a different order to maintain backwards
        compatibility. For convenience, it accepts the `level` argument as
        a string rather than the usual level number.
        """"""
        if not isinstance(level, int):
            # attempt to get the level if passed a string
            try:
                level = getattr(messages.constants, level.upper())
            except AttributeError:
                levels = messages.constants.DEFAULT_TAGS.values()
                levels_repr = "", "".join(""`%s`"" % level for level in levels)
                raise ValueError(
                    ""Bad message level string: `%s`. Possible values are: %s""
                    % (level, levels_repr)
                )

        messages.add_message(
            request, level, message, extra_tags=extra_tags, fail_silently=fail_silently
        )

    def save_form(self, request, form, change):
        """"""
        Given a ModelForm return an unsaved instance. ``change`` is True if
        the object is being changed, and False if it's being added.
        """"""
        return form.save(commit=False)

    def save_model(self, request, obj, form, change):
        """"""
        Given a model instance save it to the database.
        """"""
        obj.save()

    def delete_model(self, request, obj):
        """"""
        Given a model instance delete it from the database.
        """"""
        obj.delete()

    def delete_queryset(self, request, queryset):
        """"""Given a queryset, delete it from the database.""""""
        queryset.delete()

    def save_formset(self, request, form, formset, change):
        """"""
        Given an inline formset save it to the database.
        """"""
        formset.save()

    def save_related(self, request, form, formsets, change):
        """"""
        Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
        list of inline formsets and a boolean value based on whether the
        parent is being added or changed, save the related objects to the
        database. Note that at this point save_form() and save_model() have
        already been called.
        """"""
        form.save_m2m()
        for formset in formsets:
            self.save_formset(request, form, formset, change=change)

    def render_change_form(
        self, request, context, add=False, change=False, form_url="""", obj=None
    ):
        opts = self.model._meta
        app_label = opts.app_label
        preserved_filters = self.get_preserved_filters(request)
        form_url = add_preserved_filters(
            {""preserved_filters"": preserved_filters, ""opts"": opts}, form_url
        )
        view_on_site_url = self.get_view_on_site_url(obj)
        has_editable_inline_admin_formsets = False
        for inline in context[""inline_admin_formsets""]:
            if (
                inline.has_add_permission
                or inline.has_change_permission
                or inline.has_delete_permission
            ):
                has_editable_inline_admin_formsets = True
                break
        context.update(
            {
                ""add"": add,
                ""change"": change,
                ""has_view_permission"": self.has_view_permission(request, obj),
                ""has_add_permission"": self.has_add_permission(request),
                ""has_change_permission"": self.has_change_permission(request, obj),
                ""has_delete_permission"": self.has_delete_permission(request, obj),
                ""has_editable_inline_admin_formsets"": (
                    has_editable_inline_admin_formsets
                ),
                ""has_file_field"": context[""adminform""].form.is_multipart()
                or any(
                    admin_formset.formset.is_multipart()
                    for admin_formset in context[""inline_admin_formsets""]
                ),
                ""has_absolute_url"": view_on_site_url is not None,
                ""absolute_url"": view_on_site_url,
                ""form_url"": form_url,
                ""opts"": opts,
                ""content_type_id"": get_content_type_for_model(self.model).pk,
                ""save_as"": self.save_as,
                ""save_on_top"": self.save_on_top,
                ""to_field_var"": TO_FIELD_VAR,
                ""is_popup_var"": IS_POPUP_VAR,
                ""app_label"": app_label,
            }
        )
        if add and self.add_form_template is not None:
            form_template = self.add_form_template
        else:
            form_template = self.change_form_template

        request.current_app = self.admin_site.name

        return TemplateResponse(
            request,
            form_template
            or [
                ""admin/%s/%s/change_form.html"" % (app_label, opts.model_name),
                ""admin/%s/change_form.html"" % app_label,
                ""admin/change_form.html"",
            ],
            context,
        )

    def response_add(self, request, obj, post_url_continue=None):
        """"""
        Determine the HttpResponse for the add_view stage.
        """"""
        opts = obj._meta
        preserved_filters = self.get_preserved_filters(request)
        obj_url = reverse(
            ""admin:%s_%s_change"" % (opts.app_label, opts.model_name),
            args=(quote(obj.pk),),
            current_app=self.admin_site.name,
        )
        # Add a link to the object's change form if the user can edit the obj.
        if self.has_change_permission(request, obj):
            obj_repr = format_html('<a href=""{}"">{}</a>', urlquote(obj_url), obj)
        else:
            obj_repr = str(obj)
        msg_dict = {
            ""name"": opts.verbose_name,
            ""obj"": obj_repr,
        }
        # Here, we distinguish between different save types by checking for
        # the presence of keys in request.POST.

        if IS_POPUP_VAR in request.POST:
            to_field = request.POST.get(TO_FIELD_VAR)
            if to_field:
                attr = str(to_field)
            else:
                attr = obj._meta.pk.attname
            value = obj.serializable_value(attr)
            popup_response_data = json.dumps(
                {
                    ""value"": str(value),
                    ""obj"": str(obj),
                }
            )
            return TemplateResponse(
                request,
                self.popup_response_template
                or [
                    ""admin/%s/%s/popup_response.html""
                    % (opts.app_label, opts.model_name),
                    ""admin/%s/popup_response.html"" % opts.app_label,
                    ""admin/popup_response.html"",
                ],
                {
                    ""popup_response_data"": popup_response_data,
                },
            )

        elif ""_continue"" in request.POST or (
            # Redirecting after ""Save as new"".
            ""_saveasnew"" in request.POST
            and self.save_as_continue
            and self.has_change_permission(request, obj)
        ):
            msg = _(""The {name} “{obj}” was added successfully."")
            if self.has_change_permission(request, obj):
                msg += "" "" + _(""You may edit it again below."")
            self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
            if post_url_continue is None:
                post_url_continue = obj_url
            post_url_continue = add_preserved_filters(
                {""preserved_filters"": preserved_filters, ""opts"": opts},
                post_url_continue,
            )
            return HttpResponseRedirect(post_url_continue)

        elif ""_addanother"" in request.POST:
            msg = format_html(
                _(
                    ""The {name} “{obj}” was added successfully. You may add another ""
                    ""{name} below.""
                ),
                **msg_dict,
            )
            self.message_user(request, msg, messages.SUCCESS)
            redirect_url = request.path
            redirect_url = add_preserved_filters(
                {""preserved_filters"": preserved_filters, ""opts"": opts}, redirect_url
            )
            return HttpResponseRedirect(redirect_url)

        else:
            msg = format_html(
                _(""The {name} “{obj}” was added successfully.""), **msg_dict
            )
            self.message_user(request, msg, messages.SUCCESS)
            return self.response_post_save_add(request, obj)

    def response_change(self, request, obj):
        """"""
        Determine the HttpResponse for the change_view stage.
        """"""

        if IS_POPUP_VAR in request.POST:
            opts = obj._meta
            to_field = request.POST.get(TO_FIELD_VAR)
            attr = str(to_field) if to_field else opts.pk.attname
            value = request.resolver_match.kwargs[""object_id""]
            new_value = obj.serializable_value(attr)
            popup_response_data = json.dumps(
                {
                    ""action"": ""change"",
                    ""value"": str(value),
                    ""obj"": str(obj),
                    ""new_value"": str(new_value),
                }
            )
            return TemplateResponse(
                request,
                self.popup_response_template
                or [
                    ""admin/%s/%s/popup_response.html""
                    % (opts.app_label, opts.model_name),
                    ""admin/%s/popup_response.html"" % opts.app_label,
                    ""admin/popup_response.html"",
                ],
                {
                    ""popup_response_data"": popup_response_data,
                },
            )

        opts = self.model._meta
        preserved_filters = self.get_preserved_filters(request)

        msg_dict = {
            ""name"": opts.verbose_name,
            ""obj"": format_html('<a href=""{}"">{}</a>', urlquote(request.path), obj),
        }
        if ""_continue"" in request.POST:
            msg = format_html(
                _(
                    ""The {name} “{obj}” was changed successfully. You may edit it ""
                    ""again below.""
                ),
                **msg_dict,
            )
            self.message_user(request, msg, messages.SUCCESS)
            redirect_url = request.path
            redirect_url = add_preserved_filters(
                {""preserved_filters"": preserved_filters, ""opts"": opts}, redirect_url
            )
            return HttpResponseRedirect(redirect_url)

        elif ""_saveasnew"" in request.POST:
            msg = format_html(
                _(
                    ""The {name} “{obj}” was added successfully. You may edit it again ""
                    ""below.""
                ),
                **msg_dict,
            )
            self.message_user(request, msg, messages.SUCCESS)
            redirect_url = reverse(
                ""admin:%s_%s_change"" % (opts.app_label, opts.model_name),
                args=(obj.pk,),
                current_app=self.admin_site.name,
            )
            redirect_url = add_preserved_filters(
                {""preserved_filters"": preserved_filters, ""opts"": opts}, redirect_url
            )
            return HttpResponseRedirect(redirect_url)

        elif ""_addanother"" in request.POST:
            msg = format_html(
                _(
                    ""The {name} “{obj}” was changed successfully. You may add another ""
                    ""{name} below.""
                ),
                **msg_dict,
            )
            self.message_user(request, msg, messages.SUCCESS)
            redirect_url = reverse(
                ""admin:%s_%s_add"" % (opts.app_label, opts.model_name),
                current_app=self.admin_site.name,
            )
            redirect_url = add_preserved_filters(
                {""preserved_filters"": preserved_filters, ""opts"": opts}, redirect_url
            )
            return HttpResponseRedirect(redirect_url)

        else:
            msg = format_html(
                _(""The {name} “{obj}” was changed successfully.""), **msg_dict
            )
            self.message_user(request, msg, messages.SUCCESS)
            return self.response_post_save_change(request, obj)

    def _response_post_save(self, request, obj):
        opts = self.model._meta
        if self.has_view_or_change_permission(request):
            post_url = reverse(
                ""admin:%s_%s_changelist"" % (opts.app_label, opts.model_name),
                current_app=self.admin_site.name,
            )
            preserved_filters = self.get_preserved_filters(request)
            post_url = add_preserved_filters(
                {""preserved_filters"": preserved_filters, ""opts"": opts}, post_url
            )
        else:
            post_url = reverse(""admin:index"", current_app=self.admin_site.name)
        return HttpResponseRedirect(post_url)

    def response_post_save_add(self, request, obj):
        """"""
        Figure out where to redirect after the 'Save' button has been pressed
        when adding a new object.
        """"""
        return self._response_post_save(request, obj)

    def response_post_save_change(self, request, obj):
        """"""
        Figure out where to redirect after the 'Save' button has been pressed
        when editing an existing object.
        """"""
        return self._response_post_save(request, obj)

    def response_action(self, request, queryset):
        """"""
        Handle an admin action. This is called if a request is POSTed to the
        changelist; it returns an HttpResponse if the action was handled, and
        None otherwise.
        """"""

        # There can be multiple action forms on the page (at the top
        # and bottom of the change list, for example). Get the action
        # whose button was pushed.
        try:
            action_index = int(request.POST.get(""index"", 0))
        except ValueError:
            action_index = 0

        # Construct the action form.
        data = request.POST.copy()
        data.pop(helpers.ACTION_CHECKBOX_NAME, None)
        data.pop(""index"", None)

        # Use the action whose button was pushed
        try:
            data.update({""action"": data.getlist(""action"")[action_index]})
        except IndexError:
            # If we didn't get an action from the chosen form that's invalid
            # POST data, so by deleting action it'll fail the validation check
            # below. So no need to do anything here
            pass

        action_form = self.action_form(data, auto_id=None)
        action_form.fields[""action""].choices = self.get_action_choices(request)

        # If the form's valid we can handle the action.
        if action_form.is_valid():
            action = action_form.cleaned_data[""action""]
            select_across = action_form.cleaned_data[""select_across""]
            func = self.get_actions(request)[action][0]

            # Get the list of selected PKs. If nothing's selected, we can't
            # perform an action on it, so bail. Except we want to perform
            # the action explicitly on all objects.
            selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
            if not selected and not select_across:
                # Reminder that something needs to be selected or nothing will happen
                msg = _(
                    ""Items must be selected in order to perform ""
                    ""actions on them. No items have been changed.""
                )
                self.message_user(request, msg, messages.WARNING)
                return None

            if not select_across:
                # Perform the action only on the selected objects
                queryset = queryset.filter(pk__in=selected)

            response = func(self, request, queryset)

            # Actions may return an HttpResponse-like object, which will be
            # used as the response from the POST. If not, we'll be a good
            # little HTTP citizen and redirect back to the changelist page.
            if isinstance(response, HttpResponseBase):
                return response
            else:
                return HttpResponseRedirect(request.get_full_path())
        else:
            msg = _(""No action selected."")
            self.message_user(request, msg, messages.WARNING)
            return None

    def response_delete(self, request, obj_display, obj_id):
        """"""
        Determine the HttpResponse for the delete_view stage.
        """"""
        opts = self.model._meta

        if IS_POPUP_VAR in request.POST:
            popup_response_data = json.dumps(
                {
                    ""action"": ""delete"",
                    ""value"": str(obj_id),
                }
            )
            return TemplateResponse(
                request,
                self.popup_response_template
                or [
                    ""admin/%s/%s/popup_response.html""
                    % (opts.app_label, opts.model_name),
                    ""admin/%s/popup_response.html"" % opts.app_label,
                    ""admin/popup_response.html"",
                ],
                {
                    ""popup_response_data"": popup_response_data,
                },
            )

        self.message_user(
            request,
            _(""The %(name)s “%(obj)s” was deleted successfully."")
            % {
                ""name"": opts.verbose_name,
                ""obj"": obj_display,
            },
            messages.SUCCESS,
        )

        if self.has_change_permission(request, None):
            post_url = reverse(
                ""admin:%s_%s_changelist"" % (opts.app_label, opts.model_name),
                current_app=self.admin_site.name,
            )
            preserved_filters = self.get_preserved_filters(request)
            post_url = add_preserved_filters(
                {""preserved_filters"": preserved_filters, ""opts"": opts}, post_url
            )
        else:
            post_url = reverse(""admin:index"", current_app=self.admin_site.name)
        return HttpResponseRedirect(post_url)

    def render_delete_form(self, request, context):
        opts = self.model._meta
        app_label = opts.app_label

        request.current_app = self.admin_site.name
        context.update(
            to_field_var=TO_FIELD_VAR,
            is_popup_var=IS_POPUP_VAR,
            media=self.media,
        )

        return TemplateResponse(
            request,
            self.delete_confirmation_template
            or [
                ""admin/{}/{}/delete_confirmation.html"".format(
                    app_label, opts.model_name
                ),
                ""admin/{}/delete_confirmation.html"".format(app_label),
                ""admin/delete_confirmation.html"",
            ],
            context,
        )

    def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
        # Edit permissions on parent model are required for editable inlines.
        can_edit_parent = (
            self.has_change_permission(request, obj)
            if obj
            else self.has_add_permission(request)
        )
        inline_admin_formsets = []
        for inline, formset in zip(inline_instances, formsets):
            fieldsets = list(inline.get_fieldsets(request, obj))
            readonly = list(inline.get_readonly_fields(request, obj))
            if can_edit_parent:
                has_add_permission = inline.has_add_permission(request, obj)
                has_change_permission = inline.has_change_permission(request, obj)
                has_delete_permission = inline.has_delete_permission(request, obj)
            else:
                # Disable all edit-permissions, and overide formset settings.
                has_add_permission = (
                    has_change_permission
                ) = has_delete_permission = False
                formset.extra = formset.max_num = 0
            has_view_permission = inline.has_view_permission(request, obj)
            prepopulated = dict(inline.get_prepopulated_fields(request, obj))
            inline_admin_formset = helpers.InlineAdminFormSet(
                inline,
                formset,
                fieldsets,
                prepopulated,
                readonly,
                model_admin=self,
                has_add_permission=has_add_permission,
                has_change_permission=has_change_permission,
                has_delete_permission=has_delete_permission,
                has_view_permission=has_view_permission,
            )
            inline_admin_formsets.append(inline_admin_formset)
        return inline_admin_formsets

    def get_changeform_initial_data(self, request):
        """"""
        Get the initial form data from the request's GET params.
        """"""
        initial = dict(request.GET.items())
        for k in initial:
            try:
                f = self.model._meta.get_field(k)
            except FieldDoesNotExist:
                continue
            # We have to special-case M2Ms as a list of comma-separated PKs.
            if isinstance(f, models.ManyToManyField):
                initial[k] = initial[k].split("","")
        return initial

    def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
        """"""
        Create a message informing the user that the object doesn't exist
        and return a redirect to the admin index page.
        """"""
        msg = _(""%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?"") % {
            ""name"": opts.verbose_name,
            ""key"": unquote(object_id),
        }
        self.message_user(request, msg, messages.WARNING)
        url = reverse(""admin:index"", current_app=self.admin_site.name)
        return HttpResponseRedirect(url)

    @csrf_protect_m
    def changeform_view(self, request, object_id=None, form_url="""", extra_context=None):
        with transaction.atomic(using=router.db_for_write(self.model)):
            return self._changeform_view(request, object_id, form_url, extra_context)

    def _changeform_view(self, request, object_id, form_url, extra_context):
        to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
        if to_field and not self.to_field_allowed(request, to_field):
            raise DisallowedModelAdminToField(
                ""The field %s cannot be referenced."" % to_field
            )

        model = self.model
        opts = model._meta

        if request.method == ""POST"" and ""_saveasnew"" in request.POST:
            object_id = None

        add = object_id is None

        if add:
            if not self.has_add_permission(request):
                raise PermissionDenied
            obj = None

        else:
            obj = self.get_object(request, unquote(object_id), to_field)

            if request.method == ""POST"":
                if not self.has_change_permission(request, obj):
                    raise PermissionDenied
            else:
                if not self.has_view_or_change_permission(request, obj):
                    raise PermissionDenied

            if obj is None:
                return self._get_obj_does_not_exist_redirect(request, opts, object_id)

        fieldsets = self.get_fieldsets(request, obj)
        ModelForm = self.get_form(
            request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
        )
        if request.method == ""POST"":
            form = ModelForm(request.POST, request.FILES, instance=obj)
            formsets, inline_instances = self._create_formsets(
                request,
                form.instance,
                change=not add,
            )
            form_validated = form.is_valid()
            if form_validated:
                new_object = self.save_form(request, form, change=not add)
            else:
                new_object = form.instance
            if all_valid(formsets) and form_validated:
                self.save_model(request, new_object, form, not add)
                self.save_related(request, form, formsets, not add)
                change_message = self.construct_change_message(
                    request, form, formsets, add
                )
                if add:
                    self.log_addition(request, new_object, change_message)
                    return self.response_add(request, new_object)
                else:
                    self.log_change(request, new_object, change_message)
                    return self.response_change(request, new_object)
            else:
                form_validated = False
        else:
            if add:
                initial = self.get_changeform_initial_data(request)
                form = ModelForm(initial=initial)
                formsets, inline_instances = self._create_formsets(
                    request, form.instance, change=False
                )
            else:
                form = ModelForm(instance=obj)
                formsets, inline_instances = self._create_formsets(
                    request, obj, change=True
                )

        if not add and not self.has_change_permission(request, obj):
            readonly_fields = flatten_fieldsets(fieldsets)
        else:
            readonly_fields = self.get_readonly_fields(request, obj)
        adminForm = helpers.AdminForm(
            form,
            list(fieldsets),
            # Clear prepopulated fields on a view-only form to avoid a crash.
            self.get_prepopulated_fields(request, obj)
            if add or self.has_change_permission(request, obj)
            else {},
            readonly_fields,
            model_admin=self,
        )
        media = self.media + adminForm.media

        inline_formsets = self.get_inline_formsets(
            request, formsets, inline_instances, obj
        )
        for inline_formset in inline_formsets:
            media = media + inline_formset.media

        if add:
            title = _(""Add %s"")
        elif self.has_change_permission(request, obj):
            title = _(""Change %s"")
        else:
            title = _(""View %s"")
        context = {
            **self.admin_site.each_context(request),
            ""title"": title % opts.verbose_name,
            ""subtitle"": str(obj) if obj else None,
            ""adminform"": adminForm,
            ""object_id"": object_id,
            ""original"": obj,
            ""is_popup"": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
            ""to_field"": to_field,
            ""media"": media,
            ""inline_admin_formsets"": inline_formsets,
            ""errors"": helpers.AdminErrorList(form, formsets),
            ""preserved_filters"": self.get_preserved_filters(request),
        }

        # Hide the ""Save"" and ""Save and continue"" buttons if ""Save as New"" was
        # previously chosen to prevent the interface from getting confusing.
        if (
            request.method == ""POST""
            and not form_validated
            and ""_saveasnew"" in request.POST
        ):
            context[""show_save""] = False
            context[""show_save_and_continue""] = False
            # Use the change template instead of the add template.
            add = False

        context.update(extra_context or {})

        return self.render_change_form(
            request, context, add=add, change=not add, obj=obj, form_url=form_url
        )

    def add_view(self, request, form_url="""", extra_context=None):
        return self.changeform_view(request, None, form_url, extra_context)

    def change_view(self, request, object_id, form_url="""", extra_context=None):
        return self.changeform_view(request, object_id, form_url, extra_context)

    def _get_edited_object_pks(self, request, prefix):
        """"""Return POST data values of list_editable primary keys.""""""
        pk_pattern = re.compile(
            r""{}-\d+-{}$"".format(re.escape(prefix), self.model._meta.pk.name)
        )
        return [value for key, value in request.POST.items() if pk_pattern.match(key)]

    def _get_list_editable_queryset(self, request, prefix):
        """"""
        Based on POST data, return a queryset of the objects that were edited
        via list_editable.
        """"""
        object_pks = self._get_edited_object_pks(request, prefix)
        queryset = self.get_queryset(request)
        validate = queryset.model._meta.pk.to_python
        try:
            for pk in object_pks:
                validate(pk)
        except ValidationError:
            # Disable the optimization if the POST data was tampered with.
            return queryset
        return queryset.filter(pk__in=object_pks)

    @csrf_protect_m
    def changelist_view(self, request, extra_context=None):
        """"""
        The 'change list' admin view for this model.
        """"""
        from django.contrib.admin.views.main import ERROR_FLAG

        opts = self.model._meta
        app_label = opts.app_label
        if not self.has_view_or_change_permission(request):
            raise PermissionDenied

        try:
            cl = self.get_changelist_instance(request)
        except IncorrectLookupParameters:
            # Wacky lookup parameters were given, so redirect to the main
            # changelist page, without parameters, and pass an 'invalid=1'
            # parameter via the query string. If wacky parameters were given
            # and the 'invalid=1' parameter was already in the query string,
            # something is screwed up with the database, so display an error
            # page.
            if ERROR_FLAG in request.GET:
                return SimpleTemplateResponse(
                    ""admin/invalid_setup.html"",
                    {
                        ""title"": _(""Database error""),
                    },
                )
            return HttpResponseRedirect(request.path + ""?"" + ERROR_FLAG + ""=1"")

        # If the request was POSTed, this might be a bulk action or a bulk
        # edit. Try to look up an action or confirmation first, but if this
        # isn't an action the POST will fall through to the bulk edit check,
        # below.
        action_failed = False
        selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)

        actions = self.get_actions(request)
        # Actions with no confirmation
        if (
            actions
            and request.method == ""POST""
            and ""index"" in request.POST
            and ""_save"" not in request.POST
        ):
            if selected:
                response = self.response_action(
                    request, queryset=cl.get_queryset(request)
                )
                if response:
                    return response
                else:
                    action_failed = True
            else:
                msg = _(
                    ""Items must be selected in order to perform ""
                    ""actions on them. No items have been changed.""
                )
                self.message_user(request, msg, messages.WARNING)
                action_failed = True

        # Actions with confirmation
        if (
            actions
            and request.method == ""POST""
            and helpers.ACTION_CHECKBOX_NAME in request.POST
            and ""index"" not in request.POST
            and ""_save"" not in request.POST
        ):
            if selected:
                response = self.response_action(
                    request, queryset=cl.get_queryset(request)
                )
                if response:
                    return response
                else:
                    action_failed = True

        if action_failed:
            # Redirect back to the changelist page to avoid resubmitting the
            # form if the user refreshes the browser or uses the ""No, take
            # me back"" button on the action confirmation page.
            return HttpResponseRedirect(request.get_full_path())

        # If we're allowing changelist editing, we need to construct a formset
        # for the changelist given all the fields to be edited. Then we'll
        # use the formset to validate/process POSTed data.
        formset = cl.formset = None

        # Handle POSTed bulk-edit data.
        if request.method == ""POST"" and cl.list_editable and ""_save"" in request.POST:
            if not self.has_change_permission(request):
                raise PermissionDenied
            FormSet = self.get_changelist_formset(request)
            modified_objects = self._get_list_editable_queryset(
                request, FormSet.get_default_prefix()
            )
            formset = cl.formset = FormSet(
                request.POST, request.FILES, queryset=modified_objects
            )
            if formset.is_valid():
                changecount = 0
                for form in formset.forms:
                    if form.has_changed():
                        obj = self.save_form(request, form, change=True)
                        self.save_model(request, obj, form, change=True)
                        self.save_related(request, form, formsets=[], change=True)
                        change_msg = self.construct_change_message(request, form, None)
                        self.log_change(request, obj, change_msg)
                        changecount += 1

                if changecount:
                    msg = ngettext(
                        ""%(count)s %(name)s was changed successfully."",
                        ""%(count)s %(name)s were changed successfully."",
                        changecount,
                    ) % {
                        ""count"": changecount,
                        ""name"": model_ngettext(opts, changecount),
                    }
                    self.message_user(request, msg, messages.SUCCESS)

                return HttpResponseRedirect(request.get_full_path())

        # Handle GET -- construct a formset for display.
        elif cl.list_editable and self.has_change_permission(request):
            FormSet = self.get_changelist_formset(request)
            formset = cl.formset = FormSet(queryset=cl.result_list)

        # Build the list of media to be used by the formset.
        if formset:
            media = self.media + formset.media
        else:
            media = self.media

        # Build the action form and populate it with available actions.
        if actions:
            action_form = self.action_form(auto_id=None)
            action_form.fields[""action""].choices = self.get_action_choices(request)
            media += action_form.media
        else:
            action_form = None

        selection_note_all = ngettext(
            ""%(total_count)s selected"", ""All %(total_count)s selected"", cl.result_count
        )

        context = {
            **self.admin_site.each_context(request),
            ""module_name"": str(opts.verbose_name_plural),
            ""selection_note"": _(""0 of %(cnt)s selected"") % {""cnt"": len(cl.result_list)},
            ""selection_note_all"": selection_note_all % {""total_count"": cl.result_count},
            ""title"": cl.title,
            ""subtitle"": None,
            ""is_popup"": cl.is_popup,
            ""to_field"": cl.to_field,
            ""cl"": cl,
            ""media"": media,
            ""has_add_permission"": self.has_add_permission(request),
            ""opts"": cl.opts,
            ""action_form"": action_form,
            ""actions_on_top"": self.actions_on_top,
            ""actions_on_bottom"": self.actions_on_bottom,
            ""actions_selection_counter"": self.actions_selection_counter,
            ""preserved_filters"": self.get_preserved_filters(request),
            **(extra_context or {}),
        }

        request.current_app = self.admin_site.name

        return TemplateResponse(
            request,
            self.change_list_template
            or [
                ""admin/%s/%s/change_list.html"" % (app_label, opts.model_name),
                ""admin/%s/change_list.html"" % app_label,
                ""admin/change_list.html"",
            ],
            context,
        )

    def get_deleted_objects(self, objs, request):
        """"""
        Hook for customizing the delete process for the delete view and the
        ""delete selected"" action.
        """"""
        return get_deleted_objects(objs, request, self.admin_site)

    @csrf_protect_m
    def delete_view(self, request, object_id, extra_context=None):
        with transaction.atomic(using=router.db_for_write(self.model)):
            return self._delete_view(request, object_id, extra_context)

    def _delete_view(self, request, object_id, extra_context):
        ""The 'delete' admin view for this model.""
        opts = self.model._meta
        app_label = opts.app_label

        to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
        if to_field and not self.to_field_allowed(request, to_field):
            raise DisallowedModelAdminToField(
                ""The field %s cannot be referenced."" % to_field
            )

        obj = self.get_object(request, unquote(object_id), to_field)

        if not self.has_delete_permission(request, obj):
            raise PermissionDenied

        if obj is None:
            return self._get_obj_does_not_exist_redirect(request, opts, object_id)

        # Populate deleted_objects, a data structure of all related objects that
        # will also be deleted.
        (
            deleted_objects,
            model_count,
            perms_needed,
            protected,
        ) = self.get_deleted_objects([obj], request)

        if request.POST and not protected:  # The user has confirmed the deletion.
            if perms_needed:
                raise PermissionDenied
            obj_display = str(obj)
            attr = str(to_field) if to_field else opts.pk.attname
            obj_id = obj.serializable_value(attr)
            self.log_deletion(request, obj, obj_display)
            self.delete_model(request, obj)

            return self.response_delete(request, obj_display, obj_id)

        object_name = str(opts.verbose_name)

        if perms_needed or protected:
            title = _(""Cannot delete %(name)s"") % {""name"": object_name}
        else:
            title = _(""Are you sure?"")

        context = {
            **self.admin_site.each_context(request),
            ""title"": title,
            ""subtitle"": None,
            ""object_name"": object_name,
            ""object"": obj,
            ""deleted_objects"": deleted_objects,
            ""model_count"": dict(model_count).items(),
            ""perms_lacking"": perms_needed,
            ""protected"": protected,
            ""opts"": opts,
            ""app_label"": app_label,
            ""preserved_filters"": self.get_preserved_filters(request),
            ""is_popup"": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
            ""to_field"": to_field,
            **(extra_context or {}),
        }

        return self.render_delete_form(request, context)

    def history_view(self, request, object_id, extra_context=None):
        ""The 'history' admin view for this model.""
        from django.contrib.admin.models import LogEntry
        from django.contrib.admin.views.main import PAGE_VAR

        # First check if the user can see this history.
        model = self.model
        obj = self.get_object(request, unquote(object_id))
        if obj is None:
            return self._get_obj_does_not_exist_redirect(
                request, model._meta, object_id
            )

        if not self.has_view_or_change_permission(request, obj):
            raise PermissionDenied

        # Then get the history for this object.
        opts = model._meta
        app_label = opts.app_label
        action_list = (
            LogEntry.objects.filter(
                object_id=unquote(object_id),
                content_type=get_content_type_for_model(model),
            )
            .select_related()
            .order_by(""action_time"")
        )

        paginator = self.get_paginator(request, action_list, 100)
        page_number = request.GET.get(PAGE_VAR, 1)
        page_obj = paginator.get_page(page_number)
        page_range = paginator.get_elided_page_range(page_obj.number)

        context = {
            **self.admin_site.each_context(request),
            ""title"": _(""Change history: %s"") % obj,
            ""subtitle"": None,
            ""action_list"": page_obj,
            ""page_range"": page_range,
            ""page_var"": PAGE_VAR,
            ""pagination_required"": paginator.count > 100,
            ""module_name"": str(capfirst(opts.verbose_name_plural)),
            ""object"": obj,
            ""opts"": opts,
            ""preserved_filters"": self.get_preserved_filters(request),
            **(extra_context or {}),
        }

        request.current_app = self.admin_site.name

        return TemplateResponse(
            request,
            self.object_history_template
            or [
                ""admin/%s/%s/object_history.html"" % (app_label, opts.model_name),
                ""admin/%s/object_history.html"" % app_label,
                ""admin/object_history.html"",
            ],
            context,
        )

    def get_formset_kwargs(self, request, obj, inline, prefix):
        formset_params = {
            ""instance"": obj,
            ""prefix"": prefix,
            ""queryset"": inline.get_queryset(request),
        }
        if request.method == ""POST"":
            formset_params.update(
                {
                    ""data"": request.POST.copy(),
                    ""files"": request.FILES,
                    ""save_as_new"": ""_saveasnew"" in request.POST,
                }
            )
        return formset_params

    def _create_formsets(self, request, obj, change):
        ""Helper function to generate formsets for add/change_view.""
        formsets = []
        inline_instances = []
        prefixes = {}
        get_formsets_args = [request]
        if change:
            get_formsets_args.append(obj)
        for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
            prefix = FormSet.get_default_prefix()
            prefixes[prefix] = prefixes.get(prefix, 0) + 1
            if prefixes[prefix] != 1 or not prefix:
                prefix = ""%s-%s"" % (prefix, prefixes[prefix])
            formset_params = self.get_formset_kwargs(request, obj, inline, prefix)
            formset = FormSet(**formset_params)

            def user_deleted_form(request, obj, formset, index):
                """"""Return whether or not the user deleted the form.""""""
                return (
                    inline.has_delete_permission(request, obj)
                    and ""{}-{}-DELETE"".format(formset.prefix, index) in request.POST
                )

            # Bypass validation of each view-only inline form (since the form's
            # data won't be in request.POST), unless the form was deleted.
            if not inline.has_change_permission(request, obj if change else None):
                for index, form in enumerate(formset.initial_forms):
                    if user_deleted_form(request, obj, formset, index):
                        continue
                    form._errors = {}
                    form.cleaned_data = form.initial
            formsets.append(formset)
            inline_instances.append(inline)
        return formsets, inline_instances


class InlineModelAdmin(BaseModelAdmin):
    """"""
    Options for inline editing of ``model`` instances.

    Provide ``fk_name`` to specify the attribute name of the ``ForeignKey``
    from ``model`` to its parent. This is required if ``model`` has more than
    one ``ForeignKey`` to its parent.
    """"""

    model = None
    fk_name = None
    formset = BaseInlineFormSet
    extra = 3
    min_num = None
    max_num = None
    template = None
    verbose_name = None
    verbose_name_plural = None
    can_delete = True
    show_change_link = False
    checks_class = InlineModelAdminChecks
    classes = None

    def __init__(self, parent_model, admin_site):
        self.admin_site = admin_site
        self.parent_model = parent_model
        self.opts = self.model._meta
        self.has_registered_model = admin_site.is_registered(self.model)
        super().__init__()
        if self.verbose_name_plural is None:
            if self.verbose_name is None:
                self.verbose_name_plural = self.model._meta.verbose_name_plural
            else:
                self.verbose_name_plural = format_lazy(""{}s"", self.verbose_name)
        if self.verbose_name is None:
            self.verbose_name = self.model._meta.verbose_name

    @property
    def media(self):
        extra = """" if settings.DEBUG else "".min""
        js = [""vendor/jquery/jquery%s.js"" % extra, ""jquery.init.js"", ""inlines.js""]
        if self.filter_vertical or self.filter_horizontal:
            js.extend([""SelectBox.js"", ""SelectFilter2.js""])
        if self.classes and ""collapse"" in self.classes:
            js.append(""collapse.js"")
        return forms.Media(js=[""admin/js/%s"" % url for url in js])

    def get_extra(self, request, obj=None, **kwargs):
        """"""Hook for customizing the number of extra inline forms.""""""
        return self.extra

    def get_min_num(self, request, obj=None, **kwargs):
        """"""Hook for customizing the min number of inline forms.""""""
        return self.min_num

    def get_max_num(self, request, obj=None, **kwargs):
        """"""Hook for customizing the max number of extra inline forms.""""""
        return self.max_num

    def get_formset(self, request, obj=None, **kwargs):
        """"""Return a BaseInlineFormSet class for use in admin add/change views.""""""
        if ""fields"" in kwargs:
            fields = kwargs.pop(""fields"")
        else:
            fields = flatten_fieldsets(self.get_fieldsets(request, obj))
        excluded = self.get_exclude(request, obj)
        exclude = [] if excluded is None else list(excluded)
        exclude.extend(self.get_readonly_fields(request, obj))
        if excluded is None and hasattr(self.form, ""_meta"") and self.form._meta.exclude:
            # Take the custom ModelForm's Meta.exclude into account only if the
            # InlineModelAdmin doesn't define its own.
            exclude.extend(self.form._meta.exclude)
        # If exclude is an empty list we use None, since that's the actual
        # default.
        exclude = exclude or None
        can_delete = self.can_delete and self.has_delete_permission(request, obj)
        defaults = {
            ""form"": self.form,
            ""formset"": self.formset,
            ""fk_name"": self.fk_name,
            ""fields"": fields,
            ""exclude"": exclude,
            ""formfield_callback"": partial(self.formfield_for_dbfield, request=request),
            ""extra"": self.get_extra(request, obj, **kwargs),
            ""min_num"": self.get_min_num(request, obj, **kwargs),
            ""max_num"": self.get_max_num(request, obj, **kwargs),
            ""can_delete"": can_delete,
            **kwargs,
        }

        base_model_form = defaults[""form""]
        can_change = self.has_change_permission(request, obj) if request else True
        can_add = self.has_add_permission(request, obj) if request else True

        class DeleteProtectedModelForm(base_model_form):
            def hand_clean_DELETE(self):
                """"""
                We don't validate the 'DELETE' field itself because on
                templates it's not rendered using the field information, but
                just using a generic ""deletion_field"" of the InlineModelAdmin.
                """"""
                if self.cleaned_data.get(DELETION_FIELD_NAME, False):
                    using = router.db_for_write(self._meta.model)
                    collector = NestedObjects(using=using)
                    if self.instance._state.adding:
                        return
                    collector.collect([self.instance])
                    if collector.protected:
                        objs = []
                        for p in collector.protected:
                            objs.append(
                                # Translators: Model verbose name and instance
                                # representation, suitable to be an item in a
                                # list.
                                _(""%(class_name)s %(instance)s"")
                                % {""class_name"": p._meta.verbose_name, ""instance"": p}
                            )
                        params = {
                            ""class_name"": self._meta.model._meta.verbose_name,
                            ""instance"": self.instance,
                            ""related_objects"": get_text_list(objs, _(""and"")),
                        }
                        msg = _(
                            ""Deleting %(class_name)s %(instance)s would require ""
                            ""deleting the following protected related objects: ""
                            ""%(related_objects)s""
                        )
                        raise ValidationError(
                            msg, code=""deleting_protected"", params=params
                        )

            def is_valid(self):
                result = super().is_valid()
                self.hand_clean_DELETE()
                return result

            def has_changed(self):
                # Protect against unauthorized edits.
                if not can_change and not self.instance._state.adding:
                    return False
                if not can_add and self.instance._state.adding:
                    return False
                return super().has_changed()

        defaults[""form""] = DeleteProtectedModelForm

        if defaults[""fields""] is None and not modelform_defines_fields(
            defaults[""form""]
        ):
            defaults[""fields""] = forms.ALL_FIELDS

        return inlineformset_factory(self.parent_model, self.model, **defaults)

    def _get_form_for_get_fields(self, request, obj=None):
        return self.get_formset(request, obj, fields=None).form

    def get_queryset(self, request):
        queryset = super().get_queryset(request)
        if not self.has_view_or_change_permission(request):
            queryset = queryset.none()
        return queryset

    def _has_any_perms_for_target_model(self, request, perms):
        """"""
        This method is called only when the ModelAdmin's model is for an
        ManyToManyField's implicit through model (if self.opts.auto_created).
        Return True if the user has any of the given permissions ('add',
        'change', etc.) for the model that points to the through model.
        """"""
        opts = self.opts
        # Find the target model of an auto-created many-to-many relationship.
        for field in opts.fields:
            if field.remote_field and field.remote_field.model != self.parent_model:
                opts = field.remote_field.model._meta
                break
        return any(
            request.user.has_perm(
                ""%s.%s"" % (opts.app_label, get_permission_codename(perm, opts))
            )
            for perm in perms
        )

    def has_add_permission(self, request, obj):
        if self.opts.auto_created:
            # Auto-created intermediate models don't have their own
            # permissions. The user needs to have the change permission for the
            # related model in order to be able to do anything with the
            # intermediate model.
            return self._has_any_perms_for_target_model(request, [""change""])
        return super().has_add_permission(request)

    def has_change_permission(self, request, obj=None):
        if self.opts.auto_created:
            # Same comment as has_add_permission().
            return self._has_any_perms_for_target_model(request, [""change""])
        return super().has_change_permission(request)

    def has_delete_permission(self, request, obj=None):
        if self.opts.auto_created:
            # Same comment as has_add_permission().
            return self._has_any_perms_for_target_model(request, [""change""])
        return super().has_delete_permission(request, obj)

    def has_view_permission(self, request, obj=None):
        if self.opts.auto_created:
            # Same comment as has_add_permission(). The 'change' permission
            # also implies the 'view' permission.
            return self._has_any_perms_for_target_model(request, [""view"", ""change""])
        return super().has_view_permission(request)


class StackedInline(InlineModelAdmin):
    template = ""admin/edit_inline/stacked.html""


class TabularInline(InlineModelAdmin):
    template = ""admin/edit_inline/tabular.html""<EOS>"
"<BOS>""""""
This encapsulates the logic for displaying filters in the Django admin.
Filters are specified in models with the ""list_filter"" option.

Each filter subclass knows how to display a filter for a field that passes a
certain test -- e.g. being a DateField or ForeignKey.
""""""
import datetime

from django.contrib.admin.options import IncorrectLookupParameters
from django.contrib.admin.utils import (
    get_model_from_relation,
    prepare_lookup_value,
    reverse_field_path,
)
from django.core.exceptions import ImproperlyConfigured, ValidationError
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _


class ListFilter:
    title = None  # Human-readable title to appear in the right sidebar.
    template = ""admin/filter.html""

    def __init__(self, request, params, model, model_admin):
        # This dictionary will eventually contain the request's query string
        # parameters actually used by this filter.
        self.used_parameters = {}
        if self.title is None:
            raise ImproperlyConfigured(
                ""The list filter '%s' does not specify a 'title'.""
                % self.__class__.__name__
            )

    def has_output(self):
        """"""
        Return True if some choices would be output for this filter.
        """"""
        raise NotImplementedError(
            ""subclasses of ListFilter must provide a has_output() method""
        )

    def choices(self, changelist):
        """"""
        Return choices ready to be output in the template.

        `changelist` is the ChangeList to be displayed.
        """"""
        raise NotImplementedError(
            ""subclasses of ListFilter must provide a choices() method""
        )

    def queryset(self, request, queryset):
        """"""
        Return the filtered queryset.
        """"""
        raise NotImplementedError(
            ""subclasses of ListFilter must provide a queryset() method""
        )

    def expected_parameters(self):
        """"""
        Return the list of parameter names that are expected from the
        request's query string and that will be used by this filter.
        """"""
        raise NotImplementedError(
            ""subclasses of ListFilter must provide an expected_parameters() method""
        )


class SimpleListFilter(ListFilter):
    # The parameter that should be used in the query string for that filter.
    parameter_name = None

    def __init__(self, request, params, model, model_admin):
        super().__init__(request, params, model, model_admin)
        if self.parameter_name is None:
            raise ImproperlyConfigured(
                ""The list filter '%s' does not specify a 'parameter_name'.""
                % self.__class__.__name__
            )
        if self.parameter_name in params:
            value = params.pop(self.parameter_name)
            self.used_parameters[self.parameter_name] = value
        lookup_choices = self.lookups(request, model_admin)
        if lookup_choices is None:
            lookup_choices = ()
        self.lookup_choices = list(lookup_choices)

    def has_output(self):
        return len(self.lookup_choices) > 0

    def value(self):
        """"""
        Return the value (in string format) provided in the request's
        query string for this filter, if any, or None if the value wasn't
        provided.
        """"""
        return self.used_parameters.get(self.parameter_name)

    def lookups(self, request, model_admin):
        """"""
        Must be overridden to return a list of tuples (value, verbose value)
        """"""
        raise NotImplementedError(
            ""The SimpleListFilter.lookups() method must be overridden to ""
            ""return a list of tuples (value, verbose value).""
        )

    def expected_parameters(self):
        return [self.parameter_name]

    def choices(self, changelist):
        yield {
            ""selected"": self.value() is None,
            ""query_string"": changelist.get_query_string(remove=[self.parameter_name]),
            ""display"": _(""All""),
        }
        for lookup, title in self.lookup_choices:
            yield {
                ""selected"": self.value() == str(lookup),
                ""query_string"": changelist.get_query_string(
                    {self.parameter_name: lookup}
                ),
                ""display"": title,
            }


class FieldListFilter(ListFilter):
    _field_list_filters = []
    _take_priority_index = 0
    list_separator = "",""

    def __init__(self, field, request, params, model, model_admin, field_path):
        self.field = field
        self.field_path = field_path
        self.title = getattr(field, ""verbose_name"", field_path)
        super().__init__(request, params, model, model_admin)
        for p in self.expected_parameters():
            if p in params:
                value = params.pop(p)
                self.used_parameters[p] = prepare_lookup_value(
                    p, value, self.list_separator
                )

    def has_output(self):
        return True

    def queryset(self, request, queryset):
        try:
            return queryset.filter(**self.used_parameters)
        except (ValueError, ValidationError) as e:
            # Fields may raise a ValueError or ValidationError when converting
            # the parameters to the correct type.
            raise IncorrectLookupParameters(e)

    @classmethod
    def register(cls, test, list_filter_class, take_priority=False):
        if take_priority:
            # This is to allow overriding the default filters for certain types
            # of fields with some custom filters. The first found in the list
            # is used in priority.
            cls._field_list_filters.insert(
                cls._take_priority_index, (test, list_filter_class)
            )
            cls._take_priority_index += 1
        else:
            cls._field_list_filters.append((test, list_filter_class))

    @classmethod
    def create(cls, field, request, params, model, model_admin, field_path):
        for test, list_filter_class in cls._field_list_filters:
            if test(field):
                return list_filter_class(
                    field, request, params, model, model_admin, field_path=field_path
                )


class RelatedFieldListFilter(FieldListFilter):
    def __init__(self, field, request, params, model, model_admin, field_path):
        other_model = get_model_from_relation(field)
        self.lookup_kwarg = ""%s__%s__exact"" % (field_path, field.target_field.name)
        self.lookup_kwarg_isnull = ""%s__isnull"" % field_path
        self.lookup_val = params.get(self.lookup_kwarg)
        self.lookup_val_isnull = params.get(self.lookup_kwarg_isnull)
        super().__init__(field, request, params, model, model_admin, field_path)
        self.lookup_choices = self.field_choices(field, request, model_admin)
        if hasattr(field, ""verbose_name""):
            self.lookup_title = field.verbose_name
        else:
            self.lookup_title = other_model._meta.verbose_name
        self.title = self.lookup_title
        self.empty_value_display = model_admin.get_empty_value_display()

    @property
    def include_empty_choice(self):
        """"""
        Return True if a ""(None)"" choice should be included, which filters
        out everything except empty relationships.
        """"""
        return self.field.null or (self.field.is_relation and self.field.many_to_many)

    def has_output(self):
        if self.include_empty_choice:
            extra = 1
        else:
            extra = 0
        return len(self.lookup_choices) + extra > 1

    def expected_parameters(self):
        return [self.lookup_kwarg, self.lookup_kwarg_isnull]

    def field_admin_ordering(self, field, request, model_admin):
        """"""
        Return the model admin's ordering for related field, if provided.
        """"""
        related_admin = model_admin.admin_site._registry.get(field.remote_field.model)
        if related_admin is not None:
            return related_admin.get_ordering(request)
        return ()

    def field_choices(self, field, request, model_admin):
        ordering = self.field_admin_ordering(field, request, model_admin)
        return field.get_choices(include_blank=False, ordering=ordering)

    def choices(self, changelist):
        yield {
            ""selected"": self.lookup_val is None and not self.lookup_val_isnull,
            ""query_string"": changelist.get_query_string(
                remove=[self.lookup_kwarg, self.lookup_kwarg_isnull]
            ),
            ""display"": _(""All""),
        }
        for pk_val, val in self.lookup_choices:
            yield {
                ""selected"": self.lookup_val == str(pk_val),
                ""query_string"": changelist.get_query_string(
                    {self.lookup_kwarg: pk_val}, [self.lookup_kwarg_isnull]
                ),
                ""display"": val,
            }
        if self.include_empty_choice:
            yield {
                ""selected"": bool(self.lookup_val_isnull),
                ""query_string"": changelist.get_query_string(
                    {self.lookup_kwarg_isnull: ""True""}, [self.lookup_kwarg]
                ),
                ""display"": self.empty_value_display,
            }


FieldListFilter.register(lambda f: f.remote_field, RelatedFieldListFilter)


class BooleanFieldListFilter(FieldListFilter):
    def __init__(self, field, request, params, model, model_admin, field_path):
        self.lookup_kwarg = ""%s__exact"" % field_path
        self.lookup_kwarg2 = ""%s__isnull"" % field_path
        self.lookup_val = params.get(self.lookup_kwarg)
        self.lookup_val2 = params.get(self.lookup_kwarg2)
        super().__init__(field, request, params, model, model_admin, field_path)
        if (
            self.used_parameters
            and self.lookup_kwarg in self.used_parameters
            and self.used_parameters[self.lookup_kwarg] in (""1"", ""0"")
        ):
            self.used_parameters[self.lookup_kwarg] = bool(
                int(self.used_parameters[self.lookup_kwarg])
            )

    def expected_parameters(self):
        return [self.lookup_kwarg, self.lookup_kwarg2]

    def choices(self, changelist):
        field_choices = dict(self.field.flatchoices)
        for lookup, title in (
            (None, _(""All"")),
            (""1"", field_choices.get(True, _(""Yes""))),
            (""0"", field_choices.get(False, _(""No""))),
        ):
            yield {
                ""selected"": self.lookup_val == lookup and not self.lookup_val2,
                ""query_string"": changelist.get_query_string(
                    {self.lookup_kwarg: lookup}, [self.lookup_kwarg2]
                ),
                ""display"": title,
            }
        if self.field.null:
            yield {
                ""selected"": self.lookup_val2 == ""True"",
                ""query_string"": changelist.get_query_string(
                    {self.lookup_kwarg2: ""True""}, [self.lookup_kwarg]
                ),
                ""display"": field_choices.get(None, _(""Unknown"")),
            }


FieldListFilter.register(
    lambda f: isinstance(f, models.BooleanField), BooleanFieldListFilter
)


class ChoicesFieldListFilter(FieldListFilter):
    def __init__(self, field, request, params, model, model_admin, field_path):
        self.lookup_kwarg = ""%s__exact"" % field_path
        self.lookup_kwarg_isnull = ""%s__isnull"" % field_path
        self.lookup_val = params.get(self.lookup_kwarg)
        self.lookup_val_isnull = params.get(self.lookup_kwarg_isnull)
        super().__init__(field, request, params, model, model_admin, field_path)

    def expected_parameters(self):
        return [self.lookup_kwarg, self.lookup_kwarg_isnull]

    def choices(self, changelist):
        yield {
            ""selected"": self.lookup_val is None,
            ""query_string"": changelist.get_query_string(
                remove=[self.lookup_kwarg, self.lookup_kwarg_isnull]
            ),
            ""display"": _(""All""),
        }
        none_title = """"
        for lookup, title in self.field.flatchoices:
            if lookup is None:
                none_title = title
                continue
            yield {
                ""selected"": str(lookup) == self.lookup_val,
                ""query_string"": changelist.get_query_string(
                    {self.lookup_kwarg: lookup}, [self.lookup_kwarg_isnull]
                ),
                ""display"": title,
            }
        if none_title:
            yield {
                ""selected"": bool(self.lookup_val_isnull),
                ""query_string"": changelist.get_query_string(
                    {self.lookup_kwarg_isnull: ""True""}, [self.lookup_kwarg]
                ),
                ""display"": none_title,
            }


FieldListFilter.register(lambda f: bool(f.choices), ChoicesFieldListFilter)


class DateFieldListFilter(FieldListFilter):
    def __init__(self, field, request, params, model, model_admin, field_path):
        self.field_generic = ""%s__"" % field_path
        self.date_params = {
            k: v for k, v in params.items() if k.startswith(self.field_generic)
        }

        now = timezone.now()
        # When time zone support is enabled, convert ""now"" to the user's time
        # zone so Django's definition of ""Today"" matches what the user expects.
        if timezone.is_aware(now):
            now = timezone.localtime(now)

        if isinstance(field, models.DateTimeField):
            today = now.replace(hour=0, minute=0, second=0, microsecond=0)
        else:  # field is a models.DateField
            today = now.date()
        tomorrow = today + datetime.timedelta(days=1)
        if today.month == 12:
            next_month = today.replace(year=today.year + 1, month=1, day=1)
        else:
            next_month = today.replace(month=today.month + 1, day=1)
        next_year = today.replace(year=today.year + 1, month=1, day=1)

        self.lookup_kwarg_since = ""%s__gte"" % field_path
        self.lookup_kwarg_until = ""%s__lt"" % field_path
        self.links = (
            (_(""Any date""), {}),
            (
                _(""Today""),
                {
                    self.lookup_kwarg_since: str(today),
                    self.lookup_kwarg_until: str(tomorrow),
                },
            ),
            (
                _(""Past 7 days""),
                {
                    self.lookup_kwarg_since: str(today - datetime.timedelta(days=7)),
                    self.lookup_kwarg_until: str(tomorrow),
                },
            ),
            (
                _(""This month""),
                {
                    self.lookup_kwarg_since: str(today.replace(day=1)),
                    self.lookup_kwarg_until: str(next_month),
                },
            ),
            (
                _(""This year""),
                {
                    self.lookup_kwarg_since: str(today.replace(month=1, day=1)),
                    self.lookup_kwarg_until: str(next_year),
                },
            ),
        )
        if field.null:
            self.lookup_kwarg_isnull = ""%s__isnull"" % field_path
            self.links += (
                (_(""No date""), {self.field_generic + ""isnull"": ""True""}),
                (_(""Has date""), {self.field_generic + ""isnull"": ""False""}),
            )
        super().__init__(field, request, params, model, model_admin, field_path)

    def expected_parameters(self):
        params = [self.lookup_kwarg_since, self.lookup_kwarg_until]
        if self.field.null:
            params.append(self.lookup_kwarg_isnull)
        return params

    def choices(self, changelist):
        for title, param_dict in self.links:
            yield {
                ""selected"": self.date_params == param_dict,
                ""query_string"": changelist.get_query_string(
                    param_dict, [self.field_generic]
                ),
                ""display"": title,
            }


FieldListFilter.register(lambda f: isinstance(f, models.DateField), DateFieldListFilter)


# This should be registered last, because it's a last resort. For example,
# if a field is eligible to use the BooleanFieldListFilter, that'd be much
# more appropriate, and the AllValuesFieldListFilter won't get used for it.
class AllValuesFieldListFilter(FieldListFilter):
    def __init__(self, field, request, params, model, model_admin, field_path):
        self.lookup_kwarg = field_path
        self.lookup_kwarg_isnull = ""%s__isnull"" % field_path
        self.lookup_val = params.get(self.lookup_kwarg)
        self.lookup_val_isnull = params.get(self.lookup_kwarg_isnull)
        self.empty_value_display = model_admin.get_empty_value_display()
        parent_model, reverse_path = reverse_field_path(model, field_path)
        # Obey parent ModelAdmin queryset when deciding which options to show
        if model == parent_model:
            queryset = model_admin.get_queryset(request)
        else:
            queryset = parent_model._default_manager.all()
        self.lookup_choices = (
            queryset.distinct().order_by(field.name).values_list(field.name, flat=True)
        )
        super().__init__(field, request, params, model, model_admin, field_path)

    def expected_parameters(self):
        return [self.lookup_kwarg, self.lookup_kwarg_isnull]

    def choices(self, changelist):
        yield {
            ""selected"": self.lookup_val is None and self.lookup_val_isnull is None,
            ""query_string"": changelist.get_query_string(
                remove=[self.lookup_kwarg, self.lookup_kwarg_isnull]
            ),
            ""display"": _(""All""),
        }
        include_none = False
        for val in self.lookup_choices:
            if val is None:
                include_none = True
                continue
            val = str(val)
            yield {
                ""selected"": self.lookup_val == val,
                ""query_string"": changelist.get_query_string(
                    {self.lookup_kwarg: val}, [self.lookup_kwarg_isnull]
                ),
                ""display"": val,
            }
        if include_none:
            yield {
                ""selected"": bool(self.lookup_val_isnull),
                ""query_string"": changelist.get_query_string(
                    {self.lookup_kwarg_isnull: ""True""}, [self.lookup_kwarg]
                ),
                ""display"": self.empty_value_display,
            }


FieldListFilter.register(lambda f: True, AllValuesFieldListFilter)


class RelatedOnlyFieldListFilter(RelatedFieldListFilter):
    def field_choices(self, field, request, model_admin):
        pk_qs = (
            model_admin.get_queryset(request)
            .distinct()
            .values_list(""%s__pk"" % self.field_path, flat=True)
        )
        ordering = self.field_admin_ordering(field, request, model_admin)
        return field.get_choices(
            include_blank=False, limit_choices_to={""pk__in"": pk_qs}, ordering=ordering
        )


class EmptyFieldListFilter(FieldListFilter):
    def __init__(self, field, request, params, model, model_admin, field_path):
        if not field.empty_strings_allowed and not field.null:
            raise ImproperlyConfigured(
                ""The list filter '%s' cannot be used with field '%s' which ""
                ""doesn't allow empty strings and nulls.""
                % (
                    self.__class__.__name__,
                    field.name,
                )
            )
        self.lookup_kwarg = ""%s__isempty"" % field_path
        self.lookup_val = params.get(self.lookup_kwarg)
        super().__init__(field, request, params, model, model_admin, field_path)

    def queryset(self, request, queryset):
        if self.lookup_kwarg not in self.used_parameters:
            return queryset
        if self.lookup_val not in (""0"", ""1""):
            raise IncorrectLookupParameters

        lookup_conditions = []
        if self.field.empty_strings_allowed:
            lookup_conditions.append((self.field_path, """"))
        if self.field.null:
            lookup_conditions.append((f""{self.field_path}__isnull"", True))
        lookup_condition = models.Q(*lookup_conditions, _connector=models.Q.OR)
        if self.lookup_val == ""1"":
            return queryset.filter(lookup_condition)
        return queryset.exclude(lookup_condition)

    def expected_parameters(self):
        return [self.lookup_kwarg]

    def choices(self, changelist):
        for lookup, title in (
            (None, _(""All"")),
            (""1"", _(""Empty"")),
            (""0"", _(""Not empty"")),
        ):
            yield {
                ""selected"": self.lookup_val == lookup,
                ""query_string"": changelist.get_query_string(
                    {self.lookup_kwarg: lookup}
                ),
                ""display"": title,
            }<EOS>"
"<BOS>def action(function=None, *, permissions=None, description=None):
    """"""
    Conveniently add attributes to an action function::

        @admin.action(
            permissions=['publish'],
            description='Mark selected stories as published',
        )
        def make_published(self, request, queryset):
            queryset.update(status='p')

    This is equivalent to setting some attributes (with the original, longer
    names) on the function directly::

        def make_published(self, request, queryset):
            queryset.update(status='p')
        make_published.allowed_permissions = ['publish']
        make_published.short_description = 'Mark selected stories as published'
    """"""

    def decorator(func):
        if permissions is not None:
            func.allowed_permissions = permissions
        if description is not None:
            func.short_description = description
        return func

    if function is None:
        return decorator
    else:
        return decorator(function)


def display(
    function=None, *, boolean=None, ordering=None, description=None, empty_value=None
):
    """"""
    Conveniently add attributes to a display function::

        @admin.display(
            boolean=True,
            ordering='-publish_date',
            description='Is Published?',
        )
        def is_published(self, obj):
            return obj.publish_date is not None

    This is equivalent to setting some attributes (with the original, longer
    names) on the function directly::

        def is_published(self, obj):
            return obj.publish_date is not None
        is_published.boolean = True
        is_published.admin_order_field = '-publish_date'
        is_published.short_description = 'Is Published?'
    """"""

    def decorator(func):
        if boolean is not None and empty_value is not None:
            raise ValueError(
                ""The boolean and empty_value arguments to the @display ""
                ""decorator are mutually exclusive.""
            )
        if boolean is not None:
            func.boolean = boolean
        if ordering is not None:
            func.admin_order_field = ordering
        if description is not None:
            func.short_description = description
        if empty_value is not None:
            func.empty_value_display = empty_value
        return func

    if function is None:
        return decorator
    else:
        return decorator(function)


def register(*models, site=None):
    """"""
    Register the given model(s) classes and wrapped ModelAdmin class with
    admin site:

    @register(Author)
    class AuthorAdmin(admin.ModelAdmin):
        pass

    The `site` kwarg is an admin site to use instead of the default admin site.
    """"""
    from django.contrib.admin import ModelAdmin
    from django.contrib.admin.sites import AdminSite
    from django.contrib.admin.sites import site as default_site

    def _model_admin_wrapper(admin_class):
        if not models:
            raise ValueError(""At least one model must be passed to register."")

        admin_site = site or default_site

        if not isinstance(admin_site, AdminSite):
            raise ValueError(""site must subclass AdminSite"")

        if not issubclass(admin_class, ModelAdmin):
            raise ValueError(""Wrapped class must subclass ModelAdmin."")

        admin_site.register(models, admin_class=admin_class)

        return admin_class

    return _model_admin_wrapper<EOS>"
"<BOS>from django.contrib.auth.forms import AuthenticationForm, PasswordChangeForm
from django.core.exceptions import ValidationError
from django.utils.translation import gettext_lazy as _


class AdminAuthenticationForm(AuthenticationForm):
    """"""
    A custom authentication form used in the admin app.
    """"""

    error_messages = {
        **AuthenticationForm.error_messages,
        ""invalid_login"": _(
            ""Please enter the correct %(username)s and password for a staff ""
            ""account. Note that both fields may be case-sensitive.""
        ),
    }
    required_css_class = ""required""

    def confirm_login_allowed(self, user):
        super().confirm_login_allowed(user)
        if not user.is_staff:
            raise ValidationError(
                self.error_messages[""invalid_login""],
                code=""invalid_login"",
                params={""username"": self.username_field.verbose_name},
            )


class AdminPasswordChangeForm(PasswordChangeForm):
    required_css_class = ""required""<EOS>"
"<BOS>from contextlib import contextmanager

from django.contrib.staticfiles.testing import StaticLiveServerTestCase
from django.test import modify_settings
from django.test.selenium import SeleniumTestCase
from django.utils.deprecation import MiddlewareMixin
from django.utils.translation import gettext as _


class CSPMiddleware(MiddlewareMixin):
    """"""The admin's JavaScript should be compatible with CSP.""""""

    def process_response(self, request, response):
        response.headers[""Content-Security-Policy""] = ""default-src 'self'""
        return response


@modify_settings(MIDDLEWARE={""append"": ""django.contrib.admin.tests.CSPMiddleware""})
class AdminSeleniumTestCase(SeleniumTestCase, StaticLiveServerTestCase):

    available_apps = [
        ""django.contrib.admin"",
        ""django.contrib.auth"",
        ""django.contrib.contenttypes"",
        ""django.contrib.sessions"",
        ""django.contrib.sites"",
    ]

    def wait_until(self, callback, timeout=10):
        """"""
        Block the execution of the tests until the specified callback returns a
        value that is not falsy. This method can be called, for example, after
        clicking a link or submitting a form. See the other public methods that
        call this function for more details.
        """"""
        from selenium.webdriver.support.wait import WebDriverWait

        WebDriverWait(self.selenium, timeout).until(callback)

    def wait_for_and_switch_to_popup(self, num_windows=2, timeout=10):
        """"""
        Block until `num_windows` are present and are ready (usually 2, but can
        be overridden in the case of pop-ups opening other pop-ups). Switch the
        current window to the new pop-up.
        """"""
        self.wait_until(lambda d: len(d.window_handles) == num_windows, timeout)
        self.selenium.switch_to.window(self.selenium.window_handles[-1])
        self.wait_page_ready()

    def wait_for(self, css_selector, timeout=10):
        """"""
        Block until a CSS selector is found on the page.
        """"""
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support import expected_conditions as ec

        self.wait_until(
            ec.presence_of_element_located((By.CSS_SELECTOR, css_selector)), timeout
        )

    def wait_for_text(self, css_selector, text, timeout=10):
        """"""
        Block until the text is found in the CSS selector.
        """"""
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support import expected_conditions as ec

        self.wait_until(
            ec.text_to_be_present_in_element((By.CSS_SELECTOR, css_selector), text),
            timeout,
        )

    def wait_for_value(self, css_selector, text, timeout=10):
        """"""
        Block until the value is found in the CSS selector.
        """"""
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support import expected_conditions as ec

        self.wait_until(
            ec.text_to_be_present_in_element_value(
                (By.CSS_SELECTOR, css_selector), text
            ),
            timeout,
        )

    def wait_until_visible(self, css_selector, timeout=10):
        """"""
        Block until the element described by the CSS selector is visible.
        """"""
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support import expected_conditions as ec

        self.wait_until(
            ec.visibility_of_element_located((By.CSS_SELECTOR, css_selector)), timeout
        )

    def wait_until_invisible(self, css_selector, timeout=10):
        """"""
        Block until the element described by the CSS selector is invisible.
        """"""
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support import expected_conditions as ec

        self.wait_until(
            ec.invisibility_of_element_located((By.CSS_SELECTOR, css_selector)), timeout
        )

    def wait_page_ready(self, timeout=10):
        """"""
        Block until the  page is ready.
        """"""
        self.wait_until(
            lambda driver: driver.execute_script(""return document.readyState;"")
            == ""complete"",
            timeout,
        )

    @contextmanager
    def wait_page_loaded(self, timeout=10):
        """"""
        Block until a new page has loaded and is ready.
        """"""
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support import expected_conditions as ec

        old_page = self.selenium.find_element(By.TAG_NAME, ""html"")
        yield
        # Wait for the next page to be loaded
        self.wait_until(ec.staleness_of(old_page), timeout=timeout)
        self.wait_page_ready(timeout=timeout)

    def admin_login(self, username, password, login_url=""/admin/""):
        """"""
        Log in to the admin.
        """"""
        from selenium.webdriver.common.by import By

        self.selenium.get(""%s%s"" % (self.live_server_url, login_url))
        username_input = self.selenium.find_element(By.NAME, ""username"")
        username_input.send_keys(username)
        password_input = self.selenium.find_element(By.NAME, ""password"")
        password_input.send_keys(password)
        login_text = _(""Log in"")
        with self.wait_page_loaded():
            self.selenium.find_element(
                By.XPATH, '//input[@value=""%s""]' % login_text
            ).click()

    def select_option(self, selector, value):
        """"""
        Select the <OPTION> with the value `value` inside the <SELECT> widget
        identified by the CSS selector `selector`.
        """"""
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support.ui import Select

        select = Select(self.selenium.find_element(By.CSS_SELECTOR, selector))
        select.select_by_value(value)

    def deselect_option(self, selector, value):
        """"""
        Deselect the <OPTION> with the value `value` inside the <SELECT> widget
        identified by the CSS selector `selector`.
        """"""
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support.ui import Select

        select = Select(self.selenium.find_element(By.CSS_SELECTOR, selector))
        select.deselect_by_value(value)

    def assertCountSeleniumElements(self, selector, count, root_element=None):
        """"""
        Assert number of matches for a CSS selector.

        `root_element` allow restriction to a pre-selected node.
        """"""
        from selenium.webdriver.common.by import By

        root_element = root_element or self.selenium
        self.assertEqual(
            len(root_element.find_elements(By.CSS_SELECTOR, selector)), count
        )

    def _assertOptionsValues(self, options_selector, values):
        from selenium.webdriver.common.by import By

        if values:
            options = self.selenium.find_elements(By.CSS_SELECTOR, options_selector)
            actual_values = []
            for option in options:
                actual_values.append(option.get_attribute(""value""))
            self.assertEqual(values, actual_values)
        else:
            # Prevent the `find_elements(By.CSS_SELECTOR, …)` call from blocking
            # if the selector doesn't match any options as we expect it
            # to be the case.
            with self.disable_implicit_wait():
                self.wait_until(
                    lambda driver: not driver.find_elements(
                        By.CSS_SELECTOR, options_selector
                    )
                )

    def assertSelectOptions(self, selector, values):
        """"""
        Assert that the <SELECT> widget identified by `selector` has the
        options with the given `values`.
        """"""
        self._assertOptionsValues(""%s > option"" % selector, values)

    def assertSelectedOptions(self, selector, values):
        """"""
        Assert that the <SELECT> widget identified by `selector` has the
        selected options with the given `values`.
        """"""
        self._assertOptionsValues(""%s > option:checked"" % selector, values)

    def has_css_class(self, selector, klass):
        """"""
        Return True if the element identified by `selector` has the CSS class
        `klass`.
        """"""
        from selenium.webdriver.common.by import By

        return (
            self.selenium.find_element(
                By.CSS_SELECTOR,
                selector,
            )
            .get_attribute(""class"")
            .find(klass)
            != -1
        )<EOS>"
"<BOS>from django.apps import apps
from django.core.exceptions import FieldDoesNotExist, PermissionDenied
from django.http import Http404, JsonResponse
from django.views.generic.list import BaseListView


class AutocompleteJsonView(BaseListView):
    """"""Handle AutocompleteWidget's AJAX requests for data.""""""

    paginate_by = 20
    admin_site = None

    def get(self, request, *args, **kwargs):
        """"""
        Return a JsonResponse with search results as defined in
        serialize_result(), by default:
        {
            results: [{id: ""123"" text: ""foo""}],
            pagination: {more: true}
        }
        """"""
        (
            self.term,
            self.model_admin,
            self.source_field,
            to_field_name,
        ) = self.process_request(request)

        if not self.has_perm(request):
            raise PermissionDenied

        self.object_list = self.get_queryset()
        context = self.get_context_data()
        return JsonResponse(
            {
                ""results"": [
                    self.serialize_result(obj, to_field_name)
                    for obj in context[""object_list""]
                ],
                ""pagination"": {""more"": context[""page_obj""].has_next()},
            }
        )

    def serialize_result(self, obj, to_field_name):
        """"""
        Convert the provided model object to a dictionary that is added to the
        results list.
        """"""
        return {""id"": str(getattr(obj, to_field_name)), ""text"": str(obj)}

    def get_paginator(self, *args, **kwargs):
        """"""Use the ModelAdmin's paginator.""""""
        return self.model_admin.get_paginator(self.request, *args, **kwargs)

    def get_queryset(self):
        """"""Return queryset based on ModelAdmin.get_search_results().""""""
        qs = self.model_admin.get_queryset(self.request)
        qs = qs.complex_filter(self.source_field.get_limit_choices_to())
        qs, search_use_distinct = self.model_admin.get_search_results(
            self.request, qs, self.term
        )
        if search_use_distinct:
            qs = qs.distinct()
        return qs

    def process_request(self, request):
        """"""
        Validate request integrity, extract and return request parameters.

        Since the subsequent view permission check requires the target model
        admin, which is determined here, raise PermissionDenied if the
        requested app, model or field are malformed.

        Raise Http404 if the target model admin is not configured properly with
        search_fields.
        """"""
        term = request.GET.get(""term"", """")
        try:
            app_label = request.GET[""app_label""]
            model_name = request.GET[""model_name""]
            field_name = request.GET[""field_name""]
        except KeyError as e:
            raise PermissionDenied from e

        # Retrieve objects from parameters.
        try:
            source_model = apps.get_model(app_label, model_name)
        except LookupError as e:
            raise PermissionDenied from e

        try:
            source_field = source_model._meta.get_field(field_name)
        except FieldDoesNotExist as e:
            raise PermissionDenied from e
        try:
            remote_model = source_field.remote_field.model
        except AttributeError as e:
            raise PermissionDenied from e
        try:
            model_admin = self.admin_site._registry[remote_model]
        except KeyError as e:
            raise PermissionDenied from e

        # Validate suitability of objects.
        if not model_admin.get_search_fields(request):
            raise Http404(
                ""%s must have search_fields for the autocomplete_view.""
                % type(model_admin).__qualname__
            )

        to_field_name = getattr(
            source_field.remote_field, ""field_name"", remote_model._meta.pk.attname
        )
        to_field_name = remote_model._meta.get_field(to_field_name).attname
        if not model_admin.to_field_allowed(request, to_field_name):
            raise PermissionDenied

        return term, model_admin, source_field, to_field_name

    def has_perm(self, request, obj=None):
        """"""Check if user has permission to access the related model.""""""
        return self.model_admin.has_view_permission(request, obj=obj)<EOS>"
"<BOS>from datetime import datetime, timedelta

from django import forms
from django.conf import settings
from django.contrib import messages
from django.contrib.admin import FieldListFilter
from django.contrib.admin.exceptions import (
    DisallowedModelAdminLookup,
    DisallowedModelAdminToField,
)
from django.contrib.admin.options import (
    IS_POPUP_VAR,
    TO_FIELD_VAR,
    IncorrectLookupParameters,
)
from django.contrib.admin.utils import (
    get_fields_from_path,
    lookup_spawns_duplicates,
    prepare_lookup_value,
    quote,
)
from django.core.exceptions import (
    FieldDoesNotExist,
    ImproperlyConfigured,
    SuspiciousOperation,
)
from django.core.paginator import InvalidPage
from django.db.models import Exists, F, Field, ManyToOneRel, OrderBy, OuterRef
from django.db.models.expressions import Combinable
from django.urls import reverse
from django.utils.http import urlencode
from django.utils.timezone import make_aware
from django.utils.translation import gettext

# Changelist settings
ALL_VAR = ""all""
ORDER_VAR = ""o""
PAGE_VAR = ""p""
SEARCH_VAR = ""q""
ERROR_FLAG = ""e""

IGNORED_PARAMS = (ALL_VAR, ORDER_VAR, SEARCH_VAR, IS_POPUP_VAR, TO_FIELD_VAR)


class ChangeListSearchForm(forms.Form):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Populate ""fields"" dynamically because SEARCH_VAR is a variable:
        self.fields = {
            SEARCH_VAR: forms.CharField(required=False, strip=False),
        }


class ChangeList:
    search_form_class = ChangeListSearchForm

    def __init__(
        self,
        request,
        model,
        list_display,
        list_display_links,
        list_filter,
        date_hierarchy,
        search_fields,
        list_select_related,
        list_per_page,
        list_max_show_all,
        list_editable,
        model_admin,
        sortable_by,
        search_help_text,
    ):
        self.model = model
        self.opts = model._meta
        self.lookup_opts = self.opts
        self.root_queryset = model_admin.get_queryset(request)
        self.list_display = list_display
        self.list_display_links = list_display_links
        self.list_filter = list_filter
        self.has_filters = None
        self.has_active_filters = None
        self.clear_all_filters_qs = None
        self.date_hierarchy = date_hierarchy
        self.search_fields = search_fields
        self.list_select_related = list_select_related
        self.list_per_page = list_per_page
        self.list_max_show_all = list_max_show_all
        self.model_admin = model_admin
        self.preserved_filters = model_admin.get_preserved_filters(request)
        self.sortable_by = sortable_by
        self.search_help_text = search_help_text

        # Get search parameters from the query string.
        _search_form = self.search_form_class(request.GET)
        if not _search_form.is_valid():
            for error in _search_form.errors.values():
                messages.error(request, "", "".join(error))
        self.query = _search_form.cleaned_data.get(SEARCH_VAR) or """"
        try:
            self.page_num = int(request.GET.get(PAGE_VAR, 1))
        except ValueError:
            self.page_num = 1
        self.show_all = ALL_VAR in request.GET
        self.is_popup = IS_POPUP_VAR in request.GET
        to_field = request.GET.get(TO_FIELD_VAR)
        if to_field and not model_admin.to_field_allowed(request, to_field):
            raise DisallowedModelAdminToField(
                ""The field %s cannot be referenced."" % to_field
            )
        self.to_field = to_field
        self.params = dict(request.GET.items())
        if PAGE_VAR in self.params:
            del self.params[PAGE_VAR]
        if ERROR_FLAG in self.params:
            del self.params[ERROR_FLAG]

        if self.is_popup:
            self.list_editable = ()
        else:
            self.list_editable = list_editable
        self.queryset = self.get_queryset(request)
        self.get_results(request)
        if self.is_popup:
            title = gettext(""Select %s"")
        elif self.model_admin.has_change_permission(request):
            title = gettext(""Select %s to change"")
        else:
            title = gettext(""Select %s to view"")
        self.title = title % self.opts.verbose_name
        self.pk_attname = self.lookup_opts.pk.attname

    def __repr__(self):
        return ""<%s: model=%s model_admin=%s>"" % (
            self.__class__.__qualname__,
            self.model.__qualname__,
            self.model_admin.__class__.__qualname__,
        )

    def get_filters_params(self, params=None):
        """"""
        Return all params except IGNORED_PARAMS.
        """"""
        params = params or self.params
        lookup_params = params.copy()  # a dictionary of the query string
        # Remove all the parameters that are globally and systematically
        # ignored.
        for ignored in IGNORED_PARAMS:
            if ignored in lookup_params:
                del lookup_params[ignored]
        return lookup_params

    def get_filters(self, request):
        lookup_params = self.get_filters_params()
        may_have_duplicates = False
        has_active_filters = False

        for key, value in lookup_params.items():
            if not self.model_admin.lookup_allowed(key, value):
                raise DisallowedModelAdminLookup(""Filtering by %s not allowed"" % key)

        filter_specs = []
        for list_filter in self.list_filter:
            lookup_params_count = len(lookup_params)
            if callable(list_filter):
                # This is simply a custom list filter class.
                spec = list_filter(request, lookup_params, self.model, self.model_admin)
            else:
                field_path = None
                if isinstance(list_filter, (tuple, list)):
                    # This is a custom FieldListFilter class for a given field.
                    field, field_list_filter_class = list_filter
                else:
                    # This is simply a field name, so use the default
                    # FieldListFilter class that has been registered for the
                    # type of the given field.
                    field, field_list_filter_class = list_filter, FieldListFilter.create
                if not isinstance(field, Field):
                    field_path = field
                    field = get_fields_from_path(self.model, field_path)[-1]

                spec = field_list_filter_class(
                    field,
                    request,
                    lookup_params,
                    self.model,
                    self.model_admin,
                    field_path=field_path,
                )
                # field_list_filter_class removes any lookup_params it
                # processes. If that happened, check if duplicates should be
                # removed.
                if lookup_params_count > len(lookup_params):
                    may_have_duplicates |= lookup_spawns_duplicates(
                        self.lookup_opts,
                        field_path,
                    )
            if spec and spec.has_output():
                filter_specs.append(spec)
                if lookup_params_count > len(lookup_params):
                    has_active_filters = True

        if self.date_hierarchy:
            # Create bounded lookup parameters so that the query is more
            # efficient.
            year = lookup_params.pop(""%s__year"" % self.date_hierarchy, None)
            if year is not None:
                month = lookup_params.pop(""%s__month"" % self.date_hierarchy, None)
                day = lookup_params.pop(""%s__day"" % self.date_hierarchy, None)
                try:
                    from_date = datetime(
                        int(year),
                        int(month if month is not None else 1),
                        int(day if day is not None else 1),
                    )
                except ValueError as e:
                    raise IncorrectLookupParameters(e) from e
                if day:
                    to_date = from_date + timedelta(days=1)
                elif month:
                    # In this branch, from_date will always be the first of a
                    # month, so advancing 32 days gives the next month.
                    to_date = (from_date + timedelta(days=32)).replace(day=1)
                else:
                    to_date = from_date.replace(year=from_date.year + 1)
                if settings.USE_TZ:
                    from_date = make_aware(from_date)
                    to_date = make_aware(to_date)
                lookup_params.update(
                    {
                        ""%s__gte"" % self.date_hierarchy: from_date,
                        ""%s__lt"" % self.date_hierarchy: to_date,
                    }
                )

        # At this point, all the parameters used by the various ListFilters
        # have been removed from lookup_params, which now only contains other
        # parameters passed via the query string. We now loop through the
        # remaining parameters both to ensure that all the parameters are valid
        # fields and to determine if at least one of them spawns duplicates. If
        # the lookup parameters aren't real fields, then bail out.
        try:
            for key, value in lookup_params.items():
                lookup_params[key] = prepare_lookup_value(key, value)
                may_have_duplicates |= lookup_spawns_duplicates(self.lookup_opts, key)
            return (
                filter_specs,
                bool(filter_specs),
                lookup_params,
                may_have_duplicates,
                has_active_filters,
            )
        except FieldDoesNotExist as e:
            raise IncorrectLookupParameters(e) from e

    def get_query_string(self, new_params=None, remove=None):
        if new_params is None:
            new_params = {}
        if remove is None:
            remove = []
        p = self.params.copy()
        for r in remove:
            for k in list(p):
                if k.startswith(r):
                    del p[k]
        for k, v in new_params.items():
            if v is None:
                if k in p:
                    del p[k]
            else:
                p[k] = v
        return ""?%s"" % urlencode(sorted(p.items()))

    def get_results(self, request):
        paginator = self.model_admin.get_paginator(
            request, self.queryset, self.list_per_page
        )
        # Get the number of objects, with admin filters applied.
        result_count = paginator.count

        # Get the total number of objects, with no admin filters applied.
        if self.model_admin.show_full_result_count:
            full_result_count = self.root_queryset.count()
        else:
            full_result_count = None
        can_show_all = result_count <= self.list_max_show_all
        multi_page = result_count > self.list_per_page

        # Get the list of objects to display on this page.
        if (self.show_all and can_show_all) or not multi_page:
            result_list = self.queryset._clone()
        else:
            try:
                result_list = paginator.page(self.page_num).object_list
            except InvalidPage:
                raise IncorrectLookupParameters

        self.result_count = result_count
        self.show_full_result_count = self.model_admin.show_full_result_count
        # Admin actions are shown if there is at least one entry
        # or if entries are not counted because show_full_result_count is disabled
        self.show_admin_actions = not self.show_full_result_count or bool(
            full_result_count
        )
        self.full_result_count = full_result_count
        self.result_list = result_list
        self.can_show_all = can_show_all
        self.multi_page = multi_page
        self.paginator = paginator

    def _get_default_ordering(self):
        ordering = []
        if self.model_admin.ordering:
            ordering = self.model_admin.ordering
        elif self.lookup_opts.ordering:
            ordering = self.lookup_opts.ordering
        return ordering

    def get_ordering_field(self, field_name):
        """"""
        Return the proper model field name corresponding to the given
        field_name to use for ordering. field_name may either be the name of a
        proper model field or the name of a method (on the admin or model) or a
        callable with the 'admin_order_field' attribute. Return None if no
        proper model field name can be matched.
        """"""
        try:
            field = self.lookup_opts.get_field(field_name)
            return field.name
        except FieldDoesNotExist:
            # See whether field_name is a name of a non-field
            # that allows sorting.
            if callable(field_name):
                attr = field_name
            elif hasattr(self.model_admin, field_name):
                attr = getattr(self.model_admin, field_name)
            else:
                attr = getattr(self.model, field_name)
            if isinstance(attr, property) and hasattr(attr, ""fget""):
                attr = attr.fget
            return getattr(attr, ""admin_order_field"", None)

    def get_ordering(self, request, queryset):
        """"""
        Return the list of ordering fields for the change list.
        First check the get_ordering() method in model admin, then check
        the object's default ordering. Then, any manually-specified ordering
        from the query string overrides anything. Finally, a deterministic
        order is guaranteed by calling _get_deterministic_ordering() with the
        constructed ordering.
        """"""
        params = self.params
        ordering = list(
            self.model_admin.get_ordering(request) or self._get_default_ordering()
        )
        if ORDER_VAR in params:
            # Clear ordering and used params
            ordering = []
            order_params = params[ORDER_VAR].split(""."")
            for p in order_params:
                try:
                    none, pfx, idx = p.rpartition(""-"")
                    field_name = self.list_display[int(idx)]
                    order_field = self.get_ordering_field(field_name)
                    if not order_field:
                        continue  # No 'admin_order_field', skip it
                    if isinstance(order_field, OrderBy):
                        if pfx == ""-"":
                            order_field = order_field.copy()
                            order_field.reverse_ordering()
                        ordering.append(order_field)
                    elif hasattr(order_field, ""resolve_expression""):
                        # order_field is an expression.
                        ordering.append(
                            order_field.desc() if pfx == ""-"" else order_field.asc()
                        )
                    # reverse order if order_field has already ""-"" as prefix
                    elif order_field.startswith(""-"") and pfx == ""-"":
                        ordering.append(order_field[1:])
                    else:
                        ordering.append(pfx + order_field)
                except (IndexError, ValueError):
                    continue  # Invalid ordering specified, skip it.

        # Add the given query's ordering fields, if any.
        ordering.extend(queryset.query.order_by)

        return self._get_deterministic_ordering(ordering)

    def _get_deterministic_ordering(self, ordering):
        """"""
        Ensure a deterministic order across all database backends. Search for a
        single field or unique together set of fields providing a total
        ordering. If these are missing, augment the ordering with a descendant
        primary key.
        """"""
        ordering = list(ordering)
        ordering_fields = set()
        total_ordering_fields = {""pk""} | {
            field.attname
            for field in self.lookup_opts.fields
            if field.unique and not field.null
        }
        for part in ordering:
            # Search for single field providing a total ordering.
            field_name = None
            if isinstance(part, str):
                field_name = part.lstrip(""-"")
            elif isinstance(part, F):
                field_name = part.name
            elif isinstance(part, OrderBy) and isinstance(part.expression, F):
                field_name = part.expression.name
            if field_name:
                # Normalize attname references by using get_field().
                try:
                    field = self.lookup_opts.get_field(field_name)
                except FieldDoesNotExist:
                    # Could be ""?"" for random ordering or a related field
                    # lookup. Skip this part of introspection for now.
                    continue
                # Ordering by a related field name orders by the referenced
                # model's ordering. Skip this part of introspection for now.
                if field.remote_field and field_name == field.name:
                    continue
                if field.attname in total_ordering_fields:
                    break
                ordering_fields.add(field.attname)
        else:
            # No single total ordering field, try unique_together and total
            # unique constraints.
            constraint_field_names = (
                *self.lookup_opts.unique_together,
                *(
                    constraint.fields
                    for constraint in self.lookup_opts.total_unique_constraints
                ),
            )
            for field_names in constraint_field_names:
                # Normalize attname references by using get_field().
                fields = [
                    self.lookup_opts.get_field(field_name) for field_name in field_names
                ]
                # Composite unique constraints containing a nullable column
                # cannot ensure total ordering.
                if any(field.null for field in fields):
                    continue
                if ordering_fields.issuperset(field.attname for field in fields):
                    break
            else:
                # If no set of unique fields is present in the ordering, rely
                # on the primary key to provide total ordering.
                ordering.append(""-pk"")
        return ordering

    def get_ordering_field_columns(self):
        """"""
        Return a dictionary of ordering field column numbers and asc/desc.
        """"""
        # We must cope with more than one column having the same underlying sort
        # field, so we base things on column numbers.
        ordering = self._get_default_ordering()
        ordering_fields = {}
        if ORDER_VAR not in self.params:
            # for ordering specified on ModelAdmin or model Meta, we don't know
            # the right column numbers absolutely, because there might be more
            # than one column associated with that ordering, so we guess.
            for field in ordering:
                if isinstance(field, (Combinable, OrderBy)):
                    if not isinstance(field, OrderBy):
                        field = field.asc()
                    if isinstance(field.expression, F):
                        order_type = ""desc"" if field.descending else ""asc""
                        field = field.expression.name
                    else:
                        continue
                elif field.startswith(""-""):
                    field = field[1:]
                    order_type = ""desc""
                else:
                    order_type = ""asc""
                for index, attr in enumerate(self.list_display):
                    if self.get_ordering_field(attr) == field:
                        ordering_fields[index] = order_type
                        break
        else:
            for p in self.params[ORDER_VAR].split("".""):
                none, pfx, idx = p.rpartition(""-"")
                try:
                    idx = int(idx)
                except ValueError:
                    continue  # skip it
                ordering_fields[idx] = ""desc"" if pfx == ""-"" else ""asc""
        return ordering_fields

    def get_queryset(self, request):
        # First, we collect all the declared list filters.
        (
            self.filter_specs,
            self.has_filters,
            remaining_lookup_params,
            filters_may_have_duplicates,
            self.has_active_filters,
        ) = self.get_filters(request)
        # Then, we let every list filter modify the queryset to its liking.
        qs = self.root_queryset
        for filter_spec in self.filter_specs:
            new_qs = filter_spec.queryset(request, qs)
            if new_qs is not None:
                qs = new_qs

        try:
            # Finally, we apply the remaining lookup parameters from the query
            # string (i.e. those that haven't already been processed by the
            # filters).
            qs = qs.filter(**remaining_lookup_params)
        except (SuspiciousOperation, ImproperlyConfigured):
            # Allow certain types of errors to be re-raised as-is so that the
            # caller can treat them in a special way.
            raise
        except Exception as e:
            # Every other error is caught with a naked except, because we don't
            # have any other way of validating lookup parameters. They might be
            # invalid if the keyword arguments are incorrect, or if the values
            # are not in the correct type, so we might get FieldError,
            # ValueError, ValidationError, or ?.
            raise IncorrectLookupParameters(e)

        # Apply search results
        qs, search_may_have_duplicates = self.model_admin.get_search_results(
            request,
            qs,
            self.query,
        )

        # Set query string for clearing all filters.
        self.clear_all_filters_qs = self.get_query_string(
            new_params=remaining_lookup_params,
            remove=self.get_filters_params(),
        )
        # Remove duplicates from results, if necessary
        if filters_may_have_duplicates | search_may_have_duplicates:
            qs = qs.filter(pk=OuterRef(""pk""))
            qs = self.root_queryset.filter(Exists(qs))

        # Set ordering.
        ordering = self.get_ordering(request, qs)
        qs = qs.order_by(*ordering)

        if not qs.query.select_related:
            qs = self.apply_select_related(qs)

        return qs

    def apply_select_related(self, qs):
        if self.list_select_related is True:
            return qs.select_related()

        if self.list_select_related is False:
            if self.has_related_field_in_list_display():
                return qs.select_related()

        if self.list_select_related:
            return qs.select_related(*self.list_select_related)
        return qs

    def has_related_field_in_list_display(self):
        for field_name in self.list_display:
            try:
                field = self.lookup_opts.get_field(field_name)
            except FieldDoesNotExist:
                pass
            else:
                if isinstance(field.remote_field, ManyToOneRel):
                    # <FK>_id field names don't require a join.
                    if field_name != field.get_attname():
                        return True
        return False

    def url_for_result(self, result):
        pk = getattr(result, self.pk_attname)
        return reverse(
            ""admin:%s_%s_change"" % (self.opts.app_label, self.opts.model_name),
            args=(quote(pk),),
            current_app=self.model_admin.admin_site.name,
        )<EOS>"
"<BOS>from django.contrib.auth import REDIRECT_FIELD_NAME
from django.contrib.auth.decorators import user_passes_test


def staff_member_required(
    view_func=None, redirect_field_name=REDIRECT_FIELD_NAME, login_url=""admin:login""
):
    """"""
    Decorator for views that checks that the user is logged in and is a staff
    member, redirecting to the login page if necessary.
    """"""
    actual_decorator = user_passes_test(
        lambda u: u.is_active and u.is_staff,
        login_url=login_url,
        redirect_field_name=redirect_field_name,
    )
    if view_func:
        return actual_decorator(view_func)
    return actual_decorator<EOS>"
"<BOS>import django.contrib.admin.models
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
        (""contenttypes"", ""__first__""),
    ]

    operations = [
        migrations.CreateModel(
            name=""LogEntry"",
            fields=[
                (
                    ""id"",
                    models.AutoField(
                        verbose_name=""ID"",
                        serialize=False,
                        auto_created=True,
                        primary_key=True,
                    ),
                ),
                (
                    ""action_time"",
                    models.DateTimeField(auto_now=True, verbose_name=""action time""),
                ),
                (
                    ""object_id"",
                    models.TextField(null=True, verbose_name=""object id"", blank=True),
                ),
                (
                    ""object_repr"",
                    models.CharField(max_length=200, verbose_name=""object repr""),
                ),
                (
                    ""action_flag"",
                    models.PositiveSmallIntegerField(verbose_name=""action flag""),
                ),
                (
                    ""change_message"",
                    models.TextField(verbose_name=""change message"", blank=True),
                ),
                (
                    ""content_type"",
                    models.ForeignKey(
                        on_delete=models.SET_NULL,
                        blank=True,
                        null=True,
                        to=""contenttypes.ContentType"",
                        verbose_name=""content type"",
                    ),
                ),
                (
                    ""user"",
                    models.ForeignKey(
                        to=settings.AUTH_USER_MODEL,
                        on_delete=models.CASCADE,
                        verbose_name=""user"",
                    ),
                ),
            ],
            options={
                ""ordering"": [""-action_time""],
                ""db_table"": ""django_admin_log"",
                ""verbose_name"": ""log entry"",
                ""verbose_name_plural"": ""log entries"",
            },
            bases=(models.Model,),
            managers=[
                (""objects"", django.contrib.admin.models.LogEntryManager()),
            ],
        ),
    ]<EOS>"
"<BOS>from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        (""admin"", ""0002_logentry_remove_auto_add""),
    ]

    # No database changes; adds choices to action_flag.
    operations = [
        migrations.AlterField(
            model_name=""logentry"",
            name=""action_flag"",
            field=models.PositiveSmallIntegerField(
                choices=[(1, ""Addition""), (2, ""Change""), (3, ""Deletion"")],
                verbose_name=""action flag"",
            ),
        ),
    ]<EOS>"
"<BOS>from django.db import migrations, models
from django.utils import timezone


class Migration(migrations.Migration):

    dependencies = [
        (""admin"", ""0001_initial""),
    ]

    # No database changes; removes auto_add and adds default/editable.
    operations = [
        migrations.AlterField(
            model_name=""logentry"",
            name=""action_time"",
            field=models.DateTimeField(
                verbose_name=""action time"",
                default=timezone.now,
                editable=False,
            ),
        ),
    ]<EOS>"
"<BOS>from inspect import getfullargspec

from django.template.library import InclusionNode, parse_bits


class InclusionAdminNode(InclusionNode):
    """"""
    Template tag that allows its template to be overridden per model, per app,
    or globally.
    """"""

    def __init__(self, parser, token, func, template_name, takes_context=True):
        self.template_name = template_name
        params, varargs, varkw, defaults, kwonly, kwonly_defaults, _ = getfullargspec(
            func
        )
        bits = token.split_contents()
        args, kwargs = parse_bits(
            parser,
            bits[1:],
            params,
            varargs,
            varkw,
            defaults,
            kwonly,
            kwonly_defaults,
            takes_context,
            bits[0],
        )
        super().__init__(func, takes_context, args, kwargs, filename=None)

    def render(self, context):
        opts = context[""opts""]
        app_label = opts.app_label.lower()
        object_name = opts.object_name.lower()
        # Load template for this render call. (Setting self.filename isn't
        # thread-safe.)
        context.render_context[self] = context.template.engine.select_template(
            [
                ""admin/%s/%s/%s"" % (app_label, object_name, self.template_name),
                ""admin/%s/%s"" % (app_label, self.template_name),
                ""admin/%s"" % self.template_name,
            ]
        )
        return super().render(context)<EOS>"
"<BOS>from django import template
from django.contrib.admin.models import LogEntry

register = template.Library()


class AdminLogNode(template.Node):
    def __init__(self, limit, varname, user):
        self.limit, self.varname, self.user = limit, varname, user

    def __repr__(self):
        return ""<GetAdminLog Node>""

    def render(self, context):
        if self.user is None:
            entries = LogEntry.objects.all()
        else:
            user_id = self.user
            if not user_id.isdigit():
                user_id = context[self.user].pk
            entries = LogEntry.objects.filter(user__pk=user_id)
        context[self.varname] = entries.select_related(""content_type"", ""user"")[
            : int(self.limit)
        ]
        return """"


@register.tag
def get_admin_log(parser, token):
    """"""
    Populate a template variable with the admin log for the given criteria.

    Usage::

        {% get_admin_log [limit] as [varname] for_user [context_var_with_user_obj] %}

    Examples::

        {% get_admin_log 10 as admin_log for_user 23 %}
        {% get_admin_log 10 as admin_log for_user user %}
        {% get_admin_log 10 as admin_log %}

    Note that ``context_var_containing_user_obj`` can be a hard-coded integer
    (user ID) or the name of a template context variable containing the user
    object whose ID you want.
    """"""
    tokens = token.contents.split()
    if len(tokens) < 4:
        raise template.TemplateSyntaxError(
            ""'get_admin_log' statements require two arguments""
        )
    if not tokens[1].isdigit():
        raise template.TemplateSyntaxError(
            ""First argument to 'get_admin_log' must be an integer""
        )
    if tokens[2] != ""as"":
        raise template.TemplateSyntaxError(
            ""Second argument to 'get_admin_log' must be 'as'""
        )
    if len(tokens) > 4:
        if tokens[4] != ""for_user"":
            raise template.TemplateSyntaxError(
                ""Fourth argument to 'get_admin_log' must be 'for_user'""
            )
    return AdminLogNode(
        limit=tokens[1],
        varname=tokens[3],
        user=(tokens[5] if len(tokens) > 5 else None),
    )<EOS>"
"<BOS>from urllib.parse import parse_qsl, unquote, urlparse, urlunparse

from django import template
from django.contrib.admin.utils import quote
from django.urls import Resolver404, get_script_prefix, resolve
from django.utils.http import urlencode

register = template.Library()


@register.filter
def admin_urlname(value, arg):
    return ""admin:%s_%s_%s"" % (value.app_label, value.model_name, arg)


@register.filter
def admin_urlquote(value):
    return quote(value)


@register.simple_tag(takes_context=True)
def add_preserved_filters(context, url, popup=False, to_field=None):
    opts = context.get(""opts"")
    preserved_filters = context.get(""preserved_filters"")

    parsed_url = list(urlparse(url))
    parsed_qs = dict(parse_qsl(parsed_url[4]))
    merged_qs = {}

    if opts and preserved_filters:
        preserved_filters = dict(parse_qsl(preserved_filters))

        match_url = ""/%s"" % unquote(url).partition(get_script_prefix())[2]
        try:
            match = resolve(match_url)
        except Resolver404:
            pass
        else:
            current_url = ""%s:%s"" % (match.app_name, match.url_name)
            changelist_url = ""admin:%s_%s_changelist"" % (
                opts.app_label,
                opts.model_name,
            )
            if (
                changelist_url == current_url
                and ""_changelist_filters"" in preserved_filters
            ):
                preserved_filters = dict(
                    parse_qsl(preserved_filters[""_changelist_filters""])
                )

        merged_qs.update(preserved_filters)

    if popup:
        from django.contrib.admin.options import IS_POPUP_VAR

        merged_qs[IS_POPUP_VAR] = 1
    if to_field:
        from django.contrib.admin.options import TO_FIELD_VAR

        merged_qs[TO_FIELD_VAR] = to_field

    merged_qs.update(parsed_qs)

    parsed_url[4] = urlencode(merged_qs)
    return urlunparse(parsed_url)<EOS>"
"<BOS>import datetime

from django.conf import settings
from django.contrib.admin.templatetags.admin_urls import add_preserved_filters
from django.contrib.admin.utils import (
    display_for_field,
    display_for_value,
    get_fields_from_path,
    label_for_field,
    lookup_field,
)
from django.contrib.admin.views.main import (
    ALL_VAR,
    IS_POPUP_VAR,
    ORDER_VAR,
    PAGE_VAR,
    SEARCH_VAR,
)
from django.core.exceptions import ObjectDoesNotExist
from django.db import models
from django.template import Library
from django.template.loader import get_template
from django.templatetags.static import static
from django.urls import NoReverseMatch
from django.utils import formats, timezone
from django.utils.html import format_html
from django.utils.safestring import mark_safe
from django.utils.text import capfirst
from django.utils.translation import gettext as _

from .base import InclusionAdminNode

register = Library()


@register.simple_tag
def paginator_number(cl, i):
    """"""
    Generate an individual page index link in a paginated list.
    """"""
    if i == cl.paginator.ELLIPSIS:
        return format_html(""{} "", cl.paginator.ELLIPSIS)
    elif i == cl.page_num:
        return format_html('<span class=""this-page"">{}</span> ', i)
    else:
        return format_html(
            '<a href=""{}""{}>{}</a> ',
            cl.get_query_string({PAGE_VAR: i}),
            mark_safe(' class=""end""' if i == cl.paginator.num_pages else """"),
            i,
        )


def pagination(cl):
    """"""
    Generate the series of links to the pages in a paginated list.
    """"""
    pagination_required = (not cl.show_all or not cl.can_show_all) and cl.multi_page
    page_range = (
        cl.paginator.get_elided_page_range(cl.page_num) if pagination_required else []
    )
    need_show_all_link = cl.can_show_all and not cl.show_all and cl.multi_page
    return {
        ""cl"": cl,
        ""pagination_required"": pagination_required,
        ""show_all_url"": need_show_all_link and cl.get_query_string({ALL_VAR: """"}),
        ""page_range"": page_range,
        ""ALL_VAR"": ALL_VAR,
        ""1"": 1,
    }


@register.tag(name=""pagination"")
def pagination_tag(parser, token):
    return InclusionAdminNode(
        parser,
        token,
        func=pagination,
        template_name=""pagination.html"",
        takes_context=False,
    )


def result_headers(cl):
    """"""
    Generate the list column headers.
    """"""
    ordering_field_columns = cl.get_ordering_field_columns()
    for i, field_name in enumerate(cl.list_display):
        text, attr = label_for_field(
            field_name, cl.model, model_admin=cl.model_admin, return_attr=True
        )
        is_field_sortable = cl.sortable_by is None or field_name in cl.sortable_by
        if attr:
            field_name = _coerce_field_name(field_name, i)
            # Potentially not sortable

            # if the field is the action checkbox: no sorting and special class
            if field_name == ""action_checkbox"":
                yield {
                    ""text"": text,
                    ""class_attrib"": mark_safe(' class=""action-checkbox-column""'),
                    ""sortable"": False,
                }
                continue

            admin_order_field = getattr(attr, ""admin_order_field"", None)
            # Set ordering for attr that is a property, if defined.
            if isinstance(attr, property) and hasattr(attr, ""fget""):
                admin_order_field = getattr(attr.fget, ""admin_order_field"", None)
            if not admin_order_field:
                is_field_sortable = False

        if not is_field_sortable:
            # Not sortable
            yield {
                ""text"": text,
                ""class_attrib"": format_html(' class=""column-{}""', field_name),
                ""sortable"": False,
            }
            continue

        # OK, it is sortable if we got this far
        th_classes = [""sortable"", ""column-{}"".format(field_name)]
        order_type = """"
        new_order_type = ""asc""
        sort_priority = 0
        # Is it currently being sorted on?
        is_sorted = i in ordering_field_columns
        if is_sorted:
            order_type = ordering_field_columns.get(i).lower()
            sort_priority = list(ordering_field_columns).index(i) + 1
            th_classes.append(""sorted %sending"" % order_type)
            new_order_type = {""asc"": ""desc"", ""desc"": ""asc""}[order_type]

        # build new ordering param
        o_list_primary = []  # URL for making this field the primary sort
        o_list_remove = []  # URL for removing this field from sort
        o_list_toggle = []  # URL for toggling order type for this field

        def make_qs_param(t, n):
            return (""-"" if t == ""desc"" else """") + str(n)

        for j, ot in ordering_field_columns.items():
            if j == i:  # Same column
                param = make_qs_param(new_order_type, j)
                # We want clicking on this header to bring the ordering to the
                # front
                o_list_primary.insert(0, param)
                o_list_toggle.append(param)
                # o_list_remove - omit
            else:
                param = make_qs_param(ot, j)
                o_list_primary.append(param)
                o_list_toggle.append(param)
                o_list_remove.append(param)

        if i not in ordering_field_columns:
            o_list_primary.insert(0, make_qs_param(new_order_type, i))

        yield {
            ""text"": text,
            ""sortable"": True,
            ""sorted"": is_sorted,
            ""ascending"": order_type == ""asc"",
            ""sort_priority"": sort_priority,
            ""url_primary"": cl.get_query_string({ORDER_VAR: ""."".join(o_list_primary)}),
            ""url_remove"": cl.get_query_string({ORDER_VAR: ""."".join(o_list_remove)}),
            ""url_toggle"": cl.get_query_string({ORDER_VAR: ""."".join(o_list_toggle)}),
            ""class_attrib"": format_html(' class=""{}""', "" "".join(th_classes))
            if th_classes
            else """",
        }


def _boolean_icon(field_val):
    icon_url = static(
        ""admin/img/icon-%s.svg"" % {True: ""yes"", False: ""no"", None: ""unknown""}[field_val]
    )
    return format_html('<img src=""{}"" alt=""{}"">', icon_url, field_val)


def _coerce_field_name(field_name, field_index):
    """"""
    Coerce a field_name (which may be a callable) to a string.
    """"""
    if callable(field_name):
        if field_name.__name__ == ""<lambda>"":
            return ""lambda"" + str(field_index)
        else:
            return field_name.__name__
    return field_name


def items_for_result(cl, result, form):
    """"""
    Generate the actual list of data.
    """"""

    def link_in_col(is_first, field_name, cl):
        if cl.list_display_links is None:
            return False
        if is_first and not cl.list_display_links:
            return True
        return field_name in cl.list_display_links

    first = True
    pk = cl.lookup_opts.pk.attname
    for field_index, field_name in enumerate(cl.list_display):
        empty_value_display = cl.model_admin.get_empty_value_display()
        row_classes = [""field-%s"" % _coerce_field_name(field_name, field_index)]
        try:
            f, attr, value = lookup_field(field_name, result, cl.model_admin)
        except ObjectDoesNotExist:
            result_repr = empty_value_display
        else:
            empty_value_display = getattr(
                attr, ""empty_value_display"", empty_value_display
            )
            if f is None or f.auto_created:
                if field_name == ""action_checkbox"":
                    row_classes = [""action-checkbox""]
                boolean = getattr(attr, ""boolean"", False)
                result_repr = display_for_value(value, empty_value_display, boolean)
                if isinstance(value, (datetime.date, datetime.time)):
                    row_classes.append(""nowrap"")
            else:
                if isinstance(f.remote_field, models.ManyToOneRel):
                    field_val = getattr(result, f.name)
                    if field_val is None:
                        result_repr = empty_value_display
                    else:
                        result_repr = field_val
                else:
                    result_repr = display_for_field(value, f, empty_value_display)
                if isinstance(
                    f, (models.DateField, models.TimeField, models.ForeignKey)
                ):
                    row_classes.append(""nowrap"")
        row_class = mark_safe(' class=""%s""' % "" "".join(row_classes))
        # If list_display_links not defined, add the link tag to the first field
        if link_in_col(first, field_name, cl):
            table_tag = ""th"" if first else ""td""
            first = False

            # Display link to the result's change_view if the url exists, else
            # display just the result's representation.
            try:
                url = cl.url_for_result(result)
            except NoReverseMatch:
                link_or_text = result_repr
            else:
                url = add_preserved_filters(
                    {""preserved_filters"": cl.preserved_filters, ""opts"": cl.opts}, url
                )
                # Convert the pk to something that can be used in JavaScript.
                # Problem cases are non-ASCII strings.
                if cl.to_field:
                    attr = str(cl.to_field)
                else:
                    attr = pk
                value = result.serializable_value(attr)
                link_or_text = format_html(
                    '<a href=""{}""{}>{}</a>',
                    url,
                    format_html(' data-popup-opener=""{}""', value)
                    if cl.is_popup
                    else """",
                    result_repr,
                )

            yield format_html(
                ""<{}{}>{}</{}>"", table_tag, row_class, link_or_text, table_tag
            )
        else:
            # By default the fields come from ModelAdmin.list_editable, but if we pull
            # the fields out of the form instead of list_editable custom admins
            # can provide fields on a per request basis
            if (
                form
                and field_name in form.fields
                and not (
                    field_name == cl.model._meta.pk.name
                    and form[cl.model._meta.pk.name].is_hidden
                )
            ):
                bf = form[field_name]
                result_repr = mark_safe(str(bf.errors) + str(bf))
            yield format_html(""<td{}>{}</td>"", row_class, result_repr)
    if form and not form[cl.model._meta.pk.name].is_hidden:
        yield format_html(""<td>{}</td>"", form[cl.model._meta.pk.name])


class ResultList(list):
    """"""
    Wrapper class used to return items in a list_editable changelist, annotated
    with the form object for error reporting purposes. Needed to maintain
    backwards compatibility with existing admin templates.
    """"""

    def __init__(self, form, *items):
        self.form = form
        super().__init__(*items)


def results(cl):
    if cl.formset:
        for res, form in zip(cl.result_list, cl.formset.forms):
            yield ResultList(form, items_for_result(cl, res, form))
    else:
        for res in cl.result_list:
            yield ResultList(None, items_for_result(cl, res, None))


def result_hidden_fields(cl):
    if cl.formset:
        for res, form in zip(cl.result_list, cl.formset.forms):
            if form[cl.model._meta.pk.name].is_hidden:
                yield mark_safe(form[cl.model._meta.pk.name])


def result_list(cl):
    """"""
    Display the headers and data list together.
    """"""
    headers = list(result_headers(cl))
    num_sorted_fields = 0
    for h in headers:
        if h[""sortable""] and h[""sorted""]:
            num_sorted_fields += 1
    return {
        ""cl"": cl,
        ""result_hidden_fields"": list(result_hidden_fields(cl)),
        ""result_headers"": headers,
        ""num_sorted_fields"": num_sorted_fields,
        ""results"": list(results(cl)),
    }


@register.tag(name=""result_list"")
def result_list_tag(parser, token):
    return InclusionAdminNode(
        parser,
        token,
        func=result_list,
        template_name=""change_list_results.html"",
        takes_context=False,
    )


def date_hierarchy(cl):
    """"""
    Display the date hierarchy for date drill-down functionality.
    """"""
    if cl.date_hierarchy:
        field_name = cl.date_hierarchy
        field = get_fields_from_path(cl.model, field_name)[-1]
        if isinstance(field, models.DateTimeField):
            dates_or_datetimes = ""datetimes""
            qs_kwargs = {""is_dst"": True} if settings.USE_DEPRECATED_PYTZ else {}
        else:
            dates_or_datetimes = ""dates""
            qs_kwargs = {}
        year_field = ""%s__year"" % field_name
        month_field = ""%s__month"" % field_name
        day_field = ""%s__day"" % field_name
        field_generic = ""%s__"" % field_name
        year_lookup = cl.params.get(year_field)
        month_lookup = cl.params.get(month_field)
        day_lookup = cl.params.get(day_field)

        def link(filters):
            return cl.get_query_string(filters, [field_generic])

        if not (year_lookup or month_lookup or day_lookup):
            # select appropriate start level
            date_range = cl.queryset.aggregate(
                first=models.Min(field_name), last=models.Max(field_name)
            )
            if date_range[""first""] and date_range[""last""]:
                if dates_or_datetimes == ""datetimes"":
                    date_range = {
                        k: timezone.localtime(v) if timezone.is_aware(v) else v
                        for k, v in date_range.items()
                    }
                if date_range[""first""].year == date_range[""last""].year:
                    year_lookup = date_range[""first""].year
                    if date_range[""first""].month == date_range[""last""].month:
                        month_lookup = date_range[""first""].month

        if year_lookup and month_lookup and day_lookup:
            day = datetime.date(int(year_lookup), int(month_lookup), int(day_lookup))
            return {
                ""show"": True,
                ""back"": {
                    ""link"": link({year_field: year_lookup, month_field: month_lookup}),
                    ""title"": capfirst(formats.date_format(day, ""YEAR_MONTH_FORMAT"")),
                },
                ""choices"": [
                    {""title"": capfirst(formats.date_format(day, ""MONTH_DAY_FORMAT""))}
                ],
            }
        elif year_lookup and month_lookup:
            days = getattr(cl.queryset, dates_or_datetimes)(
                field_name, ""day"", **qs_kwargs
            )
            return {
                ""show"": True,
                ""back"": {
                    ""link"": link({year_field: year_lookup}),
                    ""title"": str(year_lookup),
                },
                ""choices"": [
                    {
                        ""link"": link(
                            {
                                year_field: year_lookup,
                                month_field: month_lookup,
                                day_field: day.day,
                            }
                        ),
                        ""title"": capfirst(formats.date_format(day, ""MONTH_DAY_FORMAT"")),
                    }
                    for day in days
                ],
            }
        elif year_lookup:
            months = getattr(cl.queryset, dates_or_datetimes)(
                field_name, ""month"", **qs_kwargs
            )
            return {
                ""show"": True,
                ""back"": {""link"": link({}), ""title"": _(""All dates"")},
                ""choices"": [
                    {
                        ""link"": link(
                            {year_field: year_lookup, month_field: month.month}
                        ),
                        ""title"": capfirst(
                            formats.date_format(month, ""YEAR_MONTH_FORMAT"")
                        ),
                    }
                    for month in months
                ],
            }
        else:
            years = getattr(cl.queryset, dates_or_datetimes)(
                field_name, ""year"", **qs_kwargs
            )
            return {
                ""show"": True,
                ""back"": None,
                ""choices"": [
                    {
                        ""link"": link({year_field: str(year.year)}),
                        ""title"": str(year.year),
                    }
                    for year in years
                ],
            }


@register.tag(name=""date_hierarchy"")
def date_hierarchy_tag(parser, token):
    return InclusionAdminNode(
        parser,
        token,
        func=date_hierarchy,
        template_name=""date_hierarchy.html"",
        takes_context=False,
    )


def search_form(cl):
    """"""
    Display a search form for searching the list.
    """"""
    return {
        ""cl"": cl,
        ""show_result_count"": cl.result_count != cl.full_result_count,
        ""search_var"": SEARCH_VAR,
        ""is_popup_var"": IS_POPUP_VAR,
    }


@register.tag(name=""search_form"")
def search_form_tag(parser, token):
    return InclusionAdminNode(
        parser,
        token,
        func=search_form,
        template_name=""search_form.html"",
        takes_context=False,
    )


@register.simple_tag
def admin_list_filter(cl, spec):
    tpl = get_template(spec.template)
    return tpl.render(
        {
            ""title"": spec.title,
            ""choices"": list(spec.choices(cl)),
            ""spec"": spec,
        }
    )


def admin_actions(context):
    """"""
    Track the number of times the action field has been rendered on the page,
    so we know which value to use.
    """"""
    context[""action_index""] = context.get(""action_index"", -1) + 1
    return context


@register.tag(name=""admin_actions"")
def admin_actions_tag(parser, token):
    return InclusionAdminNode(
        parser, token, func=admin_actions, template_name=""actions.html""
    )


@register.tag(name=""change_list_object_tools"")
def change_list_object_tools_tag(parser, token):
    """"""Display the row of change list object tools.""""""
    return InclusionAdminNode(
        parser,
        token,
        func=lambda context: context,
        template_name=""change_list_object_tools.html"",
    )<EOS>"
"<BOS>import json

from django import template
from django.template.context import Context

from .base import InclusionAdminNode

register = template.Library()


def prepopulated_fields_js(context):
    """"""
    Create a list of prepopulated_fields that should render JavaScript for
    the prepopulated fields for both the admin form and inlines.
    """"""
    prepopulated_fields = []
    if ""adminform"" in context:
        prepopulated_fields.extend(context[""adminform""].prepopulated_fields)
    if ""inline_admin_formsets"" in context:
        for inline_admin_formset in context[""inline_admin_formsets""]:
            for inline_admin_form in inline_admin_formset:
                if inline_admin_form.original is None:
                    prepopulated_fields.extend(inline_admin_form.prepopulated_fields)

    prepopulated_fields_json = []
    for field in prepopulated_fields:
        prepopulated_fields_json.append(
            {
                ""id"": ""#%s"" % field[""field""].auto_id,
                ""name"": field[""field""].name,
                ""dependency_ids"": [
                    ""#%s"" % dependency.auto_id for dependency in field[""dependencies""]
                ],
                ""dependency_list"": [
                    dependency.name for dependency in field[""dependencies""]
                ],
                ""maxLength"": field[""field""].field.max_length or 50,
                ""allowUnicode"": getattr(field[""field""].field, ""allow_unicode"", False),
            }
        )

    context.update(
        {
            ""prepopulated_fields"": prepopulated_fields,
            ""prepopulated_fields_json"": json.dumps(prepopulated_fields_json),
        }
    )
    return context


@register.tag(name=""prepopulated_fields_js"")
def prepopulated_fields_js_tag(parser, token):
    return InclusionAdminNode(
        parser,
        token,
        func=prepopulated_fields_js,
        template_name=""prepopulated_fields_js.html"",
    )


def submit_row(context):
    """"""
    Display the row of buttons for delete and save.
    """"""
    add = context[""add""]
    change = context[""change""]
    is_popup = context[""is_popup""]
    save_as = context[""save_as""]
    show_save = context.get(""show_save"", True)
    show_save_and_add_another = context.get(""show_save_and_add_another"", True)
    show_save_and_continue = context.get(""show_save_and_continue"", True)
    has_add_permission = context[""has_add_permission""]
    has_change_permission = context[""has_change_permission""]
    has_view_permission = context[""has_view_permission""]
    has_editable_inline_admin_formsets = context[""has_editable_inline_admin_formsets""]
    can_save = (
        (has_change_permission and change)
        or (has_add_permission and add)
        or has_editable_inline_admin_formsets
    )
    can_save_and_add_another = (
        has_add_permission
        and not is_popup
        and (not save_as or add)
        and can_save
        and show_save_and_add_another
    )
    can_save_and_continue = (
        not is_popup and can_save and has_view_permission and show_save_and_continue
    )
    can_change = has_change_permission or has_editable_inline_admin_formsets
    ctx = Context(context)
    ctx.update(
        {
            ""can_change"": can_change,
            ""show_delete_link"": (
                not is_popup
                and context[""has_delete_permission""]
                and change
                and context.get(""show_delete"", True)
            ),
            ""show_save_as_new"": not is_popup
            and has_change_permission
            and change
            and save_as,
            ""show_save_and_add_another"": can_save_and_add_another,
            ""show_save_and_continue"": can_save_and_continue,
            ""show_save"": show_save and can_save,
            ""show_close"": not (show_save and can_save),
        }
    )
    return ctx


@register.tag(name=""submit_row"")
def submit_row_tag(parser, token):
    return InclusionAdminNode(
        parser, token, func=submit_row, template_name=""submit_line.html""
    )


@register.tag(name=""change_form_object_tools"")
def change_form_object_tools_tag(parser, token):
    """"""Display the row of change form object tools.""""""
    return InclusionAdminNode(
        parser,
        token,
        func=lambda context: context,
        template_name=""change_form_object_tools.html"",
    )


@register.filter
def cell_count(inline_admin_form):
    """"""Return the number of cells used in a tabular inline.""""""
    count = 1  # Hidden cell with hidden 'id' field
    for fieldset in inline_admin_form:
        # Count all visible fields.
        for line in fieldset:
            for field in line:
                try:
                    is_hidden = field.field.is_hidden
                except AttributeError:
                    is_hidden = field.field[""is_hidden""]
                if not is_hidden:
                    count += 1
    if inline_admin_form.formset.can_delete:
        # Delete checkbox
        count += 1
    return count<EOS>"
